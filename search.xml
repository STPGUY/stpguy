<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[AFOI]区间与除法</title>
    <url>/AlanTuringLi/2020/09/16/AFOI-%E5%8C%BA%E9%97%B4%E4%B8%8E%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AFOI-区间与除法"><a href="#AFOI-区间与除法" class="headerlink" title="[AFOI]区间与除法"></a><a href="https://www.luogu.com.cn/problem/P5629">[AFOI]区间与除法</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个序列$A$, 叫操作序列, 序列$B$, 叫原序列</p>
<p>给定一个除数$d$, 若$A_i$能够通过不断整除$d$变成$B_j$, 那么就称作$A_i$可以被$B_j$消除</p>
<p>有$q$次询问, 每次询问给定一个区间$[l,r]$</p>
<p>求在区间$[l,r]$中至少需要多少个原数才能消除$A_l\sim A_r$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>拿着题的第一想法是把所有的$A$去操作一下, 得到可行的原数, 然后就能得到一个二进制数表示分别能被那些原数消除, 然后再贪心的求得答案</p>
<p>显然这样做是不好实现的</p>
<p><del>于是看看题解</del></p>
<p>真的是绝了!</p>
<p>那么久转化一下思路, 我们似乎可以把所有的数看成一个$d$进制的数</p>
<p>似乎这样就简单多了, 只要原数是$A_i$的某个前缀就可以了</p>
<p>如果某个原数是某个原数的<strong>真</strong>前缀, 那么我们只需要被包含的那个前缀即可</p>
<p>所以, 我们最后得到的每个$A_i$对应的原数一定是唯一的</p>
<p>那么这个时候, 直接或起来, 求这个二进制数有多少个$1$即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m, d, q;</span><br><span class="line">ll a[maxn], ys[maxn];</span><br><span class="line">ll f[maxn][<span class="number">22</span>], log_[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> Ch[maxn][<span class="number">15</span>], end[maxn], id;</span><br><span class="line"><span class="type">int</span> stk[maxn], top, cnt;</span><br><span class="line"><span class="type">bool</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cf</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        stk[++top] = x % d;</span><br><span class="line">        x /= d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cf</span>(x);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top; i; --i) &#123;</span><br><span class="line">        <span class="type">int</span> now = stk[i];</span><br><span class="line">        <span class="keyword">if</span> (!Ch[root][now]) Ch[root][now] = ++id;</span><br><span class="line">        root = Ch[root][now];</span><br><span class="line">        <span class="keyword">if</span> (end[root]) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    end[root] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cf</span>(x);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top; i; --i) &#123;</span><br><span class="line">        <span class="type">int</span> now = stk[i];</span><br><span class="line">        <span class="keyword">if</span> (!Ch[root][now]) <span class="keyword">break</span>;</span><br><span class="line">        root = Ch[root][now];</span><br><span class="line">        <span class="keyword">if</span> (end[root]) <span class="keyword">return</span> end[root]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read(), d = __read(), q = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ys[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">Insert</span>(ys[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">Query</span>(a[i]);</span><br><span class="line">        log_[i] = log_[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (~k) f[i][<span class="number">0</span>] = (<span class="number">1ll</span> &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= log_[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] | f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> l = __read(), r = __read();</span><br><span class="line">        <span class="type">int</span> len = log_[r - l + <span class="number">1</span>];</span><br><span class="line">        ll ans = f[l][len] | f[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len];</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ans) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &amp; <span class="number">1</span>) ++cnt;</span><br><span class="line">            ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字典树</tag>
        <tag>贪心</tag>
        <tag>RMQ</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>[APIO2014]序列分割</title>
    <url>/AlanTuringLi/2020/10/06/APIO2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="APIO2014-序列分割"><a href="#APIO2014-序列分割" class="headerlink" title="[APIO2014]序列分割"></a><a href="https://www.luogu.com.cn/problem/P3648">[APIO2014]序列分割</a></h1><p>可以直接看一下式子：</p>
<script type="math/tex; mode=display">
f(i,k)=\min_{j=1}^{i=1}\{f(j,k-1)+s_j(s_i-s_j)\}</script><p>因为这个只与上一维的状态有关，所以是可以滚掉一维的，那么令上一维的状态为$g$，这一维的状态就为$f$</p>
<p>考虑此时的最优决策点$(j&lt;k)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(j)+s_j(s_i-s_j)&> g(k)+s_k(s_i-s_k)\\
g(j)+s_js_i-{s_j}^2&> g(k)+s_ks_i-{s_k}^2\\
(g(j)-{s_j}^2)-(g(k)-{s_k}^2)&> s_i(s_k-s_j)\\
\frac {(g(j)-{s_j}^2)-(g(k)-{s_k}^2)}{s_k-s_j}&> s_i
\end{aligned}</script><p>然后注意到，这个$s_i$一定是单调递增的，所以可以直接用队列维护斜率单增</p>
<p>然后就写完了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll s[maxn], f[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="type">int</span> __pre[maxn][<span class="number">205</span>], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll y1 = f[t][x] - s[x] * s[x], x1 = s[x];</span><br><span class="line">    ll y2 = f[t][y] - s[y] * s[y], x2 = s[y];</span><br><span class="line">    <span class="keyword">if</span> (x1 == x2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">double</span> (y1 - y2) / (x2 - x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read(), k = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + __read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">t</span><span class="params">(j &amp; <span class="number">1</span>)</span></span>;</span><br><span class="line">        q[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">Slope</span>(q[l], q[l + <span class="number">1</span>], t ^ <span class="number">1</span>) &lt;= s[i]) ++l;</span><br><span class="line">            __pre[i][j] = q[l];</span><br><span class="line">            f[t][i] = f[t ^ <span class="number">1</span>][q[l]] + s[q[l]] * (s[i] - s[q[l]]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">Slope</span>(q[r - <span class="number">1</span>], q[r], t ^ <span class="number">1</span>) &gt;= <span class="built_in">Slope</span>(q[r], i, t ^ <span class="number">1</span>)) --r;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, f[k &amp; <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = n; k; --k) p = __pre[p][k], <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC102D</title>
    <url>/AlanTuringLi/2020/11/22/ARC102D/</url>
    <content><![CDATA[<h1 id="ARC102D"><a href="#ARC102D" class="headerlink" title="ARC102D"></a><a href="https://www.luogu.com.cn/problem/AT4363">ARC102D</a></h1><p>考虑一次交换操作从 $c,b,a$ 变成 $a,b,c$，减少了 $3$ 对逆序对 $(c,b),c(c,a),(b,a)$，然后一次操作也不会改变一个点的位置的奇偶性。</p>
<p>这指明了两条信息：</p>
<ul>
<li>点权与位置的奇偶性应当相同。</li>
<li>逆序对的对数应当是 $3$ 的倍数。</li>
</ul>
<p>当然，只有这两个条件是远远不够的，然后还可以发现每一次操作，会减少一对奇偶性相同的逆序对。</p>
<p>所以奇数与偶数的逆序对数之和应当是逆序对的三分之一。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, tmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t[maxn], ans;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">Tree</span> () &#123;</span><br><span class="line">        <span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">			t[x] += <span class="number">1</span>;</span><br><span class="line">			x += <span class="built_in">lowbit</span>(x);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			res += t[x];</span><br><span class="line">			x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">	   x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		tmp = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">		T[i &amp; <span class="number">1</span>].ans += T[i &amp; <span class="number">1</span>].<span class="built_in">query</span>(n - tmp + <span class="number">1</span>);</span><br><span class="line">		T[<span class="number">2</span>].ans += T[<span class="number">2</span>].<span class="built_in">query</span>(n - tmp + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		T[i &amp; <span class="number">1</span>].<span class="built_in">update</span>(n - tmp + <span class="number">1</span>);</span><br><span class="line">		T[<span class="number">2</span>].<span class="built_in">update</span>(n - tmp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((tmp &amp; <span class="number">1</span>) ^ (i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (T[<span class="number">2</span>].ans == (T[<span class="number">0</span>].ans + T[<span class="number">1</span>].ans) * <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1139D</title>
    <url>/AlanTuringLi/2020/10/15/CF1139D/</url>
    <content><![CDATA[<h1 id="CF1139D-Step-to-One"><a href="#CF1139D-Step-to-One" class="headerlink" title="CF1139D Step to One"></a><a href="https://www.luogu.com.cn/problem/CF1139D">CF1139D Step to One</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你手中有集合 ${1,2,3\cdots,n}$，然后每一次操作你都会从数集中等概率抽取一个数放到新的序列中，直到新的序列的 $\gcd$ 的值为 $1$。</p>
<p>求你的期望操作次数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题十分的精妙，它集合了数学期望还有莫比乌斯反演，十分考验 $OIER$ 的基础能力</p>
<h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><p>首先知道，$E(x)$ 表示对于事件 $x$ 的数学期望， $P(x)$ 表示事件 $x$ 的概率</p>
<p>那么有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E(\gcd=1)&=\sum_{i\ge 1}E(len=i)
\\&=\sum_{i\ge1}P(len=i)\times i\\
&=\sum_{i\ge1}P(len=i)\sum_{j=1}^i1\\
&=\sum_{j\ge1}\sum_{i\ge j}P(len = i)\\
&=\sum_{j\ge1}P(len \ge j)\\
&=\sum_{j\ge1}P(len=j)+\sum_{j\ge1}P(len > j)
\\&=1+\sum_{j\ge1}P(len > j)
\end{aligned}</script><p>这个步骤，就是期望步数（概率 * 步数），显然就是期望公式$E(x+y)=E(x)+E(y)$</p>
<p>其中 $len$ 表示达到 $\gcd=1$ 花费的步数</p>
<p>那么重点就是这个$\sum_{j\ge1}P(len&gt;j)$该如何处理了</p>
<p>想要 $len&gt;j$ 那么可以理解为长度为 $j$ 时的 $\gcd&gt;1$ </p>
<p>所以可以有如下化简：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(len>j)&={j\ge1}P(\gcd_{i=1}^ja_i>1)\\
&=1-P(\gcd_{i=1}^ja_i=1)\\
&=1-\frac1{n^j}\sum_{a_1=1}^n\sum_{a_2=1}^n\cdots\sum_{a_j=1}^n[\gcd_{i=1}^ja_i==1]
\end{aligned}</script><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>这个和之前的<a href="https://alansblog.ink/2020/10/12/SP7001-VLATTICE-Visible-Lattice-Points/">某道题</a>有点像，所以化简过程就不写了，所以就可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(len>j)&=1-\frac1{n^j}\sum_{a_1=1}^n\sum_{a_2=1}^n\cdots\sum_{a_j=1}^n[\gcd_{i=1}^ja_i==1]\\
&=1-\frac1{n^j}\sum_{d=1}^n\mu(d)[\frac nd]^j\\
&=-\frac1{n^j}\sum_{d=2}^n\mu(d)[\frac nd]^j
\end{aligned}</script><p>这一步也很显然</p>
<p>那么现在就可以带回数学期望的式子里，可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E(\gcd=1)&=1+\sum_{j\ge1}P(len>j)\\
&=1-\sum_{j\ge1}\frac1{n^j}\sum_{d=2}^n\mu(d)[\frac nd]\\
&=1-\sum_{d=2}^n\mu(d)\sum_{j\ge1}(\frac {[\frac nd]}n)^j\\
&=1-\sum_{d=2}^n\mu(d)\frac{[\frac nd]}{n-[\frac nd]}
\end{aligned}</script><p>那么最后数论分块 + 线性筛逆元一下就可以了，时间复杂度 $O(\sqrt n)$，但是其实也是可以 $O(n)$ 做的，毕竟数据范围很小</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mu[maxn], inv[maxn];</span><br><span class="line"><span class="type">int</span> pr[maxn], cnt, <span class="built_in">ans</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">        inv[i] = <span class="number">1ll</span> * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        <span class="type">int</span> temp = n / l;</span><br><span class="line">        ans = ((ans - <span class="number">1ll</span> * (mu[r] - mu[l - <span class="number">1</span>]) % mod * temp % mod * inv[n - temp] % mod) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ((ans % mod) + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>期望Dp</tag>
        <tag>期望</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>CF920G List of Integers</title>
    <url>/AlanTuringLi/2020/09/25/CF920G/</url>
    <content><![CDATA[<h1 id="List-of-Intergers"><a href="#List-of-Intergers" class="headerlink" title="List of Intergers"></a><a href="https://www.luogu.com.cn/problem/CF920G">List of Intergers</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求第$k$大的大于等于 $x$ 且与 $p$ 互质的数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>即，求最小的 $y$ 使：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]-\sum_{i=1}^x[i\perp p]=k</script><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>那么看见这个形式，自然而然地会想到这个东西：$\mu*1=\epsilon$</p>
<p>所以就可以把 $[i\perp p]$ 写成：</p>
<script type="math/tex; mode=display">
\sum_{d|\gcd(i,p)}\mu(d)</script><p>那么交求和顺序，先枚举 $p$ 的因子 $d$，可以得到:</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^y[i\perp p]&=\sum_{i=1}^y\sum_{d|\gcd(i,p)}\mu(d)\\
&=\sum_{d|p}\mu(d)\sum_{i=1}^\left\lfloor\frac y d\right\rfloor1
\\&=\sum_{d|p}\mu(d)\left\lfloor\frac y d\right\rfloor
\end{align*}</script><p>那么，这个时候，后面这一块，已经是十分好求的了，可以直接枚举 $\sqrt y$ 范围内 $y$ 的因子(顺便得到 $&gt;\sqrt y$ )的因子，按照这个直接加就可以了</p>
<h2 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h2><p>还是考虑$[i\perp p]$，换一种写法呢就是$[\gcd(i,p)==1]$</p>
<p>那么就是说，不合法的就是$\gcd(i,p) &gt; 1$</p>
<p>那么按照套路，还是应该用总共的减去不合法的，</p>
<p>那么就要枚举$p$的每个因子对答案的贡献</p>
<p>同样的，还是可以得到容斥系数就是$\mu$</p>
<p>那么还是能够得到同一个式子：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]=\sum_{d|p}^y\mu(d)\left\lfloor\frac y d\right\rfloor</script><p>当然，这并不是巧合，有兴趣的同学可以自行了解一下(<del>我也说不清</del>)</p>
<p>时间复杂度为$O(n\log n\sqrt n)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mu[maxn], pr[maxn], cnt, line;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l * l &lt;= x; ++l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % l) <span class="keyword">continue</span>;</span><br><span class="line">        ans += mu[l] * (n / l);</span><br><span class="line">        <span class="keyword">if</span> (l * l &lt; x) ans += mu[x / l] * (n / (x / l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> x = __read(), p = __read(), k = __read();</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">1e7</span>)</span>, <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        line = <span class="built_in">Query</span>(x, p);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Query</span>(mid, p) - line &gt;= k) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UPT：</strong>有位机房巨佬认为我写的这个是有点小问题的，我觉得这个可以解释一下</p>
<p>他的意思是按照样例给的$7\;22\;1$，我的$Query$函数求得的$9$和$10$的答案都是$5$，那么为什么我取得的是$9$而不是$10$，然后$10$与$22$并不互质，为什么对$10$还有答案呢？</p>
<p>回到最开头，有这样一个东西：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]-\sum_{i=1}^x[i\perp p]=k</script><p>会发现，我们求得的值，并不是说$y$是第几个，我们求得的值是在$[1,y]$有几个</p>
<p>令：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=1}^x[i\perp p]</script><p>当$f(y)-f(y-1)=1$时，当且仅当$[y\perp p]=1$，所以，我们二分答案要取的是第一个满足条件的数</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>容斥</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CF932D Tree</title>
    <url>/AlanTuringLi/2020/09/04/CF932D/</url>
    <content><![CDATA[<h1 id="CF932D-Tree"><a href="#CF932D-Tree" class="headerlink" title="CF932D Tree"></a><a href="https://www.luogu.com.cn/problem/CF932D">CF932D Tree</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><ul>
<li>首先，我们有$Q$次操作</li>
</ul>
<blockquote>
<ul>
<li>操作$1$：在节点$R$下面再加一个权值为$W$的点</li>
<li>操作$2$：询问从点$X$开始往上走，（每次遇到权值大于当前选过的最后一个点的点必定会选），问最多能选多少点</li>
</ul>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以很容易的发现，我们选中的点一定是一个单调不下降序列</p>
<p>那么就是说，我们可以稍微改动一下操作一，让每一条链都一定是单调不上升的（从根出发的链）</p>
<p>然后，我们每次加入的点必定不会是已经存在的某个点的祖先，所以我们改变他的位置对原来的树是没有影响的</p>
<p>若有节点成为了这个被我们认为操作的节点的儿子，它的值依赖于我们人为操作的那个点，所以这个答案也不会因为我们的操作出现问题</p>
<p>那么我们就可以在加入节点的时候，找到第一个权值大于该节点的点做为这个点的父节点</p>
<p>顺便跟新一下前缀和</p>
<p>这个用倍增实现就好了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查询的话，能跳就跳，每次向上跳了更新一下限制即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);<span class="comment">//向上跳了2的i次方层，那就有2的i次方个点</span></span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">0x6f6f6f6f6f6f6f6f</span>;</span><br><span class="line"></span><br><span class="line">ll father[maxn][<span class="number">20</span>], wight[maxn], <span class="built_in">cnt</span>(<span class="number">1</span>);</span><br><span class="line">ll sum[maxn][<span class="number">20</span>], lastans, limit;</span><br><span class="line">ll Q, Opt, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (sum, <span class="number">0x6f</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    wight[<span class="number">0</span>] = inf;</span><br><span class="line">    Q = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        Opt = <span class="built_in">Read</span>(), X = <span class="built_in">Read</span>() ^ lastans, Y = <span class="built_in">Read</span>() ^ lastans;</span><br><span class="line">        <span class="keyword">if</span> (Opt == <span class="number">1</span>) <span class="built_in">AddPoint</span>(X, Y);</span><br><span class="line">        <span class="keyword">else</span> limit = Y, <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, lastans = <span class="built_in">Query</span>(X));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES</title>
    <url>/AlanTuringLi/2022/10/20/CODEFORCES/</url>
    <content><![CDATA[<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>$CF$ 的比赛整体来说不是没法做的，题目都很巧妙，所以审题，打开思路很重要！</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>cf</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CF997C</title>
    <url>/AlanTuringLi/2020/12/02/CF997C/</url>
    <content><![CDATA[<h1 id="CF997C-Sky-Full-of-Stars"><a href="#CF997C-Sky-Full-of-Stars" class="headerlink" title="CF997C Sky Full of Stars"></a><a href="https://www.luogu.com.cn/problem/CF997C">CF997C Sky Full of Stars</a></h1><p>这道题的第一想法就是用总方案数减去不合法的方案，显然不合法的方案就是没有一行 / 一列 是全部相同的。</p>
<p>那么这就可以把行列分开讨论：</p>
<ul>
<li>没有一列合法的方案总数为：$(3^n-3)^n$</li>
<li>至少有一行合法且没有列合法的方案总数为：$-\sum\limits_{i=1}^n(-1)^i\binom ni\left(3\times\left(3^{n-i}-1\right)^n+\left(3^i-3\right)\times3^{n(n-i)}\right)$</li>
</ul>
<blockquote>
<p>   简单说明一下，就是枚举有几行是相同的，然后又需要分类讨论了：</p>
<ul>
<li>若：这几行的颜色都相同，那么所有列的都没有一个合法的</li>
<li>若：这几行颜色不同，那么剩下的就可以乱选了</li>
</ul>
</blockquote>
<p>总结一下，答案就是：</p>
<script type="math/tex; mode=display">
ans = 3^{n^2}-\left((3^n-3)^n+\sum\limits_{i=1}^n(-1)^i\binom ni\left(3\times\left(3^{n-i}-1\right)^n+\left(3^i-3\right)\times3^{n(n-i)}\right)\right)</script><p>所以预处理一下，整体时间复杂度就是 $O(n\log n)$ 的了，只可惜考场没有推出来。。。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i, l, r) for (ll i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (ll i = r; i &gt;= l; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> infile[] = <span class="string">&quot;.in&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> outfile[] = <span class="string">&quot;.out&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	   <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	   <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	   <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		   <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">		   o = <span class="built_in">getchar</span>();</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		   x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	   <span class="keyword">return</span> t ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">file</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (infile, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (outfile, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">		x = x * x % mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans, fac[maxn], inv[maxn], bas[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fac[x] * inv[y] % mod * inv[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n = <span class="built_in">read</span>();</span><br><span class="line">	ans = (<span class="built_in">Pow</span>(<span class="number">3</span>, n * n) - <span class="built_in">Pow</span>((<span class="built_in">Pow</span>(<span class="number">3</span>, n) - <span class="number">3</span> + mod) % mod, n) + mod) % mod;</span><br><span class="line">	fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = bas[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">per</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">		bas[i] = <span class="number">3</span> * bas[i - <span class="number">1</span>] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	inv[n] = <span class="built_in">Pow</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span> (i, <span class="number">2</span>, n)</span><br><span class="line">		inv[i - <span class="number">1</span>] = inv[i] * i % mod;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">per</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">			ans = (ans + <span class="built_in">C</span>(n, i) * (<span class="number">3</span> * <span class="built_in">Pow</span>(bas[n - i] - <span class="number">1</span>, n) % mod + (bas[i] - <span class="number">3</span>) * <span class="built_in">Pow</span>(<span class="number">3</span>, n * (n - i)) % mod) % mod) % mod;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans = (ans - <span class="built_in">C</span>(n, i) * (<span class="number">3</span> * <span class="built_in">Pow</span>(bas[n - i] - <span class="number">1</span>, n) % mod + (bas[i] - <span class="number">3</span>) * <span class="built_in">Pow</span>(<span class="number">3</span>, n * (n - i)) % mod) % mod + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[CQOI2017]小Q的表格</title>
    <url>/AlanTuringLi/2020/09/21/CQOI2017-%E5%B0%8FQ%E7%9A%84%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="CQOI2017-小Q的表格"><a href="#CQOI2017-小Q的表格" class="headerlink" title="[CQOI2017]小Q的表格"></a><a href="https://www.luogu.com.cn/problem/P3700">[CQOI2017]小Q的表格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个表格，满足：</p>
<ul>
<li>$\forall a,b\;f(a,b)=f(b,a)$</li>
<li>$\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$</li>
</ul>
<p>有$m$次操作</p>
<ul>
<li>每次操作修改$f(a,b)$的值，为了使整个表满足条件，所以要修改的点还挺多的</li>
<li>然后让你输出$k*k$的范围内的数的和</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于性质$\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$，观察发现它可以转化一下：</p>
<script type="math/tex; mode=display">
\begin{align*}
b\cdot f(a,a+b)&=(a+b)\cdot f(a,b)\\
\Leftrightarrow ab\cdot f(a,a+b)&=a(a+b)\cdot f(a,b)\\
\Leftrightarrow\quad\;\frac{f(a,a+b)}{a(a+b)}&=\frac{f(a,b)}{ab}\\
\Leftrightarrow\qquad\;\;\;\frac{f(a,b)}{a,b}&=\frac{f(\gcd(a,b), \gcd(a,b))}{\gcd^2(a,b)}
\end{align*}</script><p>所以可以得到一个结论：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(a,b)&=f(gcd(a,b),gcd(a,b))\times\frac{ab}{\gcd^2(a,b)}\\
&=g(d)\times\frac{ab}{d^2}
\end{align*}</script><p>那么就得到了一个线性的表了</p>
<p>那么再回头看看题目要求的问题</p>
<script type="math/tex; mode=display">
\begin{align*}
ans&=\sum_{d=1}^ng(d)\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{\gcd^2(i,j)}[\gcd(i,j)=d]\\
&=\sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}\sum_{j=1}^{\left\lfloor\frac md\right\rfloor}ij[\gcd(i,j)=1]\\
&=\sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}i\sum_{j=1}^{\left\lfloor\frac nd\right\rfloor}j[\gcd(i,j)=1]\\
\end{align*}</script><p>考虑:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ni[\gcd(i,n)=1]=\frac{n\times\varphi(n)}{2}</script><p>所以原式可以化为:</p>
<script type="math/tex; mode=display">
ans= \sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}i^2\varphi(i)</script><p>那么这个时候我们发现，后面的是可以直接$O(1)$求解的（先预处理，就可以直接查询）</p>
<p>然而前面那个$g(d)$是会发生改变的</p>
<p>这个可以用树状数组或者是分块来维护</p>
<p>这两个理论上是可以过的，实测再<a href="loj.ac">loj</a>是可以过的</p>
<p>洛谷似乎有点卡常，要$TLE$一两个点</p>
<p><a href="https://loj.ac/submission/937220">树状数组实现</a>，<a href="https://loj.ac/submission/937110">分块实现</a></p>
<h3 id="Code-树状数组"><a href="#Code-树状数组" class="headerlink" title="Code(树状数组)"></a>Code(树状数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = ((x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>)) % mod;</span><br><span class="line">    <span class="keyword">return</span> x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll id[maxn], st[maxn], ed[maxn];</span><br><span class="line">ll val[maxn], sum[maxn], Sum[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">        x -= mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= mod)</span><br><span class="line">        temp -= mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">        temp += mod;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(sum[x], val);</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="built_in">inc</span>(ans, sum[x]);</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="built_in">Query</span>(r), <span class="number">-1ll</span> * <span class="built_in">Query</span>(l - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        val[i] = <span class="number">1ll</span> * i * i % mod;</span><br><span class="line">        <span class="built_in">Update</span>(i, val[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = <span class="built_in">Gcd</span>(a, b);</span><br><span class="line"></span><br><span class="line">        ll upt = x * d % mod * d % mod * <span class="built_in">Pow</span>(<span class="number">1ll</span> * a * b % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">Update</span>(d, <span class="built_in">add</span>(upt, -val[d]));</span><br><span class="line">        val[d] = upt;</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = k / (k / l);</span><br><span class="line">            <span class="built_in">inc</span>(ans, f[k / l] * <span class="built_in">Query</span>(l, r) % mod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Code-分块"><a href="#Code-分块" class="headerlink" title="Code(分块)"></a>Code(分块)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = ((x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>)) % mod;</span><br><span class="line">    <span class="keyword">return</span> x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll id[maxn], st[maxn], ed[maxn];</span><br><span class="line">ll val[maxn], sum[maxn], Sum[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">        x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= mod)</span><br><span class="line">        temp -= mod;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get_sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(Sum[id[x] - <span class="number">1</span>], sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get_sum</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> ((<span class="built_in">Get_sum</span>(r) - <span class="built_in">Get_sum</span>(l - <span class="number">1</span>)) % mod + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == st[id[x]])</span><br><span class="line">        sum[x] = val[x];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum[x] = sum[x - <span class="number">1</span>] + val[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = x + <span class="number">1</span>; i &lt;= ed[id[x]]; ++i) sum[i] = <span class="built_in">add</span>(sum[i - <span class="number">1</span>], val[i]);</span><br><span class="line">    <span class="keyword">for</span> (ll i = id[x]; i &lt;= len; ++i) Sum[i] = <span class="built_in">add</span>(Sum[i - <span class="number">1</span>], sum[ed[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        id[i] = i / size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[id[i]] = i, ed[id[i] - <span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = id[n], ed[id[n]] = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="number">1ll</span> * i * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        sum[st[i]] = val[st[i]];</span><br><span class="line">        <span class="keyword">for</span> (ll j = st[i] + <span class="number">1</span>; j &lt;= ed[i]; ++j) sum[j] = <span class="built_in">add</span>(sum[j - <span class="number">1</span>], val[j]);</span><br><span class="line">        Sum[i] = <span class="built_in">add</span>(Sum[i - <span class="number">1</span>], sum[ed[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = <span class="built_in">Gcd</span>(a, b);</span><br><span class="line"></span><br><span class="line">        val[d] = x * d % mod * d % mod * <span class="built_in">Pow</span>(<span class="number">1ll</span> * a * b % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Update</span>(d);</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = k / (k / l);</span><br><span class="line">            <span class="built_in">inc</span>(ans, f[k / l] * <span class="built_in">Get_sum</span>(l, r) % mod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进一步考虑"><a href="#进一步考虑" class="headerlink" title="进一步考虑"></a>进一步考虑</h2><p>我们每次修改的值其实是$f(\gcd(a,b))$，所以真时要改的值并不多</p>
<ul>
<li><p>那么我们可以先求出原表中$k*k$范围内的值</p>
</li>
<li><p>再求出修改的值对答案贡献相对原来的偏移量</p>
</li>
</ul>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=1}^{cnt}(改(i)-原^2(i))\sum_{j=1}^{\left\lfloor\frac ki\right\rfloor}j^2\varphi(j)</script><p>所以这个就是$O(cnt)$的复杂度</p>
<p>然后又是可以证明对于所有的$\gcd(n,m)$的个数时处于$\log n\sim\sqrt n$这个级别的</p>
<p>所以修改大概就是$O(m\log n)\sim O(m\sqrt n)$</p>
<p>然而实际跑下来要比这快得多</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll stk[maxn], upt[maxn], top;</span><br><span class="line"><span class="type">bool</span> vis[maxn], che[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = <span class="built_in">gcd</span>(a, b);</span><br><span class="line"></span><br><span class="line">        upt[d] = x / (a / d) / (b / d) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!che[d]) &#123;</span><br><span class="line">            stk[++top] = d;</span><br><span class="line">            che[d] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(sum(k))</span></span>;</span><br><span class="line">        ans = ans * ans % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= top; ++i) &#123;</span><br><span class="line">            d = stk[i];</span><br><span class="line">            ans = (ans + ((upt[d] - d * d % mod) % mod + mod) % mod * f[k / d] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Closest Equals</title>
    <url>/AlanTuringLi/2020/09/15/Closest-Equals/</url>
    <content><![CDATA[<h1 id="Closest-Equals"><a href="#Closest-Equals" class="headerlink" title="Closest Equals"></a><a href="https://ac.nowcoder.com/acm/problem/110867">Closest Equals</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给你一串数,有$m$次询问,每次求问一个区间$[l,r]$,问在区间内最近的两个相同的数的距离是多少</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>第一反应就是记录一下这个值上一次出现的位置,这就可以记录一次答案了</p>
<p>然后可以构造出一个新的序列,因为当某两个可行的数在另外两个可行的数内时,外面的数是没有贡献的</p>
<p>然后就可以找到第一个$prev[i]\ge l$的$i$, 然后再找到最后一个$last[i]\le r$</p>
<p>这就构成了一个新的可行区间</p>
<p>那么如果找到的新的$r &lt; l$那么这就是无解的, 直接输出$-1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt, cur;</span><br><span class="line"><span class="type">int</span> a[maxn], d[maxn], p[maxn], f[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> __prev[maxn],  __last[maxn], __log[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> _lower_bound(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(cur)</span>, <span class="title">ans</span><span class="params">(cur + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (__prev[mid] &lt; x) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> _upper_bound(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(cur)</span>, <span class="title">ans</span><span class="params">(cur + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (__last[mid] &lt;= x) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min__</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = __read();</span><br><span class="line">        <span class="keyword">if</span> (!Vis[temp]) Vis[temp] = ++cnt;</span><br><span class="line">        a[i] = Vis[temp];</span><br><span class="line">        <span class="type">int</span> j = p[a[i]];</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> (__prev[cur] &gt;= j) <span class="keyword">continue</span>;</span><br><span class="line">        __prev[++cur] = j, __last[cur] = i, d[cur] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= cur; ++i)</span><br><span class="line">        f[i][<span class="number">0</span>] = d[i], __log[i] = __log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">j</span>(<span class="number">1</span>); (<span class="number">1</span> &lt;&lt; j) &lt;= cur; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cur; ++i)</span><br><span class="line">            f[i][j] = <span class="built_in">min__</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> x = _lower_bound(__read()), y = _upper_bound(__read());</span><br><span class="line">        <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = __log[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min__</span>(f[x][len], f[y - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>RMQ</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HAOI2015树上染色</title>
    <url>/AlanTuringLi/2020/07/21/HAOI2015%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<h1 id="HAOI2015-树上染色"><a href="#HAOI2015-树上染色" class="headerlink" title="[HAOI2015]树上染色"></a><a href="https://loj.ac/problem/2124">[HAOI2015]树上染色</a></h1><p>简单的说, 就是求树上所有边对答案的贡献之和</p>
<p>我们可以用$Dp[i][j]$表示以$i$为根的子树内, 有$j$个点为黑点的情况下, 这个子树中的边对答案的贡献之和</p>
<p>每次新加入一个$i$的子节点时, 另新节点中有$k$个黑点, 那么:</p>
<script type="math/tex; mode=display">
Dp[i][j]=max(Dp[i][j],\; Dp[i][j-k]+Dp[i_{new}]+W_{new}*Times);\\
其中Times=子树内的黑点*子树外的黑点+子树内的白点*子树外的白点</script><p>所以这道题就算是做完了</p>
<p>$Dp$一定要考虑好状态的<strong>表示, 转移和初始化</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> N, K, U, V, W, Size[Maxn];</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Cost[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line">ll Dp[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> _F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Size[U] = <span class="number">1</span>;</span><br><span class="line">    Dp[U][<span class="number">0</span>] = Dp[U][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _F) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(V, U);</span><br><span class="line">        Size[U] += Size[V];</span><br><span class="line">        <span class="type">int</span> W = Cost[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">min</span>(K, Size[U]); i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, Size[V]); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Dp[U][i - j] == <span class="number">-1</span>) <span class="keyword">continue</span>;<span class="comment">//不成立的直接跳过</span></span><br><span class="line">                ll Val = W * ((ll)j * (K - j) + (ll)(Size[V] - j) * (N - K + j - Size[V]));</span><br><span class="line">                Dp[U][i] = <span class="built_in">max</span>(Dp[U][i], Dp[U][i - j] + Dp[V][j] + Val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);<span class="comment">//初始化, 因为有些状态是不会成立的</span></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;U, &amp;V, &amp;W);</span><br><span class="line">        <span class="built_in">AddEdge</span> (U, V, W), <span class="built_in">AddEdge</span>(V, U, W);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span> (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Dp[<span class="number">1</span>][K]);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树型Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6035 Colorful Tree</title>
    <url>/AlanTuringLi/2020/07/21/HDU6035%20Colorful%20Tree/</url>
    <content><![CDATA[<h1 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a><a href="https://vjudge.net/problem/HDU-6035">Colorful Tree</a></h1><p>简言之, 求总权值减去不合法的权值</p>
<p>即对于每种颜色, 求不经过这种颜色的边的个数</p>
<p>考虑删除这种颜色, 那么剩下的点会构成几个连通块, 对于每个连通块的权值都为$Size*(Size-1)/2$</p>
<p>一遍$DFS$貌似可以解决了</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> N, U, V, Tot, Cur, C[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn];</span><br><span class="line">ll Sum[Maxn], Size[Maxn];</span><br><span class="line">ll Res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> _F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Size[U] = <span class="number">1</span>;</span><br><span class="line">    ll X = Sum[C[U]], Y = X;<span class="comment">//这一步很妙啊</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _F) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span> (V, U);</span><br><span class="line">        Size[U] += Size[V];</span><br><span class="line">        ll Temp = Size[V] - Sum[C[U]] + X;<span class="comment">//好好想为啥</span></span><br><span class="line">        Res += (Temp - <span class="number">1</span>) * Temp / <span class="number">2</span>;</span><br><span class="line">        X = Sum[C[U]];</span><br><span class="line">    &#125;</span><br><span class="line">    Sum[C[U]] += Size[U] - (Sum[C[U]] - Y);<span class="comment">//简直妙哉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> Head);</span><br><span class="line">    <span class="built_in">memset</span> (Sum, <span class="number">0</span>, <span class="keyword">sizeof</span> Sum);</span><br><span class="line">    <span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">    Tot = Res = Cur = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Case</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, C + i);</span><br><span class="line">            <span class="keyword">if</span> (!Vis[C[i]]) ++Cnt, Vis[C[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;U, &amp;V);</span><br><span class="line">            <span class="built_in">AddEdge</span>(U, V), <span class="built_in">AddEdge</span>(V, U);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ll Ans = <span class="number">1ll</span> * N * (N - <span class="number">1</span>) * Cnt / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll Temp = N - Sum[i];</span><br><span class="line">                Ans -= Temp * (Temp - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//这个是最后一个连通块</span></span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Case #%d: %lld\n&quot;</span>, ++Case, Ans - Res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树型Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI]2015公约数序列</title>
    <url>/AlanTuringLi/2020/09/25/HEOI-2015%E5%85%AC%E7%BA%A6%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="HEOI2015-公约数数列"><a href="#HEOI2015-公约数数列" class="headerlink" title="[HEOI2015]公约数数列"></a><a href="https://www.luogu.com.cn/problem/P4108">[HEOI2015]公约数数列</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个序列，有两种操作</p>
<ul>
<li>修改第 $id$ 个数，让它变成$x$</li>
<li>查询最小的$id$，让他满足<script type="math/tex; mode=display">
(\otimes_{i=0}^{id}a_i)*\gcd(a_0,a_1\cdots a_{id})=x</script></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个$\gcd$有点东西，是这只可能不断变小的</p>
<p>所以这个是单调的，没鸟用</p>
<p>所以直接暴力分块乱搞，练练代码能力还是不错的选择</p>
<p>只是说有地方时可以优化的</p>
<p>比如说，当前$\gcd$前缀不是查询的$x$的约数，就可以直接跳过的</p>
<p>还有，如果说这个块对答案没有$\gcd$没有贡献，就可以直接二分查找异或前缀和了</p>
<p>然后似乎就完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, p, q, a[maxn], l[<span class="number">505</span>], r[<span class="number">505</span>], id[maxn];</span><br><span class="line">ll gd[maxn], xr[maxn], map_id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xr[x] == xr[y]) <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    <span class="keyword">return</span> xr[x] &lt; xr[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; l[id[pos]]) &#123;</span><br><span class="line">        gd[pos] = <span class="built_in">gcd</span>(gd[pos - <span class="number">1</span>], a[pos]);</span><br><span class="line">        xr[pos] = xr[pos - <span class="number">1</span>] ^ a[pos];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gd[pos] = xr[pos] = a[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt;= r[id[pos]]; ++i) &#123;</span><br><span class="line">        gd[i] = <span class="built_in">gcd</span>(gd[i - <span class="number">1</span>], a[i]);</span><br><span class="line">        xr[i] = xr[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(map_id + l[id[pos]], map_id + r[id[pos]] + <span class="number">1</span>, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll l, ll r, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(l)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function">ll <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (xr[map_id[mid]] &gt;= val) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">-1</span>)</span>, <span class="title">q_gd</span><span class="params">(a[<span class="number">1</span>])</span>, <span class="title">q_xr</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= id[n] &amp;&amp; ans == <span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="built_in">gcd</span>(q_gd, gd[r[i]])) &#123;</span><br><span class="line">            q_gd = <span class="built_in">gcd</span>(q_gd, gd[r[i]]);</span><br><span class="line">            q_xr ^= xr[r[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(q_gd, gd[r[i]]) == q_gd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % q_gd == <span class="number">0</span>) &#123;</span><br><span class="line">                ll targer = (x / q_gd) ^ q_xr;</span><br><span class="line">                ll pos = <span class="built_in">Find</span>(l[i], r[i], targer);</span><br><span class="line">                <span class="keyword">if</span> (xr[map_id[pos]] == targer) ans = map_id[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            q_xr ^= xr[r[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j &lt;= r[i]; ++j) &#123;</span><br><span class="line">                q_gd = <span class="built_in">gcd</span>(q_gd, a[j]);</span><br><span class="line">                q_xr = q_xr ^ a[j];</span><br><span class="line">                <span class="keyword">if</span> (q_gd * q_xr == x) &#123;</span><br><span class="line">                    ans = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Opt[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    p = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        id[i] = (i - <span class="number">1</span>) / p + <span class="number">1</span>;</span><br><span class="line">        map_id[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (!l[id[i]]) l[id[i]] = i;</span><br><span class="line">        r[id[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= id[n]; ++i) <span class="built_in">Update</span>(l[i]);</span><br><span class="line"></span><br><span class="line">    q = __read();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, Opt);</span><br><span class="line">        <span class="keyword">if</span> (*Opt == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            ll pos = __read() + <span class="number">1</span>, x = __read();</span><br><span class="line">            a[pos] = x;</span><br><span class="line">            <span class="built_in">Update</span>(pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll x = __read();</span><br><span class="line">            ll ans = <span class="built_in">Query</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>分块</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI2014]南园满地推轻絮</title>
    <url>/AlanTuringLi/2020/09/03/HEOI2014-%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E6%8E%A8%E8%BD%BB%E7%B5%AE/</url>
    <content><![CDATA[<h1 id="HEOI2014-南园满地推轻絮"><a href="#HEOI2014-南园满地推轻絮" class="headerlink" title="[HEOI2014]南园满地推轻絮"></a><a href="https://www.luogu.com.cn/problem/P4105">[HEOI2014]南园满地推轻絮</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>就是二分去找$\max(x)$, 满足$|a_i-b_i|\le x$</p>
<p>那么就是要让$b_i$尽可能小的满足$a_i-b_i&lt;x$，然后在保证$b_i$单调不下降的情况下，不等式是否成立</p>
<blockquote>
<p>  易证：</p>
<p> 当$x &gt; y$时，若$b_i$数组满足条件$a_i-b_i\le y$且$b_i$单调不下降，那么$b_i$数组也一定满足$a_i-b_i\le y$且$b_i$单调不下降</p>
<p> 那么有了这个性质就可以二分答案了，因为当小的取值成立时，大的取值一定成立</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, sa, sb, sc, sd, p;</span><br><span class="line"><span class="type">int</span> l, r, ans, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1ll</span> * sa * x  % p * x % p * x % p + <span class="number">1ll</span> * sb * x % p * x % p + <span class="number">1ll</span> * sc * x % p + sd) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="number">0</span>, a[<span class="number">1</span>] - x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = <span class="built_in">max</span>(b[i - <span class="number">1</span>], a[i] - x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(b[i] - a[i]) &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d %d %d %d %d&quot;</span>, &amp;n, &amp;sa, &amp;sb, &amp;sc, &amp;sd, a + <span class="number">1</span>, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) a[i] = (<span class="built_in">f</span>(a[i - <span class="number">1</span>]) + <span class="built_in">f</span>(a[i - <span class="number">2</span>])) % p, r = <span class="built_in">max</span>(r, a[i]);</span><br><span class="line">    r = <span class="built_in">max</span>(a[<span class="number">1</span>], r);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS入门-T形波导的内场分析</title>
    <url>/AlanTuringLi/2023/11/05/HFSS%E5%85%A5%E9%97%A8-T%E5%BD%A2%E6%B3%A2%E5%AF%BC%E7%9A%84%E5%86%85%E5%9C%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749436701&p=2&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<ul>
<li>新建 $HFSS$ 工程设计</li>
<li>创建 $T$ 型波导模型<ul>
<li>创建几何模型</li>
<li>分配边界条件以及激励</li>
</ul>
</li>
<li>求解设置和扫频设置<ul>
<li>求解频率：$10GHz$</li>
<li>扫频设置：$8\sim10GHz$，插值扫频</li>
</ul>
</li>
<li>查看分析结果<ul>
<li>$S$  参数扫频结果</li>
<li>电场分布图</li>
<li>动态演示电场分布</li>
</ul>
</li>
</ul>
<h2 id="创建几何模型"><a href="#创建几何模型" class="headerlink" title="创建几何模型"></a>创建几何模型</h2><p><img src="./unit.png" alt="unit"></p>
<script type="math/tex; mode=display">
\Downarrow</script><p><img src="./dif.png" alt="dif"></p>
<script type="math/tex; mode=display">
\Downarrow</script><p><img src="./激励.png" alt="激励"></p>
<p>绘制激励后可以通过旋转复制物体的方式，将激励一起复制到对象的表面。</p>
<h2 id="求解和扫频设置"><a href="#求解和扫频设置" class="headerlink" title="求解和扫频设置"></a>求解和扫频设置</h2><p> <img src="./求解条件.png" alt="求解条件"></p>
<p><img src="./扫频范围.png" alt="扫频范围"></p>
<h2 id="查看分析结果"><a href="#查看分析结果" class="headerlink" title="查看分析结果"></a>查看分析结果</h2><ul>
<li>$S$ 参数扫频结果：<img src="./res.png" alt="res"></li>
<li>电场分布图：<img src="./表面结果.png" alt="表面结果"></li>
<li>动态演示电场分布：<img src="./动态演示.gif" alt="动态演示"></li>
</ul>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>K-D Tree</title>
    <url>/AlanTuringLi/2022/09/22/K-D-Tree/</url>
    <content><![CDATA[<h1 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="$K-D\;Tree$"></a>$K-D\;Tree$</h1><p>处理高维空间的数据结构</p>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>每次取离散化程度最高的维度的中点作为一个节点，所以整个建树的过程与归并排序类似（这里用 $k = 2$ 举例）：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">AvergX</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">AvergY</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ValX</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ValY</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        AvergX += P[i].x;</span><br><span class="line">        AvergY += P[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    AvergX /= (r - l + <span class="number">1.0</span>), AvergY /= (r - l + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        ValX += <span class="built_in">pow</span>(P[i].x - AvergX);</span><br><span class="line">        ValY += <span class="built_in">pow</span>(P[i].y - AvergY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ValX &gt; ValY) <span class="built_in">nth_element</span> (P + l, P + mid, P + r + <span class="number">1</span>, CompareX);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">nth_element</span> (P + l, P + mid, P + r + <span class="number">1</span>, CompareY);</span><br><span class="line"></span><br><span class="line">    Son[mid][<span class="number">0</span>] = <span class="built_in">Build</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    Son[mid][<span class="number">1</span>] = <span class="built_in">Build</span> (mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以证明对于 $n$ 个节点的一棵树的时间复杂度为 $O(n\log n)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>记录插入节点的排序维度，按顺序依次插入左（右）节点，如果某个节点左右失去平衡，则考虑重构这个节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bad</span><span class="params">(<span class="type">int</span> X)</span> </span>&#123; <span class="keyword">return</span> Par * Size[X] &lt;= (<span class="type">double</span>)<span class="built_in">max</span>(Size[LS[X]], Size[RS[X]]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReSort</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!X) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">ReSort</span>(LS[X]);</span><br><span class="line">    Cnt[++T] = X;</span><br><span class="line">    <span class="built_in">ReSort</span>(RS[X]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ReBuilt</span><span class="params">(<span class="type">int</span> &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReSort</span>(X);</span><br><span class="line">    X = <span class="built_in">Build</span>(<span class="number">1</span>, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>这类问题大致询问两点之间的距离，所以可以记录一个子树包含的最大矩形，可以构造估价函数，做类似 $A^*$ 的剪枝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    MaxAns = <span class="built_in">max</span>(MaxAns, <span class="built_in">Distante</span>(mid));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ExpAnsl = <span class="built_in">ExpMaxDis</span> (Son[mid][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">double</span> ExpAnsr = <span class="built_in">ExpMaxDis</span> (Son[mid][<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ExpAnsl &gt; ExpAnsr) &#123;<span class="comment">//加大剪枝力度，尽可能不让复杂度变为O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &gt; MaxAns &amp;&amp; Son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &gt; MaxAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &gt; MaxAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &gt; MaxAns &amp;&amp; Son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询的时间复杂度为 $O(\log n)\sim O(n)$</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CQOI2016-K-远点对"><a href="#CQOI2016-K-远点对" class="headerlink" title="(CQOI2016)K 远点对 "></a><a href="https://www.luogu.com.cn/problem/P4357">(CQOI2016)K 远点对 </a></h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题面
    </div>
    <div class='spoiler-content'>
        <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知平面内 $N$ 个点的坐标，求欧氏距离下的第 $K$ 远点对。</p>
<p>两个点 $P(x_1,y_1)$ 和 $Q(x_2,y_2)$ 的欧氏距离定义为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件第一行为用空格隔开的两个整数 $N,K$ 。</p>
<p>接下来 $N$ 行，每行两个整数 $X,Y$ ，表示一个点的坐标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件第一行为一个整数，表示第 $K$ 远点对的距离的平方（一定是个整数）。</p>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">2 0</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0 2</span><br><span class="line">3 0</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于 $100\%$ 的测试点，$N \le 100000,1 \le K \le 100,K \le \dfrac {N(N-1)}{2},0 \le X,Y &lt; 2^{31}$</p>

    </div>
</div>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对输入的点建树，然后查询所有的点，考虑到会重复计算，所以小根堆的大小要变为题设的二倍</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> N, K, Son[Maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> XMin[Maxn], XMax[Maxn], YMin[Maxn], YMax[Maxn];</span><br><span class="line">priority_queue &lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;<span class="type">int</span> X, Y;&#125;P[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">CmpX</span><span class="params">(Node A, Node B)</span> </span>&#123;<span class="keyword">return</span> A.X &lt; B.X;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">CmpY</span><span class="params">(Node A, Node B)</span> </span>&#123;<span class="keyword">return</span> A.Y &lt; B.Y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rectangle</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMin[X] = XMax[X] = P[X].X;</span><br><span class="line">    YMin[X] = YMax[X] = P[X].Y;</span><br><span class="line">    <span class="keyword">if</span> (Son[X][<span class="number">0</span>])  </span><br><span class="line">        XMin[X] = <span class="built_in">min</span>(XMin[X], XMin[Son[X][<span class="number">0</span>]]), XMax[X] = <span class="built_in">max</span>(XMax[X], XMax[Son[X][<span class="number">0</span>]]),</span><br><span class="line">        YMin[X] = <span class="built_in">min</span>(YMin[X], YMin[Son[X][<span class="number">0</span>]]), YMax[X] = <span class="built_in">max</span>(YMax[X], YMax[Son[X][<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (Son[X][<span class="number">1</span>])</span><br><span class="line">        XMin[X] = <span class="built_in">min</span>(XMin[X], XMin[Son[X][<span class="number">1</span>]]), XMax[X] = <span class="built_in">max</span>(XMax[X], XMax[Son[X][<span class="number">1</span>]]),</span><br><span class="line">        YMin[X] = <span class="built_in">min</span>(YMin[X], YMin[Son[X][<span class="number">1</span>]]), YMax[X] = <span class="built_in">max</span>(YMax[X], YMax[Son[X][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mid</span><span class="params">((L + R) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Avx</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Avy</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Vax</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Vay</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) Avx += P[i].X, Avy += P[i].Y;</span><br><span class="line">    Avx /= (R - L + <span class="number">1</span>), Avy /= (R - L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i)  </span><br><span class="line">        Vax += (P[i].X - Avx) * (P[i].X - Avx), </span><br><span class="line">        Vay += (P[i].Y - Avy) * (P[i].Y - Avy);</span><br><span class="line">    <span class="keyword">if</span> (Vax &gt; Vay) <span class="built_in">nth_element</span>(P + L, P + Mid, P + R + <span class="number">1</span>, CmpX);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">nth_element</span>(P + L, P + Mid, P + R + <span class="number">1</span>, CmpY);</span><br><span class="line">    Son[Mid][<span class="number">0</span>] = <span class="built_in">Build</span>(L, Mid - <span class="number">1</span>), Son[Mid][<span class="number">1</span>] = <span class="built_in">Build</span>(Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">Rectangle</span>(Mid);</span><br><span class="line">    <span class="keyword">return</span> Mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(<span class="type">int</span> X)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span> * X * X;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Pow</span>(XMin[A] - P[B].X), <span class="built_in">Pow</span>(XMax[A] - P[B].X)) + </span><br><span class="line">           <span class="built_in">max</span>(<span class="built_in">Pow</span>(YMin[A] - P[B].Y), <span class="built_in">Pow</span>(YMax[A] - P[B].Y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mid</span><span class="params">((L + R) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    ll Temp = <span class="built_in">Pow</span>(P[Mid].X - P[T].X) + <span class="built_in">Pow</span>(P[Mid].Y - P[T].Y);</span><br><span class="line">    <span class="keyword">if</span> (Temp &gt; Q.<span class="built_in">top</span>()) Q.<span class="built_in">pop</span>(), Q.<span class="built_in">push</span>(Temp);</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    ll DisL = <span class="built_in">F</span>(Son[Mid][<span class="number">0</span>], T), DisR = <span class="built_in">F</span>(Son[Mid][<span class="number">1</span>], T);</span><br><span class="line">    <span class="keyword">if</span> (DisL &gt; Q.<span class="built_in">top</span>()) <span class="built_in">Query</span> (L, Mid - <span class="number">1</span>, T);</span><br><span class="line">    <span class="keyword">if</span> (DisR &gt; Q.<span class="built_in">top</span>()) <span class="built_in">Query</span> (Mid + <span class="number">1</span>, R, T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (K &lt;&lt; <span class="number">1</span>); ++i) Q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;P[i].X, &amp;P[i].Y);</span><br><span class="line">    <span class="built_in">Build</span> (<span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">Query</span> (<span class="number">1</span>, N, i);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Q.<span class="built_in">top</span>());</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="SDOI2012-最近最远点对"><a href="#SDOI2012-最近最远点对" class="headerlink" title="[SDOI2012]最近最远点对"></a><a href="https://www.luogu.com.cn/problem/P6247">[SDOI2012]最近最远点对</a></h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题面
    </div>
    <div class='spoiler-content'>
        <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定平面直角坐标系上的 $n$ 个点，分别求出距离最近的两个点的距离和距离最远的两个点的距离。注意，距离为直线距离()。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数，$n$。<br>接下来 $n$ 行每行两个非负浮点数，$x_i$,$y_i$，表示第 $i$ 个点的 X 坐标与 Y 坐标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>总共一行，两个浮点数，为最短距离与最长距离。误差不超过 $0.01$ 视为正确。</p>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0.0 0.0</span><br><span class="line">0.0 1.0</span><br><span class="line">1.0 0.0</span><br><span class="line">1.0 1.0</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.00 1.41</span><br></pre></td></tr></table></figure>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>对于 $30\%$ 的数据，$n\leq 2000$；</li>
<li>对于 $70\%$ 的数据，$n\leq 20000$；</li>
<li>对于 $100\%$ 的数据，$0 \lt n\leq 10^5$，输入数据中所有数均为不超过 $10^9$ 的非负数。</li>
</ul>

    </div>
</div>
<p>也是很模板的一道题了，注意剪枝</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态K——D Tree 模板</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Points</span> &#123; <span class="type">double</span> x, y; &#125;P[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son[Maxn][<span class="number">2</span>], target;</span><br><span class="line"><span class="type">double</span> MaxX[Maxn], MaxY[Maxn];</span><br><span class="line"><span class="type">double</span> MinX[Maxn], MinY[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">CompareX</span> <span class="params">(Points A, Points B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">CompareY</span> <span class="params">(Points A, Points B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.y &lt; B.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rectangle</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    MaxX[x] = MinX[x] = P[x].x;</span><br><span class="line">    MaxY[x] = MinY[x] = P[x].y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Son[x][<span class="number">0</span>]) &#123;</span><br><span class="line">        MaxX[x] = <span class="built_in">max</span> (MaxX[x], MaxX[Son[x][<span class="number">0</span>]]);</span><br><span class="line">        MaxY[x] = <span class="built_in">max</span> (MaxY[x], MaxY[Son[x][<span class="number">0</span>]]);</span><br><span class="line">        MinX[x] = <span class="built_in">min</span> (MinX[x], MinX[Son[x][<span class="number">0</span>]]);</span><br><span class="line">        MinY[x] = <span class="built_in">min</span> (MinY[x], MinY[Son[x][<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        MaxX[x] = <span class="built_in">max</span> (MaxX[x], MaxX[Son[x][<span class="number">1</span>]]);</span><br><span class="line">        MaxY[x] = <span class="built_in">max</span> (MaxY[x], MaxY[Son[x][<span class="number">1</span>]]);</span><br><span class="line">        MinX[x] = <span class="built_in">min</span> (MinX[x], MinX[Son[x][<span class="number">1</span>]]);</span><br><span class="line">        MinY[x] = <span class="built_in">min</span> (MinY[x], MinY[Son[x][<span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">AvergX</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">AvergY</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ValX</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ValY</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        AvergX += P[i].x;</span><br><span class="line">        AvergY += P[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    AvergX /= (r - l + <span class="number">1.0</span>), AvergY /= (r - l + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        ValX += <span class="built_in">pow</span>(P[i].x - AvergX);</span><br><span class="line">        ValY += <span class="built_in">pow</span>(P[i].y - AvergY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ValX &gt; ValY) <span class="built_in">nth_element</span> (P + l, P + mid, P + r + <span class="number">1</span>, CompareX);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">nth_element</span> (P + l, P + mid, P + r + <span class="number">1</span>, CompareY);</span><br><span class="line"></span><br><span class="line">    Son[mid][<span class="number">0</span>] = <span class="built_in">Build</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    Son[mid][<span class="number">1</span>] = <span class="built_in">Build</span> (mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rectangle</span> (mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> MaxAns, <span class="built_in">MinAns</span>(<span class="number">1e18</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">ExpMaxDis</span><span class="params">(<span class="type">int</span> pa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span> (<span class="built_in">pow</span> (MaxX[pa] - P[target].x), <span class="built_in">pow</span> (MinX[pa] - P[target].x)) + </span><br><span class="line">           <span class="built_in">max</span> (<span class="built_in">pow</span> (MaxY[pa] - P[target].y), <span class="built_in">pow</span> (MinY[pa] - P[target].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">ExpMinDis</span><span class="params">(<span class="type">int</span> pa)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (MinX[pa] &gt; P[target].x) ans += <span class="built_in">pow</span>(MinX[pa] - P[target].x);</span><br><span class="line">    <span class="keyword">if</span> (MaxX[pa] &lt; P[target].x) ans += <span class="built_in">pow</span>(MaxX[pa] - P[target].x);</span><br><span class="line">    <span class="keyword">if</span> (MinY[pa] &gt; P[target].y) ans += <span class="built_in">pow</span>(MinY[pa] - P[target].y);</span><br><span class="line">    <span class="keyword">if</span> (MaxY[pa] &lt; P[target].y) ans += <span class="built_in">pow</span>(MaxY[pa] - P[target].y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Distante</span><span class="params">(<span class="type">int</span> pa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(P[pa].x - P[target].x) + <span class="built_in">pow</span>(P[pa].y - P[target].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    MaxAns = <span class="built_in">max</span>(MaxAns, <span class="built_in">Distante</span>(mid));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ExpAnsl = <span class="built_in">ExpMaxDis</span> (Son[mid][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">double</span> ExpAnsr = <span class="built_in">ExpMaxDis</span> (Son[mid][<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ExpAnsl &gt; ExpAnsr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &gt; MaxAns &amp;&amp; Son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &gt; MaxAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &gt; MaxAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &gt; MaxAns &amp;&amp; Son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mid != target) MinAns = <span class="built_in">min</span>(MinAns, <span class="built_in">Distante</span>(mid));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ExpAnsl = <span class="built_in">ExpMinDis</span> (Son[mid][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">double</span> ExpAnsr = <span class="built_in">ExpMinDis</span> (Son[mid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ExpAnsl &lt; ExpAnsr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &lt; MinAns &amp;&amp; Son[mid][<span class="number">0</span>]) <span class="built_in">QueryMin</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &lt; MinAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMin</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsr &lt; MinAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMin</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span> (ExpAnsl &lt; MinAns &amp;&amp; Son[mid][<span class="number">1</span>]) <span class="built_in">QueryMin</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%lf %lf&quot;</span>, &amp;P[i].x, &amp;P[i].y);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Build</span> (<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxn = (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (target = <span class="number">1</span>; target &lt;= maxn; ++target) &#123;</span><br><span class="line">        <span class="built_in">QueryMax</span> (<span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">QueryMin</span> (<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lf %lf\n&quot;</span>, <span class="built_in">sqrt</span>(MinAns), <span class="built_in">sqrt</span>(MaxAns));</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="SDOI2010-捉迷藏"><a href="#SDOI2010-捉迷藏" class="headerlink" title="(SDOI2010)捉迷藏"></a><a href="https://www.luogu.com.cn/problem/P2479">(SDOI2010)捉迷藏</a></h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题面
    </div>
    <div class='spoiler-content'>
        <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>iPig在大肥猪学校刚上完了无聊的猪文课，天资聪慧的iPig被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。</p>
<p>但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。一番寂寞的剪刀石头布后，他们决定iPig去捉giPi。由于他们都很熟悉大肥猪学校的地形了，所以giPi只会躲在大肥猪学校内N个隐秘地点，显然iPig也只会在那N个地点内找giPi。游戏一开始，他们从这N个隐秘地点之中选定一个地点，iPig保持不动，然后giPi用30秒的时间逃离现场（显然，giPi不会呆在原地）。然后iPig会随机地去找giPi，直到找到为止。由于iPig很懒，所以他到总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。</p>
<p>由于iPig现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig告诉了你大肥猪学校的N个隐秘地点的坐标，请你编程求出iPig的问题。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件hideseek.in：</p>
<p>第1行：一个整数N；</p>
<p>第2 ~ (N + 1)行：每行两个整数Xi，Yi，表示第i个地点的坐标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件hideseek.out有且仅有一行：一个整数，为距离差的最小值。</p>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>30%的数据中，2 &lt;= N &lt;= 1000；</p>
<p>100%的数据中，2 &lt;= N &lt;= 100000，0 &lt;= Xi, Yi &lt;= 100000000。</p>
<p>数据保证没有重点。</p>

    </div>
</div>
<p>通过这道题可以发现，除了欧几里得距离，$K-D\;Tree$ 还可以处理曼哈顿距离</p>
<p>注意估价函数的正确性，否则可能 $\text{RE}，\text{WA}$ </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> target, son[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> minx[maxn], maxx[maxn], miny[maxn], maxy[maxn];</span><br><span class="line">pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        t = (t &lt;&lt; <span class="number">1</span>) + (t &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rectangle</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    maxx[x] = minx[x] = p[x].first;</span><br><span class="line">    maxy[x] = miny[x] = p[x].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) </span><br><span class="line">        <span class="keyword">if</span> (son[x][i]) &#123;</span><br><span class="line">            maxx[x] = <span class="built_in">max</span> (maxx[x], maxx[son[x][i]]), maxy[x] = <span class="built_in">max</span> (maxy[x], maxy[son[x][i]]),</span><br><span class="line">            minx[x] = <span class="built_in">min</span> (minx[x], minx[son[x][i]]), miny[x] = <span class="built_in">min</span> (miny[x], miny[son[x][i]]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">Avex</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Avey</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Valx</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Valy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        Avex += p[i].first,</span><br><span class="line">        Avey += p[i].second;</span><br><span class="line">    Avex /= (r - l + <span class="number">1</span>), Avey /= (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        Valx += <span class="built_in">pow</span> (Avex - p[i].first, <span class="number">2</span>),</span><br><span class="line">        Valy += <span class="built_in">pow</span> (Avey - p[i].second, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Valx &gt; Valy) <span class="built_in">nth_element</span> (p + l, p + mid, p + r + <span class="number">1</span>, [] (pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; A, pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; B) </span><br><span class="line">                                                                            &#123;<span class="keyword">return</span> A.first &lt; B.first;&#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">nth_element</span> (p + l, p + mid, p + r + <span class="number">1</span>, [](pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; A, pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; B) </span><br><span class="line">                                                                            &#123;<span class="keyword">return</span> A.second &lt; B.second;&#125;);</span><br><span class="line">    </span><br><span class="line">    son[mid][<span class="number">0</span>] = <span class="built_in">Build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">    son[mid][<span class="number">1</span>] = <span class="built_in">Build</span> (mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rectangle</span> (mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ExpMaxDis</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span> (<span class="built_in">abs</span>(maxx[now] - p[target].first), <span class="built_in">abs</span>(minx[now] - p[target].first)) +</span><br><span class="line">           <span class="built_in">max</span> (<span class="built_in">abs</span>(maxy[now] - p[target].second), <span class="built_in">abs</span>(miny[now] - p[target].second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ExpMinDis</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">x</span><span class="params">(p[target].first)</span>, <span class="title">y</span><span class="params">(p[target].second)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; minx[now]) ans += minx[now] - x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; maxx[now]) ans += x - maxx[now];</span><br><span class="line">    <span class="keyword">if</span> (y &lt; miny[now]) ans += miny[now] - y;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; maxy[now]) ans += y - maxy[now];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Distance</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span> (p[now].first - p[target].first) + </span><br><span class="line">           <span class="built_in">abs</span> (p[now].second - p[target].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Minans, Maxans, <span class="built_in">Ans</span>(inf);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mid ^ target) Maxans = <span class="built_in">max</span>(Maxans, <span class="built_in">Distance</span> (mid));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ansl = <span class="built_in">ExpMaxDis</span> (son[mid][<span class="number">0</span>]), ansr = <span class="built_in">ExpMaxDis</span> (son[mid][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ansl &gt; ansr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ansl &gt; Maxans &amp;&amp; son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ansr &gt; Maxans &amp;&amp; son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ansr &gt; Maxans &amp;&amp; son[mid][<span class="number">1</span>]) <span class="built_in">QueryMax</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span> (ansl &gt; Maxans &amp;&amp; son[mid][<span class="number">0</span>]) <span class="built_in">QueryMax</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mid ^ target) Minans = <span class="built_in">min</span>(Minans, <span class="built_in">Distance</span> (mid));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ansl = <span class="built_in">ExpMinDis</span> (son[mid][<span class="number">0</span>]), ansr = <span class="built_in">ExpMinDis</span> (son[mid][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ansl &lt; ansr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ansl &lt; Minans &amp;&amp; son[mid][<span class="number">0</span>]) <span class="built_in">QueryMin</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ansr &lt; Minans &amp;&amp; son[mid][<span class="number">1</span>]) <span class="built_in">QueryMin</span> (mid + <span class="number">1</span>, r); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ansr &lt; Minans &amp;&amp; son[mid][<span class="number">1</span>]) <span class="built_in">QueryMin</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span> (ansl &lt; Minans &amp;&amp; son[mid][<span class="number">0</span>]) <span class="built_in">QueryMin</span> (l, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(read())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        p[i].first = <span class="built_in">read</span>(), p[i].second = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Build</span> (<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (target = <span class="number">1</span>; target &lt;= n; ++target) &#123;</span><br><span class="line">        Maxans = <span class="number">0</span>, Minans = inf;</span><br><span class="line">        <span class="built_in">QueryMax</span>(<span class="number">1</span>, n), <span class="built_in">QueryMin</span>(<span class="number">1</span>, n);</span><br><span class="line">        Ans = <span class="built_in">min</span>(Ans, Maxans - Minans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Ans &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS汇编入门</title>
    <url>/AlanTuringLi/2022/08/26/MIPS%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>名字 <center></th>
<th>示例<center></th>
<th>注释<center></th>
</tr>
</thead>
<tbody>
<tr>
<td>$32$ 个寄存器</td>
<td>$ $$$0-$7$, $$t0-$t9$, $$zero$, $$a0-$a3$, $$v0-$v1$, $$gp$，$$fp$, $\ $sp$, $$ra$, $$at$</td>
<td>寄存器用于数据的快速存取。在 $MIPS$ 中，只能对存放在寄存器中的数据执行算术操作，寄存器 $$zero$ 的值恒为 $0$ ，寄存器 $$at$ 被汇编器保留，用于处理大常数。</td>
</tr>
<tr>
<td>$2^{32}$ 个存储器字</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>JSOI2011 柠檬</title>
    <url>/AlanTuringLi/2020/11/21/JSOI2011-%E6%9F%A0%E6%AA%AC/</url>
    <content><![CDATA[<h1 id="JSOI2011-柠檬"><a href="#JSOI2011-柠檬" class="headerlink" title="[JSOI2011]柠檬"></a><a href="https://www.luogu.com.cn/problem/P5504">[JSOI2011]柠檬</a></h1><p>还是先有一些约定：</p>
<ul>
<li>$f_i$ 表示到消除到 $i$ 时的最大值。</li>
<li>$c_i$ 表示当前贝壳的大小。</li>
<li>$s_i$ 表示从 $1$ 开始到 $i$ 有多少个贝壳与当前贝壳颜色相同。</li>
</ul>
<p>然后，显然可以发现，我们接下来的一段的两端的颜色应当是相同的时候最优，所以就可以对不同的颜色分开讨论。</p>
<p>考虑对于 $i$，有决策点 $j$，当且仅当 $c_i==c_j$。若此时有两个决策点 $j&lt;k$，此时 $j$ 比 $k$ 更优当且仅当：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{j-1}+c_i\times(s_i-s_j+1)^2&>f_{k-1}+c_i\times(s_k-s_j+1)^2\\
f_{j-1}+c_is_j-2c_is_is_j+c_i{s_j}^2+c_i&>f_{k-1}+c_is_k-2c_is_is_k+c_i{s_k}^2+c_i\\
f_{j-1}+c_is_j-2c_is_is_j+c_i{s_j}^2&>f_{k-1}+c_is_k-2c_is_is_k+c_i{s_k}^2\\
f_{j-1}-2c_is_is_j+c_i{s_j}^2-f_{k-1}-2c_is_is_k+c_i{s_k}^2&>c_i(s_k-s_j)\\
\frac{\Delta y}{c_i(s_k-s_j)}&>1
\end{aligned}</script><p>由于这些点的 $s$ 是丹增的，所以就可以用栈维护一个上凸壳，栈定就是当点的最优决策点。</p>
<p>所以找出来所有决策点以后，在用决策单调性稍加处理，就可以统计答案了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, tot[maxm];</span><br><span class="line"><span class="type">int</span> s[maxn], c[maxn];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; stk[maxm];</span><br><span class="line">ll f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[i - <span class="number">1</span>] + <span class="number">1ll</span> * c[i] * s[i] * s[i] - <span class="number">2ll</span> * c[i] * s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span> * (<span class="built_in">Y</span>(i) - <span class="built_in">Y</span>(j)) / (s[i] * c[i] - s[j] * c[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[j - <span class="number">1</span>] + <span class="number">1ll</span> * c[i] * (s[i] - s[j] + <span class="number">1</span>) * (s[i] - s[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t1 stk[t][stk[t].size() - 1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t2 stk[t][stk[t].size() - 2]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line">		s[i] = ++tot[c[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i) &#123;</span><br><span class="line">		t = c[i];</span><br><span class="line">		<span class="keyword">while</span> (stk[t].<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(t2, i) &gt;= <span class="built_in">slope</span>(t2, t1)) stk[t].<span class="built_in">pop_back</span>();</span><br><span class="line">		stk[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (stk[t].<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">calc</span>(i, t1) &lt;= <span class="built_in">calc</span>(i, t2)) stk[t].<span class="built_in">pop_back</span>();</span><br><span class="line">		f[i] = <span class="built_in">calc</span>(i, t1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, f[n]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MooFest</title>
    <url>/AlanTuringLi/2020/09/15/MooFest/</url>
    <content><![CDATA[<h1 id="MooFest"><a href="#MooFest" class="headerlink" title="MooFest"></a><a href="https://www.luogu.com.cn/problem/P5094">MooFest</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们发现这个$\max$十分不好维护</p>
<p>就是说，如果已经保证了$v_i\ge v_j$，那么原式可以写为</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nv_i\sum_{j=1}^ndis(i,j)</script><p>这个按照$v_i$从大到小就可以了吧</p>
<p>那么就是$\sum_{j=i+1}^ndis(i,j)$的问题了</p>
<p>这个看看数据，这个大概是需要一个$\log$的复杂度</p>
<p>那么发现像什么线段树，树状数组之类的<del>高级</del>数据结构就可以维护</p>
<p>就分成两种情况，一种是$x_p&gt;x_i$的，一种是$x_p &lt; x_i$的</p>
<p>那就分别求和，那么就可以写成这样</p>
<script type="math/tex; mode=display">
sum\{x_p[x_p>x_i]\}-cnt\{[x_p>x_i]\}*x_i+cnt\{[x_p<x_i]\}*x_i-sum\{x_p[x_p<x_i]\}</script><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>这个用了一个十分易懂的方式来维护</p>
<p>那就是先按照$x_i$从小到大排序</p>
<p>用树状数组一个点一个点插入，记录一下每头牛的$x_i$的排序，方便下文的删除操作</p>
<p>然后再按$v_i$从大到小排序</p>
<p>然后每次就查询完了就从树状数组中把这头牛删掉</p>
<p>然后重载了一下运算符，操作可能会方便一些吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v, x, p;&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmpv</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &gt; y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="type">int</span> tree[maxn], cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        tree[x] += v;</span><br><span class="line">        cnt[x] += p;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">cur</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        cur += cnt[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ans, cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num second</span></span><br><span class="line"></span><br><span class="line">pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="keyword">operator</span> - (pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span> (a.sum - b.sum, a.num - b.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;c[i].v, &amp;c[i].x);</span><br><span class="line">    <span class="built_in">sort</span> (c + <span class="number">1</span>, c + n + <span class="number">1</span>, cmpx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(i, c[i].x, <span class="number">1</span>), c[i].p = i;</span><br><span class="line">    <span class="built_in">sort</span> (c + <span class="number">1</span>, c + n + <span class="number">1</span>, cmpv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; r = <span class="built_in">query</span>(c[i].p, n), l = <span class="built_in">query</span>(c[i].p - <span class="number">1</span>);</span><br><span class="line">        ans += <span class="number">1ll</span> * c[i].v * (r.sum - r.num * c[i].x + l.num * c[i].x - l.sum);</span><br><span class="line">        <span class="built_in">add</span>(c[i].p, -c[i].x, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2015]寿司晚宴</title>
    <url>/AlanTuringLi/2020/10/07/NOI2015-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/</url>
    <content><![CDATA[<h1 id="NOI2015-寿司晚宴"><a href="#NOI2015-寿司晚宴" class="headerlink" title="[NOI2015]寿司晚宴"></a><a href="https://www.luogu.com.cn/problem/P2150">[NOI2015]寿司晚宴</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>你有数集 ${1,2,3\cdots n-1}$ ，问你把这些数分派到两个集合中（可以是空集）且这两个集合的没有公共的素因子的方案数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个是可以暴力枚举的，期望 $30$ 分？</p>
<p>考虑把所有数的素因子列出来，可以发现，对于每个数，它一定不会有两个及以上大于 $22$ 的素因子</p>
<p>那么就是可以这样理解，可以把所有的小于 $22$ 的素数列举出来，那么就只有 $8$ 个，这部分就可以状压，那么就可以单独用一维来处理素因子大于 $22$ 的部分</p>
<p>听上去十分的简单，但是，这个必须保证所有有大于 $22$ 的素因子的数在同一个集合中，所以要用 $f_1$表示这类数在第一个集合中，用 $f_2$ 表示这一类数在第二个集合中</p>
<p>然后在用 $f$ 表示上一种状态答案，然后每次大素数发生改变的时候，就可以更新一下所有的信息 （要用一个简单容斥）</p>
<p>然后这样看上去貌似就不难了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())      &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sta, res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        sta = res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; p[i]; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val % p[i]) <span class="keyword">continue</span>;</span><br><span class="line">            sta |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">while</span> (!(val % p[i])) val /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">1</span>) res = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;T) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res &lt; T.res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">265</span>][<span class="number">265</span>], f1[<span class="number">265</span>][<span class="number">265</span>], f2[<span class="number">265</span>][<span class="number">265</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> t = x + y;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= m) <span class="keyword">return</span> t - m;</span><br><span class="line">    <span class="keyword">return</span> t; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) a[i - <span class="number">1</span>] = <span class="built_in">Node</span>(i);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i].res ^ a[i - <span class="number">1</span>].res || !a[i].res) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span> (f1, f, <span class="keyword">sizeof</span> f1);</span><br><span class="line">            <span class="built_in">memcpy</span> (f2, f, <span class="keyword">sizeof</span> f2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">255</span>; ~j; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">255</span>; ~k; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &amp; k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> t = a[i].sta;</span><br><span class="line">                <span class="keyword">if</span> (!(t &amp; j)) f2[j][k | t] = <span class="built_in">add</span>(f2[j][k | t], f2[j][k]);</span><br><span class="line">                <span class="keyword">if</span> (!(t &amp; k)) f1[j | t][k] = <span class="built_in">add</span>(f1[j | t][k], f1[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span> || a[i].res ^ a[i + <span class="number">1</span>].res || !a[i].res) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">255</span>; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">255</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &amp; k) <span class="keyword">continue</span>;</span><br><span class="line">                    f[j][k] = <span class="built_in">add</span>(f1[j][k], <span class="built_in">add</span>(f2[j][k], m - f[j][k]));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">255</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!(i &amp; j)) ans = <span class="built_in">add</span>(ans, f[i][j]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2018]屠龙勇士</title>
    <url>/AlanTuringLi/2020/09/23/NOI2018-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    <content><![CDATA[<h1 id="NOI2018-屠龙勇士"><a href="#NOI2018-屠龙勇士" class="headerlink" title="[NOI2018]屠龙勇士"></a><a href="https://www.luogu.com.cn/problem/P4774">[NOI2018]屠龙勇士</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>你有一些刀，然后要去杀龙吃</p>
<p>没把刀都有自己的攻击力</p>
<p>然后固定每次砍它多少刀，然后龙还会回血。。。</p>
<p>如果能刚好回到零，这龙才是彻底的死了，可以吃了</p>
<p>否则输出 $-1$ </p>
<h2 id="Sulotion"><a href="#Sulotion" class="headerlink" title="Sulotion"></a>Sulotion</h2><p>对于这些剑​🗡​，你可以写平衡树维护，支持查询，删除，还有插入操作（<del>还tm可能有重复元素</del>）</p>
<p>算了，$\text{STL}$大法好，$\text{multiset}$全都支持的，理论上平板电视也可以（我离$\text{AC}$只差一个$\text{C++11}$）</p>
<p>那么假设已经得到了所有应该用的剑，那么就可以得到如下好东西：</p>
<script type="math/tex; mode=display">
\begin{cases}
atk_2\cdot x\equiv a_1\pmod {p_1}\\
atk_2\cdot x\equiv a_2\pmod {p_2}\\
\quad\vdots\\ 
atk_3\cdot x\equiv a_3\pmod {p_3}\\
\end{cases}\\</script><p>还要满足所有的$atk_3\times x\ge p_3$</p>
<p>所以还要维护一个$\max(\left\lceil\frac {p_i}{atk_i}\right\rceil)$</p>
<p>那么把所有的$atk_i$的逆元乘到右边去似乎就可以了？</p>
<p>由于题目并不保证互质，所以再操作前是一定一定要判断操作是否是可行的</p>
<p>似乎就结束啦</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[maxn], p[maxn], b[maxn];</span><br><span class="line">ll x, y, g;</span><br><span class="line">multiset &lt;ll&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        g = a;</span><br><span class="line">        <span class="keyword">return</span> ;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = a * b - (ll)((ld)a / mod * b + <span class="number">1e-8</span>) * mod;</span><br><span class="line">    <span class="keyword">return</span> res &lt; <span class="number">0</span> ? res + mod : res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll T = __read();</span><br><span class="line">    multiset &lt;ll&gt; :: iterator it;</span><br><span class="line">    __next: <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        ll n = __read(), m = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = __read();</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; ++i) s.<span class="built_in">insert</span>(__read());</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">mx</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            it = s.<span class="built_in">upper_bound</span>(a[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) --it;</span><br><span class="line">            ll atk = *it;</span><br><span class="line">            s.<span class="built_in">erase</span>(it);</span><br><span class="line">            s.<span class="built_in">insert</span>(b[i]);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, (a[i] - <span class="number">1</span>) / atk + <span class="number">1</span>);</span><br><span class="line">            atk %= p[i], a[i] %= p[i];</span><br><span class="line">            <span class="keyword">if</span> (!atk &amp;&amp; a[i]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!atk &amp;&amp; !a[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">exgcd</span>(atk, p[i], x, y);</span><br><span class="line">            <span class="keyword">if</span> (a[i] % g) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p[i] /= g;</span><br><span class="line">            a[i] = <span class="built_in">mul</span>(a[i] / g, (x % p[i] + p[i]) % p[i], p[i]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exgcd</span>(m, p[i], x, y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((a[i] - c) % g) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m = m / g * p[i];</span><br><span class="line">            c = (c + <span class="built_in">mul</span>(<span class="built_in">mul</span>(m / p[i], (x % m + m) % m, m), ((a[i] - c) % m + m) % m, m)) % m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, c &gt;= mx ? c : c + m * ((mx - c - <span class="number">1</span>) / m + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>同余方程</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/AlanTuringLi/2020/09/20/Min-25%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用来处理积性函数前缀和的不错选择， 时间复杂度为$O(\frac{n^{\frac 34}}{\log_2n})$，空间复杂度为$O(\sqrt n)$</p>
<p><strong>限制：</strong>要求质数$p$处的函数值是个多项式，且$p^k$处的函数值也容易计算</p>
<p><strong>规定：</strong></p>
<ul>
<li>$\mathbb{P}$表示素数集合</li>
<li>$cnt$表示$n$范围内的素数个数</li>
<li>$p_i$表示第$i$个素数，特别的$p_0=0$</li>
<li>$lpf(x)$表示$x$的最小质因子</li>
<li>$F(x)$是我们要求的一个积性函数</li>
<li>$f(i)$是我们构造出来的计算方式与$F(x)$相似的完全积性函数</li>
</ul>
<h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h2><p>大致思路是将$F(x)$分为两部分来考虑，一部分是素数，另一部分是合数</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ul>
<li><p>先考虑求解：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{cnt}F(p_i)=\sum_{x=1}^nF(x)[x\in \mathbb{P}]</script></li>
<li><p>定义二元函数$g$：</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=2}^nf(i)[i\in \mathbb{p}\;\lor\; lpf(i)>p_j]</script></li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li><p>这里的$f(i)$的具体计算方式与$i\in\mathbb{p}$时的$F(i)$的计算方式相同，如当$F(x)=\varphi(x)$时$f(x)=x-1$，即得到的应当是一个完全积性函数</p>
</li>
<li><p>所以我们可以发现，当且仅当$j=cnt$时，所求得的值才是要求的值</p>
</li>
<li><p>这里可以易证$lpf(i)\le \sqrt n$，即若$lpf(j)^2\ge n$，则$g(n,j)=g(n,j-1)$，因为不存在$lpf(i)&gt;p_j$， 否则：</p>
<script type="math/tex; mode=display">
g(n,j)=g(n,j-1)-f(p_j)\cdot\big(g(\frac{n}{p_j},j-1)-g(p_{j-1},j-1)\big)</script></li>
</ul>
<p><strong>证明：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,j)&=\sum_{i=2}^nf(i)[i\in\mathbb{P}\;\lor\;lpf(i)>p_j]\\
g(n,j-1)&=\sum_{i=2}^nf(i)[i\in\mathbb{P}\;\lor\;lpf(i)>p_{j-1}]\\
\end{align*}</script><ul>
<li><p>那么我们就可以发现，从$j-1$递推到$j$的过程中，我们多计算了一部分贡献，就是$i\notin \mathbb{P} \;\land\; i\ne 1 \;\land\; lpf(i)=p_j$这一部分的贡献</p>
</li>
<li><p>所以我们要减去它们</p>
</li>
<li><p>那么这一部分共有的特点就是都存在最小的质因子$p_j$</p>
</li>
<li><p>那么我们就可以先把$f(p_j)$提出来</p>
</li>
<li><p>即剩下的部分的贡献可以表示为：$\big(g(\frac n{p_j},j-1)-g(p_j-1,j-1)\big)$</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>关于</p>
</li>
<li><script type="math/tex; mode=display">
f(p_j)\cdot g(p_{j-1},j-1)</script></li>
<li><p>这一部分又可以写为:</p>
</li>
<li><script type="math/tex; mode=display">
\sum_{i=1}^{j-1}f(p_i\cdot p_j)</script></li>
<li><p>发现这一部分的数并满足上文所说的$i\notin \mathbb{P} \;\land\; i\ne 1 \;\land\; lpf(i)=p_j$，所以这不能减，得消掉</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>于是就得到了$g$的递推式，进而可以将空间压缩至$\sqrt n$</p>
</li>
<li><p>对于$g$的第一维，其实只有$\frac n1,\frac n2,\frac n3\cdots\frac nn$这些值有被用到。观察递推式，第一位的转移只有$n\rightarrow \frac np$，而下取整又满足结合律：</p>
</li>
<li><script type="math/tex; mode=display">
\left\lfloor\frac{\lfloor\frac {n}{a}\rfloor}{b}\right\rfloor=\left\lfloor\frac{n}{ab}\right\rfloor</script></li>
<li><p>所以无论怎样，这个函数只会用到那么$\sqrt n$个值</p>
</li>
<li><p>对于$g$的第二维，转移只有$j\rightarrow j-1$，与此同时第一位也在缩小，所以我们从大到小更新，就可以直接滚掉第二维</p>
</li>
</ul>
<p><del>据说这一步的时间复杂度就是$O(\frac{n^{\frac {3}{4}}}{\log_2n})$</del></p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>现在，我们要求的就是</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^nf(i)</script><ul>
<li><p>定义二元函数$S$：</p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)=\sum_{i=2}^nF(i)[lpf(i)> p_j]</script></li>
<li><p>显然$ans=S(n,0)$</p>
</li>
<li><p>考虑将答案拆分成素数和合数两个部分计算</p>
</li>
<li><p>显然素数部分的贡献为 </p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)_{素}=g(n,cnt)-g(p_j,j)</script></li>
<li><p>在考虑合数部分：枚举一批数的最小质因子为$p_k$，指数为$e$，那么就可以不重复的计算$lpf(i)\ge p_k$的合数</p>
</li>
<li><p>因为枚举了幂次，所以将${p_k}^e$提出来后，这批数就没有质因子$p_k$了，就可积了</p>
</li>
<li><p><strong>注意</strong>，${p_k}^e$并没有被看作合数，所以贡献是还要加上去的</p>
</li>
<li><p>不用记忆化，直接递归计算即可，边界为$p_j &gt;n,S(n,j)=0$</p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)=g(n,cnt)-g(p_j,j)+\sum_{k=j}^{p_k^2\le n}\sum_{e=1}^{p_k^e\le n}F(p_k^e)(S(\left\lfloor\frac n{p_k^e}\right\rfloor,k)+[e\ne1]</script></li>
<li><p>总时间复杂度为$O(\frac{n^{\frac {3}{4}}}{\log_2n})$</p>
</li>
</ul>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><script type="math/tex; mode=display">
 \begin{aligned} T(n) &= \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{i}\right)\right) + \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{\frac{n}{i}}\right)\right) \\ &= \sum_{i^{2} \le n} O\left(\frac{\sqrt{i}}{\ln{\sqrt{i}}}\right) + \sum_{i^{2} \le n} O\left(\frac{\sqrt{\frac{n}{i}}}{\ln{\sqrt{\frac{n}{i}}}}\right) \\ &= O\left(\int_{1}^{\sqrt{n}} \frac{\sqrt{\frac{n}{x}}}{\log{\sqrt{\frac{n}{x}}}} \mathrm{d} x\right) \\ &= O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right) \end{aligned}</script><p><del>直接表示看不懂好吧，跑路了</del></p>
<h1 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h1><h2 id="Min-25筛-1"><a href="#Min-25筛-1" class="headerlink" title="Min_25筛"></a><a href="https://www.luogu.com.cn/problem/P5325">Min_25筛</a></h2><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>求：$\sum_{i=1}^nF(i)$</p>
<p>其中$\forall p\in \mathbb{P}\quad\forall k\in[1,\inf]\quad F(p^k)=p^k(p^k-1)$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>那么我们可以直接另$f(i) = i(i-1)$</p>
<p>然后就可以直接做了，完全的套式子，十分无脑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll inv = <span class="number">166666668</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll sq, tot, pr[maxn], id1[maxn], id2[maxn], w[maxn];</span><br><span class="line">ll cnt, sum1[maxn], sum2[maxn], g1[maxn], g2[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">return</span> temp &gt;= mod ? temp - mod : temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= sq; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= sq; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="built_in">inc</span>(sum1[i], <span class="built_in">add</span>(sum1[i - <span class="number">1</span>], pr[i])),</span><br><span class="line">        <span class="built_in">inc</span>(sum2[i], <span class="built_in">add</span>(sum2[i - <span class="number">1</span>], <span class="number">1ll</span> * pr[i] * pr[i] % mod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">id</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= sq) <span class="keyword">return</span> id1[x];</span><br><span class="line">    <span class="keyword">return</span> id2[n / x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f1</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f2</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % mod * (<span class="number">2</span> * x % mod + <span class="number">1</span>) % mod * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x, ll j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[j] &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = ((g2[<span class="built_in">id</span>(x)] - g1[<span class="built_in">id</span>(x)] + mod) % mod - (sum2[j] - sum1[j] + mod) % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (ll i = j + <span class="number">1</span>; i &lt;= cnt &amp;&amp; <span class="number">1ll</span> * pr[i] * pr[i] &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll e = <span class="number">1</span>, sp = pr[i]; sp &lt;= x; sp *= pr[i], ++e)</span><br><span class="line">            ans = (ans + sp % mod * (sp % mod - <span class="number">1</span>) % mod * (<span class="built_in">S</span>(x / sp, i) + (e &gt; <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        w[++tot] = n / l;</span><br><span class="line">        g1[tot] = <span class="built_in">f1</span>(w[tot]) - <span class="number">1</span>, g2[tot] = <span class="built_in">f2</span>(w[tot]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (w[tot] &lt;= sq) id1[w[tot]] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[n / w[tot]] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= tot &amp;&amp; <span class="number">1ll</span> * pr[i] * pr[i] &lt;= w[j]; ++j) &#123;</span><br><span class="line">            ll k = <span class="built_in">id</span>(w[j] / pr[i]);</span><br><span class="line">            g1[j] = (g1[j] - pr[i] * (g1[k] - sum1[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">            g2[j] = (g2[j] - <span class="number">1ll</span> * pr[i] * pr[i] % mod * (g2[k] - sum2[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, (<span class="built_in">S</span>(n, <span class="number">0</span>) + <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<p><a href="http://jklover.hs-blog.cf/2019/06/05/min-25筛学习笔记/">JKLover(姥爷的原味博客)</a></p>
<p><a href="https://oi-wiki.org/math/min-25/">OI-wiki不是给人看的好东西</a></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Min_25筛</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2020游记</title>
    <url>/AlanTuringLi/2020/08/18/NOI2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="day1.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-美食家（delicacy）"><a href="#T1-美食家（delicacy）" class="headerlink" title="T1:美食家（delicacy）"></a>T1:<strong>美食家（delicacy）</strong></h1><p>不知道是个什么题，网络流也没想好怎么维护</p>
<p>暴力：<del>直接跑</del></p>
<p>先鸽着</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>NOI</tag>
        <tag>鸽~</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2019</title>
    <url>/AlanTuringLi/2020/09/16/NOIP2019/</url>
    <content><![CDATA[<h1 id="Day1T1-格雷码"><a href="#Day1T1-格雷码" class="headerlink" title="Day1T1 格雷码"></a>Day1T1 <a href="https://www.luogu.com.cn/problem/P5657">格雷码</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个找找规律模拟一下即可, 注意要开$\text{ULL}$, 否则会挂掉</p>
<p><del>规律记不得了</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">N</span><span class="params">(<span class="number">1</span>)</span>, M, K</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span> (--M) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (K &gt;= N) <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>), K = N - K % N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day1T2-括号树"><a href="#Day1T2-括号树" class="headerlink" title="Day1T2 括号树"></a>Day1T2 <a href="https://www.luogu.com.cn/problem/P5658">括号树</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>用栈进行括号匹配, 如果能匹配上, 那么当前位置的答案就是他的父节点的答案加上这个节点有的贡献, 那么就十分的简单了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll stk[maxn], f[maxn], top, cur, ans;</span><br><span class="line">ll sta[maxn], sum[maxn], size[maxn];</span><br><span class="line">ll head[maxn], _edge[maxn], _next[maxn];</span><br><span class="line"><span class="type">char</span> opt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Addedge</span><span class="params">(ll u, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _next[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    _edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u, ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">left</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sta[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (top) &#123;</span><br><span class="line">            left = stk[top];</span><br><span class="line">            size[u] = size[f[left]] + <span class="number">1</span>;</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> stk[++top] = u;</span><br><span class="line">    sum[u] = sum[fa] + size[u];</span><br><span class="line">    <span class="keyword">for</span> (ll i = head[u]; i; i = _next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(_edge[i], u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left) stk[++top] = left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (top) --top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n = __read();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, opt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) sta[i] = (opt[i] == <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">i</span>(<span class="number">2</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = __read();</span><br><span class="line">        <span class="built_in">Addedge</span>(f[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) ans ^= (i * sum[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day1T3-树上的数"><a href="#Day1T3-树上的数" class="headerlink" title="Day1T3 树上的数"></a>Day1T3 <a href="https://www.luogu.com.cn/problem/P5659">树上的数</a></h1><p>鸽~</p>
<hr>
<h1 id="Day2T1-Emiya-家今天的饭"><a href="#Day2T1-Emiya-家今天的饭" class="headerlink" title="Day2T1 Emiya 家今天的饭"></a>Day2T1 <a href="https://www.luogu.com.cn/problem/P5664">Emiya 家今天的饭</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>那么首先考虑容斥, 我们用所有方案减去不可行的方案</p>
<p>设计转移方程 : $Dp[i][j][k]$表示在第$i$种烹饪方式时选择第$j$种食材, 且这种食材比其他食材多用了$k$次</p>
<p>由于$k$有可能是负数, 所以我们给了一个$n$的偏移量</p>
<p>那么$Dp[i][j][k]=Dp[i-1][j][k]+Dp[i-1][k-1]<em>a[i][j]+Dp[i-1][k+1]</em>(sum[i]-a[i][j])$</p>
<p>所以不可行的方案就是$k&gt;n$的方案数</p>
<p>减去即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn][maxn * <span class="number">20</span>], sum[maxn][maxn * <span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> f[maxn][maxn * <span class="number">20</span>][maxn &lt;&lt; <span class="number">1</span>], <span class="built_in">ans</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) sum[i][<span class="number">0</span>] = (sum[i][<span class="number">0</span>] + (a[i][j] = __read())) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) sum[i][j] = (sum[i][<span class="number">0</span>] - a[i][j] + mod) % mod;</span><br><span class="line">        ans = <span class="number">1ll</span> * ans * (sum[i][<span class="number">0</span>] + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        f[<span class="number">0</span>][j][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = n - i; k &lt;= n + i; ++k)</span><br><span class="line">                f[i][j][k] = (f[i - <span class="number">1</span>][j][k] + <span class="number">1ll</span> * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * a[i][j] % mod + <span class="number">1ll</span> * sum[i][j] * f[i - <span class="number">1</span>][j][k + <span class="number">1</span>] % mod) % mod; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = (ans - f[n][j][n + i] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day2T2-划分"><a href="#Day2T2-划分" class="headerlink" title="Day2T2 划分"></a>Day2T2 划分</h1><p>别急, 先鸽鸽~</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>NOI</tag>
        <tag>鸽~</tag>
      </tags>
  </entry>
  <entry>
    <title>CF703D Mishaka and Interesting sum</title>
    <url>/AlanTuringLi/2020/09/15/Mishaka-and-Interesting-sum/</url>
    <content><![CDATA[<h1 id="CF703D-Mishka-and-Interesting-sum"><a href="#CF703D-Mishka-and-Interesting-sum" class="headerlink" title="CF703D Mishka and Interesting sum"></a><a href="https://www.luogu.com.cn/problem/CF703D">CF703D Mishka and Interesting sum</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个序列, 有$m$次询问</p>
<p>每次询问会给你一个$[l, r]$, 让你求区间内出现偶数次的数的异或和</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>首先我们可以想到异或的某些性质:$x\otimes y \otimes x = y$</p>
<p>那么我们可以转化一下题目的意思, 我们可以先求一次区间的异或和, 再去异或一个东西, 可能就是我们想要的答案了</p>
<p>那么抑或什么呢, 按照由题意, 要异或一个能让奇数变成偶数的东西, 简单地说, 就是异或这个区间所有出现的数的异或和, 而并非整个区间的异或和</p>
<p>那么这个就和$\text{HH}$的项链有点类似了</p>
<p>时间复杂度就是一个$O(n\log n)$的了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], sum[maxn], ans[maxn];</span><br><span class="line"><span class="type">int</span> n, m, cnt, tree[maxn];</span><br><span class="line"><span class="type">int</span> __prev[maxn], __last[maxn];</span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp; T) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; T.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">        tree[p] ^= val;</span><br><span class="line">        p += <span class="built_in">lowbit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ans ^= tree[p];</span><br><span class="line">        p -= <span class="built_in">lowbit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Query</span>(r) ^ <span class="built_in">Query</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        <span class="keyword">if</span> (!T[a[i]]) T[a[i]] = ++cnt;</span><br><span class="line">        <span class="type">int</span> p = T[a[i]];</span><br><span class="line">        __last[i] = __prev[p];</span><br><span class="line">        __prev[p] = i;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i)</span><br><span class="line">        Que[i].l = __read(), Que[i].r = __read(), Que[i].id = i;</span><br><span class="line">    <span class="built_in">sort</span> (Que + <span class="number">1</span>, Que + m + <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">p</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= Que[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__last[p]) <span class="built_in">Update</span>(__last[p], a[p]);\\确保这个数只有一次的贡献</span><br><span class="line">            <span class="built_in">Update</span>(p, a[p]);</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[Que[i].id] = <span class="built_in">Query</span>(Que[i].l, Que[i].r) ^ sum[Que[i].r] ^ sum[Que[i].l - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2020-退役记</title>
    <url>/AlanTuringLi/2020/12/07/NOIP2020-%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>P1587[NOI2016]循环之美</title>
    <url>/AlanTuringLi/2020/08/06/P1587%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<h1 id="P1587-NOI2016-循环之美"><a href="#P1587-NOI2016-循环之美" class="headerlink" title="P1587[NOI2016]循环之美"></a><a href="https://www.luogu.com.cn/problem/P1587">P1587[NOI2016]循环之美</a></h1><p>emmmmm</p>
<p>这是一道莫比乌斯反演+杜教筛的好题</p>
<p>题目就不赘述了，即求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]</script><p>这个看完题应该就知道怎么证明了</p>
<p>好，继续化简式子:</p>
<p>$Step\;One:$</p>
<script type="math/tex; mode=display">
\begin{align*}
&\quad\sum_{j=1}^m[j\perp k]\sum_{i=1}^n[i\perp j]\\
&=\sum_{j=1}^m[j\perp k]\sum_{i=1}^n\sum_{d|\gcd(i,j)}\mu(d)\\
&=\sum_{d=1}^{\min(n, m)}\frac nd\mu(d)\sum_{j=1}^{\frac md}[jd\perp k]\\
&=\sum_{d=1}^{\min(n, m)}\frac nd\mu(d)[d\perp k]\sum_{j=1}^{\frac md}[j\perp k]
\end{align*}</script><p>$Step\;Two:$</p>
<p>考虑拆分$\sum\limits_{j=1}^{\frac md}[j\perp k]$</p>
<p>你可以莫比乌斯反演，但是那样就太麻烦了，这个我们可以考虑用欧拉函数和剩余系的方法来处理，于是有：</p>
<script type="math/tex; mode=display">
f(n)=\frac nk\varphi(k)+f(n\%k)</script><p>这个可以预处理+度教筛</p>
<p>$Step\;Three:$</p>
<p>考虑</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,k)&=\sum_{d=1}^n\mu(d)[d\perp k]\\
&=\sum_{d=1}^n\mu(d)\sum_{d\prime|(d,k)}\mu(d\prime)\\
&=\sum_{d=1}^n\mu(d)\sum_{d\prime|d,d\prime |k}\mu(d\prime)\\
&=\sum_{d\prime=1}^n...
\end{align*}</script><p>先说下一种的</p>
<p>考虑先处理$[j\perp k]$，化简可以得到</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,m,k)&=\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]\\
&=\sum_{d|k}\mu(d)f(\frac md,n,d)
\end{align*}</script><p>边界就不用说了？</p>
<p>看代码</p>
<p>​    </p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P2675三角圣地</title>
    <url>/AlanTuringLi/2020/07/20/P2675%E4%B8%89%E8%A7%92%E5%9C%A3%E5%9C%B0/</url>
    <content><![CDATA[<h1 id="P2675-《瞿葩的数字游戏》T3-三角圣地"><a href="#P2675-《瞿葩的数字游戏》T3-三角圣地" class="headerlink" title="P2675 《瞿葩的数字游戏》T3-三角圣地"></a><a href="https://www.luogu.com.cn/problem/P2675">P2675 《瞿葩的数字游戏》T3-三角圣地</a></h1><blockquote>
<p> emmmmm, 这眨眼一看像是个杨辉三角之类的东西, 定眼一看好像不太对啊</p>
</blockquote>
<p>每次把上面两堆合并起来, 显然越靠近中间在最后的结果中出现次数越多, 越靠近两端次数越少, 考虑贪心</p>
<p>所以数列大概长成这个样子:</p>
<script type="math/tex; mode=display">
2, 4, 6,\cdots,2(k-1),2k,2k-1,\cdots,5,3,1</script><p>所以可以得出: $2k-1$与$2k$出现的频率是相通的<del>并没啥用</del></p>
<p>答案可以记为: </p>
<script type="math/tex; mode=display">
Ans = \sum\limits_{i=1}^nc_i\cdot A_i</script><p>打一个表, 与似乎发现系数就$TM$是杨辉三角了啊, 模数很小, 快乐$Lucas$</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> N, Ans;</span><br><span class="line"><span class="type">int</span> Num[Maxn], Fac[Maxn] = &#123;<span class="number">1</span>&#125;, Inv[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">        X = X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Inv[i] = <span class="built_in">Pow</span>(Fac[i], Mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (M &gt; N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Fac[N] * Inv[M] % Mod * Inv[N - M] % Mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lucas</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!M) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Lucas</span>(N / Mod, M / Mod) * <span class="built_in">C</span>(N % Mod, M % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i += <span class="number">2</span>) Num[i &gt;&gt; <span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i += <span class="number">2</span>) Num[N - (i &gt;&gt; <span class="number">1</span>)] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Ans = (Ans + Num[i] % Mod * <span class="built_in">Lucas</span>(N - <span class="number">1</span>, i - <span class="number">1</span>) % Mod) % Mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans % Mod);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title>P2599取石子游戏</title>
    <url>/AlanTuringLi/2020/07/13/P2599%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="P2599-ZJOI2009-取石子游戏"><a href="#P2599-ZJOI2009-取石子游戏" class="headerlink" title="P2599 [ZJOI2009]取石子游戏"></a><a href="https://www.luogu.com.cn/problem/P2599"><strong>P2599 [ZJOI2009]取石子游戏</strong></a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在研究过$Nim$游戏及各种变种之后，$Orez$又发现了一种全新的取石子游戏，这个游戏是这样的： 有$n$堆石子，将这$n$堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。 $Orez$问：对于任意给出一个初始一个局面，是否存在先手必胜策略。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>文件的第一行为一个整数$T$，表示有 $T$组测试数据。</p>
<p>对于每组测试数据，第一行为一个整数$n$，表示有$n$堆石子; 第二行为$n$个整数$a_i$，依次表示每堆石子的数目。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组测试数据仅输出一个整数$0$或$1$。其中$1$表示有先手必胜策略，$0$表示没有。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><blockquote>
<p>如果最靠外边的两堆不一样, 那就先取高的那一堆的一个</p>
<p>然后后手取了几个, 先手就会跟着后手在另一堆中取相同的个石子</p>
<p>易证当两堆的差大于$1$时, 后手一定会先取完一堆</p>
<p>先手该取的那一堆还有石子</p>
<p>谔谔, 出了一点小问题?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T, N, A[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, A + i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(A[<span class="number">0</span>] - A[N - <span class="number">1</span>]) &lt;= <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] == <span class="number">1</span> || A[N - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>P1491集合位置</title>
    <url>/AlanTuringLi/2020/07/20/P1491%E9%9B%86%E5%90%88%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="P1491-集合位置"><a href="#P1491-集合位置" class="headerlink" title="P1491 集合位置"></a><a href="https://www.luogu.com.cn/problem/P1491">P1491 集合位置</a></h1><p>简言之: 求<strong>不严格</strong>的次短路</p>
<p>emmmm, 这个我们考虑$A^*$算法</p>
<p>估价函数$f(x)=g(x)+h(x)$, 其中$g(x)$表示从起点到$x$的花费, $h(x)$表示从$x$到终点的期望最小花费, 这个可以先跑一遍最短路处理出来</p>
<p>然后就是一个优先队列, 关键字为$f(x)$的升序队列, 跑一遍, 第$k$次跑到的终点就是$k$短路了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">205</span>;</span><br><span class="line">pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; P[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn];</span><br><span class="line"><span class="type">double</span> H[Maxn], Cost[<span class="number">40005</span>];</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[<span class="number">40005</span>], E[<span class="number">40005</span>], Cur;</span><br><span class="line"><span class="type">int</span> N, M, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ANode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> X;</span><br><span class="line">    <span class="type">double</span> Dis;</span><br><span class="line">    <span class="type">bool</span> Vis[Maxn];</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ANode &amp;Temp) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Dis + H[X] &gt; Temp.Dis + H[Temp.X];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Dis</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">double</span>(P[U].x - P[V].x) * <span class="built_in">double</span>(P[U].x - P[V].x) + <span class="built_in">double</span>(P[U].y - P[V].y) * <span class="built_in">double</span>(P[U].y - P[V].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = <span class="built_in">Dis</span>(U, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) H[i] = <span class="number">1e9</span>;</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(N);</span><br><span class="line">    H[N] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> X = Q.<span class="built_in">front</span>();</span><br><span class="line">        Vis[X] = <span class="number">0</span>;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (H[E[i]] &lt;= H[X] + Cost[i]) <span class="keyword">continue</span>;</span><br><span class="line">            H[E[i]] = H[X] + Cost[i];</span><br><span class="line">            <span class="keyword">if</span> (Vis[E[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(E[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetRoad</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt;ANode&gt; Q;</span><br><span class="line">    ANode Now = ANode&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Now.Vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(Now);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Now = Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (Now.X == N)++Count;</span><br><span class="line">        <span class="keyword">if</span> (Count == <span class="number">2</span>) <span class="keyword">return</span> Now.Dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = Head[Now.X]; i; i = Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Now.Vis[E[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            ANode Nxt = Now;</span><br><span class="line">            Nxt.X = E[i], Nxt.Dis = Now.Dis + Cost[i];</span><br><span class="line">            Nxt.Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(Nxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;P[i].x, &amp;P[i].y);</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;X, &amp;Y);</span><br><span class="line">        <span class="built_in">AddEdge</span>(X, Y), <span class="built_in">AddEdge</span>(Y, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SPFA</span>();</span><br><span class="line">    <span class="type">double</span> Ans = <span class="built_in">GetRoad</span>();</span><br><span class="line">    <span class="keyword">if</span> (Ans &lt; <span class="number">0.0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, Ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>k短路</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P3810[模板]三位偏序</title>
    <url>/AlanTuringLi/2020/07/27/P3810%5B%E6%A8%A1%E6%9D%BF%5D%E4%B8%89%E4%BD%8D%E5%81%8F%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="P3810-【模板】三维偏序（陌上花开）"><a href="#P3810-【模板】三维偏序（陌上花开）" class="headerlink" title="P3810 【模板】三维偏序（陌上花开）"></a><a href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a></h1><p>这道题, 刚看题时, 感觉就是把三个元素压缩成一个元素, 然后就是一个逆序对这样的一个问题 .</p>
<p>但是, 三个条件要求的是要同时成立, 所以, 不能这样做</p>
<p>既然想到逆序对了, 那么我们就可以先让其中的两维变成有序的, 剩下的一维, 就类似一个逆序对了</p>
<ul>
<li>首先对$X$进行排序</li>
<li>分治, 在每个块中对$Y$排序</li>
<li>对$Z$做逆序对, 此时$Z$是有限制条件的, 它依赖于$X,Y$的取值大小</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> X, Y, Z, Ans, W;</span><br><span class="line">&#125;A[Maxn], B[Maxn];</span><br><span class="line"><span class="type">int</span> Cnt, Ans[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> K, N;</span><br><span class="line"><span class="type">int</span> Tree[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Cmpa</span><span class="params">(Node A, Node B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.X == B.X) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.Y == B.Y) <span class="keyword">return</span> A.Z &lt; B.Z;</span><br><span class="line">        <span class="keyword">return</span> A.Y &lt; B.Y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.X &lt; B.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Cmpy</span><span class="params">(Node A, Node B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.Y == B.Y) <span class="keyword">return</span> A.Z &lt; B.Z;</span><br><span class="line">    <span class="keyword">return</span> A.Y &lt; B.Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Ask</span><span class="params">(<span class="type">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        Ans += Tree[P];</span><br><span class="line">        P -= <span class="built_in">lowbit</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> P, <span class="type">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (P &lt;= K)</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[P] += Val;</span><br><span class="line">        P += <span class="built_in">lowbit</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CDQ</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CDQ</span> (L, Mid), <span class="built_in">CDQ</span> (Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">sort</span> (A + L, A + Mid + <span class="number">1</span>, Cmpy);</span><br><span class="line">    <span class="built_in">sort</span> (A + Mid + <span class="number">1</span>, A + R + <span class="number">1</span>, Cmpy);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(L)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Mid + <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (A[j].Y &lt;= A[i].Y &amp;&amp; j &lt;= Mid)</span><br><span class="line">            <span class="built_in">Add</span>(A[j].Z, A[j].W), ++j;</span><br><span class="line">        A[i].Ans += <span class="built_in">Ask</span>(A[i].Z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; j; ++i) <span class="built_in">Add</span>(A[i].Z, -A[i].W);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;B[i].X, &amp;B[i].Y, &amp;B[i].Z);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span> (B + <span class="number">1</span>, B + N + <span class="number">1</span>, Cmpa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, C = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++C;</span><br><span class="line">        <span class="keyword">if</span> (B[i].X != B[i + <span class="number">1</span>].X || B[i].Y != B[i + <span class="number">1</span>].Y || B[i].Z != B[i + <span class="number">1</span>].Z)</span><br><span class="line">            A[++Cnt] = B[i], A[Cnt].W = C, C = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="built_in">CDQ</span> (<span class="number">1</span>, Cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Cnt; ++i)</span><br><span class="line">        Ans[A[i].Ans + A[i].W - <span class="number">1</span>] += A[i].W;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不明白为啥叫$CDQ$, 大雾</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4180严格次小生成树</title>
    <url>/AlanTuringLi/2020/07/21/P4180%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010]严格次小生成树"></a><a href="https://www.luogu.com.cn/problem/P4180">P4180 [BJWC2010]严格次小生成树</a></h1><p>题意同标题</p>
<p>最小生成树就不用说了, 那么次小生成树就是枚举剩下的边, 把它加入到我们的最小生成树中, 这样就构成了一个奇环树, 考虑这条新加入的边能够取代哪一条边, 能使新生成的树为一颗与原来全职不相等的树?</p>
<p>显然答案是取代第一个长度严格小于新加入的边的那一条, 关于这一条边, 我们可以维护树上两点间的最大边权和严格次大边权</p>
<p>因为做这道题时, <del>没发现写树剖维护的</del>, 觉得倍增写着挺好看的, 于是就写了个倍增维护的</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Maxm = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, M, <span class="built_in">MinInc</span>(<span class="number">1e9</span> + <span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> F[Maxn][<span class="number">20</span>], Max[Maxn][<span class="number">20</span>], SMax[Maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> Depth[Maxn], Fa[Maxn];</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxm &lt;&lt; <span class="number">1</span>], Next[Maxm &lt;&lt; <span class="number">1</span>], Cost[Maxm &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line">ll Ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> U, V, W;</span><br><span class="line">    <span class="type">bool</span> In;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;Temp) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> W &lt; Temp.W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;_E[Maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Fa[X] == X) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> Fa[X] = <span class="built_in">Find</span>(Fa[X]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MST</span><span class="params">(<span class="type">int</span> Cnt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; Cnt != N - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> U = _E[i].U, V = _E[i].V, FU = <span class="built_in">Find</span>(U), FV = <span class="built_in">Find</span>(V);</span><br><span class="line">        <span class="keyword">if</span> (FU == FV) <span class="keyword">continue</span>;</span><br><span class="line">        Fa[FV] = FU;</span><br><span class="line">        ++Cnt;</span><br><span class="line">        _E[i].In = <span class="number">1</span>;</span><br><span class="line">        Ans += _E[i].W;</span><br><span class="line">        <span class="built_in">AddEdge</span>(U, V, _E[i].W);</span><br><span class="line">        <span class="built_in">AddEdge</span>(V, U, _E[i].W);<span class="comment">//建边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//最小生成树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> _f, <span class="type">int</span> WEdge, <span class="type">int</span> Dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Depth[X] = Dep, F[X][<span class="number">0</span>] = _f, Max[X][<span class="number">0</span>] = WEdge, SMax[X][<span class="number">0</span>] = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= Dep; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        F[X][i] = F[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        Max[X][i] = <span class="built_in">max</span>(Max[X][i - <span class="number">1</span>], Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);<span class="comment">//倍增维护最大的边</span></span><br><span class="line">        SMax[X][i] = <span class="built_in">max</span>(SMax[X][i - <span class="number">1</span>], SMax[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);<span class="comment">//次大</span></span><br><span class="line">        <span class="keyword">if</span> (Max[X][i - <span class="number">1</span>] &lt; Max[X][i]) SMax[X][i] = <span class="built_in">max</span>(SMax[X][i], Max[X][i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Max[X][i - <span class="number">1</span>] &gt; Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]) SMax[X][i] = <span class="built_in">max</span>(SMax[X][i], Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(V, X, Cost[i], Dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Depth[X] &lt; Depth[Y]) X ^= Y ^= X ^= Y;</span><br><span class="line">    <span class="type">int</span> K = Depth[X] - Depth[Y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">17</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (K &gt;&gt; i &amp; <span class="number">1</span>) X = F[X][i];</span><br><span class="line">    <span class="keyword">if</span> (X == Y) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (F[X][i] != F[Y][i]) X = F[X][i], Y = F[Y][i];</span><br><span class="line">    <span class="keyword">return</span> F[X][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Work</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T, <span class="type">int</span> _W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span>, K </span>= Depth[S] - Depth[T];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">17</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (K &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Max[S][i] != _W) Ans = <span class="built_in">max</span>(Ans, Max[S][i]);</span><br><span class="line">            <span class="keyword">else</span> Ans = <span class="built_in">max</span>(Ans, SMax[S][i]);</span><br><span class="line">            S = F[S][i];</span><br><span class="line">        &#125;<span class="comment">//找路径上严格小于_W的最大边</span></span><br><span class="line">    MinInc = <span class="built_in">min</span>(MinInc, _W - Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;_E[i].U, &amp;_E[i].V, &amp;_E[i].W);</span><br><span class="line">    <span class="built_in">sort</span> (_E + <span class="number">1</span>, _E + M + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">MST</span>();</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!_E[i].In)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> U = _E[i].U, V = _E[i].V;</span><br><span class="line">            <span class="type">int</span> Lca = <span class="built_in">LCA</span>(U, V);</span><br><span class="line">            <span class="built_in">Work</span> (U, Lca, _E[i].W);</span><br><span class="line">            <span class="built_in">Work</span> (V, Lca, _E[i].W);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans + MinInc);<span class="comment">//答案是最小生成树+最小增量</span></span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若这道题求的并不是严格次小生成树, 那么就不需要维护次小边, 就是说最小增量可能为零</p>
<p>多说一句, 洛谷的数据貌似真的太弱了, 我有地方写挂了竟然都可以$AC$</p>
<p><del>而且洛谷评测的速度比$LOJ$慢太多啦</del></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4655[CEO2017]Building Bridges</title>
    <url>/AlanTuringLi/2020/08/05/P4655%5BCEO2017%5DBuildingBridges/</url>
    <content><![CDATA[<h1 id="Building-Bridges"><a href="#Building-Bridges" class="headerlink" title="Building Bridges"></a><a href="https://www.luogu.com.cn/problem/P4655">Building Bridges</a></h1><h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="$CDQ$分治"></a>$CDQ$分治</h2><p>对, 这道题我的第一反应就是斜率优化</p>
<p>先推一波式子：</p>
<script type="math/tex; mode=display">
\text{先令Dp[i]表示以i结尾的这一段的贡献, S[i]表示关于W[i]的一个前缀和}\\
\begin{align*}
Dp[i] &= (h[i]-h[t])^2+S[i-1]-S[t]\\
Dp[j] &= (h[j]-h[t])^2+S[j-1]-S[t]\\
\end{align*}\\</script><p>若$Dp[j]&gt;Dp[i]$, 那么有：</p>
<script type="math/tex; mode=display">
\begin{align*}
(h[j]-h[t]^2)+S[j-1]-S[t]&>(h[i]-h[t]^2)+S[i-1]-S[t]\\
h[j]^2-2h[j]h[t]+h[t]^2+S[j-1]-S[t]&>h[i]^2-2h[i]h[t]+h[t]^2+S[i-1]-S[t]\\
h[j]^2-2h[j]h[t]+S[j-1]&>h[i]^2-2h[i]h[t]+S[i-1]\\
(h[j]+S[j-1])-(h[i]-S[i-1])&>2h[t]*(h[j]-h[i])\\
\frac{g[j]-g[i]}{h[j]-h[i]}&>2h[t]
\end{align*}</script><p>那么这个式子要想写斜率优化的话，$h$数组要保证单调</p>
<p>嗯，就分治，排序，然后斜率$Dp$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(\log^2n)$应该没有问题吧，没有写代码，口胡</p>
<h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>？？？，怎么回事，看错题了？</p>
<p>没有，个人认为这才是正解！！！</p>
<p>再来看看我们的式子：</p>
<script type="math/tex; mode=display">
\begin{align*}
Dp[i]&=(h[i]-h[t])^2+S[i-1]-S[t]+Dp[t]\\
&=h[i]^2-2h[i]h[t]+h[t]^2+S[i-1]-S[t]+Dp[t]\\
&=h[i]^2+S[i-1]+\min_{t=1}^{i-1}(h[t]^2-2h[t]h[i]-S[t]+Dp[t])
\end{align*}</script><p>看见其实对于我们的$i$，它的答案其实有一部分是定值，还有一部分与之前的信息相关联</p>
<p>那么我们可以新定义一个函数叫$f_t(x)$：</p>
<script type="math/tex; mode=display">
f_t(x)=-2h[t]\times x+h[t]^2-S[t]+Dp[t]</script><p>那么，原式可以化为</p>
<script type="math/tex; mode=display">
Dp[i]=h[i]+S[i-1]+\min_{t=1}^{i-1}f_t(H[i])</script><p>相当于是向一个坐标系中加入了很多条线段，问你在某个点时的最小值，是吧</p>
<p>此时，$f_t(x)$的斜率为$-2h[t]$，截距为$h[t]^2-S[t]+Dp[t]$</p>
<p>就可以了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, L = <span class="number">0</span>, R = <span class="number">1e6</span>, MWi = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll K[Maxn], B[Maxn] = &#123;<span class="number">1e18</span>&#125;, H[Maxn], W[Maxn], F[Maxn];\\B[<span class="number">0</span>]一定要初始化，否则当x取<span class="number">0</span>时，不会进行更新的</span><br><span class="line"><span class="type">int</span> S[MWi &lt;&lt; <span class="number">2</span>], Qx, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Fx</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> K[Id] * X + B[Id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> K, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Fx</span>(L, K) &lt; <span class="built_in">Fx</span>(L, S[X])) S[X] = K;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Fx</span>(Mid, K) &lt; <span class="built_in">Fx</span>(Mid, S[X])) <span class="built_in">swap</span>(K, S[X]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Fx</span>(L, K) &lt; <span class="built_in">Fx</span>(L, S[X])) <span class="built_in">UpDate</span>(L, Mid, K, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Fx</span>(R, K) &lt; <span class="built_in">Fx</span>(R, S[X])) <span class="built_in">UpDate</span>(Mid + <span class="number">1</span>, R, K, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in">Fx</span>(L, S[X]);</span><br><span class="line">    <span class="type">int</span> Mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll Temp = <span class="built_in">Fx</span>(Qx, S[X]);</span><br><span class="line">    <span class="keyword">if</span> (Qx &lt;= Mid) <span class="keyword">return</span> <span class="built_in">min</span>(Temp, <span class="built_in">Query</span>(L, Mid, X &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(Temp, <span class="built_in">Query</span>(Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, K + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> </span><br><span class="line">    (<span class="string">&quot;%lld&quot;</span>, W + i), W[i] += W[i - <span class="number">1</span>];</span><br><span class="line">    B[<span class="number">1</span>] = K[<span class="number">1</span>] * K[<span class="number">1</span>] - W[<span class="number">1</span>];</span><br><span class="line">    K[<span class="number">1</span>] *= <span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">UpDate</span> (L, R, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Qx = K[i];</span><br><span class="line">        F[i] = K[i] * K[i] + W[i - <span class="number">1</span>] + <span class="built_in">Query</span>(L, R);</span><br><span class="line">        B[i] = F[i] + K[i] * K[i] - W[i];</span><br><span class="line">        K[i] *= <span class="number">-2</span>;</span><br><span class="line">        <span class="built_in">UpDate</span> (L, R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, F[N]);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P6216 回文匹配</title>
    <url>/AlanTuringLi/2020/11/10/P6216-%E5%9B%9E%E6%96%87%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="P6216-回文匹配"><a href="#P6216-回文匹配" class="headerlink" title="P6216 回文匹配"></a><a href="https://www.luogu.com.cn/problem/P6216">P6216 回文匹配</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一对字符串 $(s_1,s_2)$，若 $s_1$ 的长度为奇数的子串 $(l,r)$ 满足 $(l,r)$ 是回文的，那么 $s_1$ 的“分数”会增加 $s_2$ 在 $(l,r)$ 中出现的次数。</p>
<p>现在给出一对 $(s_1,s_2)$，请计算出 $s_1$ 的“分数”。</p>
<p>答案对 $2 ^ {32}$ 取模。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数，$n,m$，表示 $s_1$ 的长度和 $s_2$ 的长度。</p>
<p>第二行两个字符串，$s_1,s_2$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示 $s_1$ 的分数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>所以对于一个回文中心为 $i$ 的答案：</p>
<script type="math/tex; mode=display">
ans_i=\sum_{p=0}^{p_i}sum^\prime_{i+p-len_b}-sum^\prime_{i-p}[p\times 2-1\ge len_b]</script><p>然后可以把这个布尔表达式拉出来康康：</p>
<script type="math/tex; mode=display">
p\times 2-1\ge len_b\\
p\times 2\ge len_b+1\\
p\ge\left\lceil\frac{len_b+1}{2}\right\rceil</script><p>所以还可以这样表达：</p>
<script type="math/tex; mode=display">
mid=\left\lceil\frac{len_b+1}2\right\rceil\\
ans_i=\sum_{p=mid}^{p_i}sum^\prime_{i+p-len_b}-sum^\prime_{i-p}</script><p>所以答案就可以写成：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans &= \sum_{i=mid}^{len_a}\sum_{p=mid}^{p_i}sum^\prime_{i+p-len_b}-sum^\prime_{i-p}\\
ans &= \sum_{i=mid}^{len_a}(\sum_{p=mid}^{p_i}sum^\prime_{i+p-len_b})-(\sum_{p=mid}^{p_i}sum^\prime_{i-p})\\
ans &= \sum_{i=mid}^{len_a}(sum^{\prime\prime}_{i+p_i-len_b}-sum^{\prime\prime}_{i+mid-len_b})-(sum^{\prime\prime}_{i-mid}-sum^{\prime\prime}_{i-len_b})\\
\end{aligned}</script><p>所以就可以 $KMP$ 玩了以后做一个二阶的前缀和，然后就这样就可以了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="type">int</span> lena, lenb, sum[maxn];</span><br><span class="line"><span class="type">int</span> pre[maxn], p[maxn];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, nxt = <span class="number">0</span>; i &lt;= lenb; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nxt &amp;&amp; b[nxt + <span class="number">1</span>] != b[i]) nxt = pre[nxt];</span><br><span class="line">		<span class="keyword">if</span> (b[nxt + <span class="number">1</span>] == b[i]) ++nxt;</span><br><span class="line">		pre[i] = nxt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, nxt = <span class="number">0</span>; i &lt;= lena; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nxt &amp;&amp; b[nxt + <span class="number">1</span>] != a[i]) nxt = pre[nxt];</span><br><span class="line">		<span class="keyword">if</span> (b[nxt + <span class="number">1</span>] == a[i]) ++nxt;</span><br><span class="line">		<span class="keyword">if</span> (nxt == lenb) &#123;</span><br><span class="line">			nxt = pre[nxt];</span><br><span class="line">			sum[i - lenb + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; ++i) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; ++i) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">mx</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">id</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	p[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>, p[lena + <span class="number">1</span>] = <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mx &gt; i) p[i] = <span class="built_in">min</span>(p[id * <span class="number">2</span> - i], mx - i);</span><br><span class="line">		<span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (a[i - p[i]] == a[i + p[i]] &amp;&amp; i - p[i] &gt;= <span class="number">1</span> &amp;&amp; i + p[i] &lt;= lena) ++p[i];</span><br><span class="line">		<span class="keyword">if</span> (i + p[i] &gt; mx) mx = p[i] + i, id = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;lena, &amp;lenb);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s %s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kmp</span>();</span><br><span class="line">	<span class="built_in">manacher</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">ceil</span>((lenb + <span class="number">1</span>)/<span class="number">2.0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= lena; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">2</span> * p[i] - <span class="number">1</span> &lt; lenb) <span class="keyword">continue</span>;</span><br><span class="line">		ans += <span class="built_in">Sum</span>(i - lenb + mid, i - lenb + p[i]);</span><br><span class="line">		ans -= <span class="built_in">Sum</span>(i - p[i], i - mid);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>Present</title>
    <url>/AlanTuringLi/2020/09/15/Present/</url>
    <content><![CDATA[<h1 id="Present"><a href="#Present" class="headerlink" title="Present"></a><a href="https://ac.nowcoder.com/acm/problem/110615">Present</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>先给你一串序列,你至多有$\text{m}$次操作使得一段长度为$w$的区间加一</p>
<p>问这串序列的最小值最大可以是多少?</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>最小值最大或者最大值最小,我们的第一反应可能都是二分答案</p>
<blockquote>
<p>简单证明一下:</p>
<blockquote>
<p>如果最小值最大为$x$,那么只要我们少做一次操作,那么$x-1$也是可行的<br>这满足二分答案的性质,所以呢二分答案没有问题的</p>
</blockquote>
</blockquote>
<p>那么关于$check$函数的话,如果当前我们枚举到的数他小于这个我们$\text{check}$的值,那么我们就给这一段区间加上这个差值(如果可以加,否则返回零)</p>
<p>那么时间复杂度大概就是$O(\log10^9*n)$,可以接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m, w, a[maxn];</span><br><span class="line">ll CF[maxn], temp[maxn];</span><br><span class="line"><span class="function">ll <span class="title">l</span><span class="params">(<span class="number">0x7fffffff</span>)</span>, r, ans</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Check</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(temp + <span class="number">1</span>, CF + <span class="number">1</span>, <span class="built_in">sizeof</span>(ll) * n);</span><br><span class="line">    <span class="function">ll <span class="title">now</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">rest</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        now += temp[i];</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (now + rest &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll get = x - now;</span><br><span class="line">        rest -= get;</span><br><span class="line">        now += get;</span><br><span class="line">        <span class="keyword">if</span> (i + w &lt;= n) temp[i + w] -= get;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read(), w = __read();</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)  &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        CF[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">        l = <span class="built_in">min</span>(l, a[i]), r = <span class="built_in">max</span>(r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    r += m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>[SCOI2009]游戏</title>
    <url>/AlanTuringLi/2020/09/18/SCOI2009-%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="SCOI2009-游戏"><a href="#SCOI2009-游戏" class="headerlink" title="[SCOI2009]游戏)"></a><a href="[https://ac.nowcoder.com/acm/problem/20271](https://ac.nowcoder.com/acm/problem/20271">[SCOI2009]游戏</a>)</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个$1$到$n$的序列, 每个数可能对应另一个数</p>
<p>不停的变换, 直到变回串, 一次变换记作一次花费</p>
<p>问你对于所有可能的对应关系, 有多少种不同的花费</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然, 无论对应关系如何, 这些有对应关系的数一定构成环(包括自环)</p>
<p>对于每一个环, 若他的长度为$x$, 那么这个环归位的花费一定为$x$</p>
<p>那么原串长度可以表示为$\sum_{i=1}^n len_i$, 那么花费就为$\mathbb{lcm}len_i$</p>
<p>所以问题就转化为了有多少种不同的$\mathbb{lcm}$</p>
<p>再考虑所有的$\mathbb{lcm}$, 可以表示为$\mathbb{lcm}=p_1^{\max(k_1)}p_2^{\max(k_2)}\cdots p_n^{\max(k_n)}$</p>
<p>看上去是不是有点点像背包了呢?</p>
<p>因为我们知道$\forall i\;p_i\in[1,n], \forall k\;p_ik\in[1,n]$, 那后每个物品至多选一次(若可以选多次, 那么后面选的不应该有贡献, 如上式), 似乎就可以写一个$01$背包了呢</p>
<p>所以我们可以先处理出$1\sim n$内所有的素数,再枚举每个素数的$k\in[1,n]$次方作为体积为$p_i^n$的物品, 容量为$n$</p>
<p>就结束啦<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[maxn];</span><br><span class="line"><span class="type">int</span> pr[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++pr[<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pr[<span class="number">0</span>] &amp;&amp; i * pr[j] &lt;= maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pr[<span class="number">0</span>]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= pr[i]; --j) &#123;<span class="comment">//这里的n只能从n到1,保证每个物品只选一次</span></span><br><span class="line">            <span class="type">int</span> temp = pr[i];</span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= j) f[j] += f[j - temp], temp *= pr[i];<span class="comment">//这里从小到大枚举temp没有什么讲究</span></span><br><span class="line">            <span class="comment">//但是不能先枚举pr[i]的k次方,先枚举次方会导致一个素数被多次计算, 然而他不应该有贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ans += f[i];<span class="comment">//最后枚举有多少个物品, 从0个物品到n个都是有贡献的</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2017]数字表格</title>
    <url>/AlanTuringLi/2020/09/30/SDOI2017-%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="SDOI2017-数字表格"><a href="#SDOI2017-数字表格" class="headerlink" title="[SDOI2017]数字表格"></a><a href="https://www.luogu.com.cn/problem/P3704">[SDOI2017]数字表格</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n\prod_{j=1}^mf_{\gcd(i,j)}</script><p>其中：</p>
<script type="math/tex; mode=display">
f_i=
\begin{cases}
0&i=0\\
1&i=1\\
f_{i-1}+f_{i-2}&i\ge2
\end{cases}</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这其实是一个多么裸的题，最多就用了一个欧拉定理。。。</p>
<p>那就直接来吧(规定$n\le m$)</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=\prod_{i=1}^n\prod_{j=1}^mf_{\gcd(i,j)}\\
&=\prod_{d=1}^nf_d^{\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}[\gcd(i,j)==1]}
\end{aligned}</script><p>其中，那一坨多么难看的指数可以拉出来特殊关照一下</p>
<p>那么就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}[\gcd==1]&=\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}\sum_{k|\gcd(i,j)}\mu(k)\\
&=\sum_{k=1}^{\frac nd}\mu(k)\left\lfloor\frac n{kd}\right\rfloor\left\lfloor\frac m{kd}\right\rfloor\\
\end{aligned}</script><p>带回原式，可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=\prod_{d=1}^n{f_d}^{\sum_{k=1}^{\frac nd}\mu(k)\left\lfloor\frac n{kd}\right\rfloor\left\lfloor\frac m{kd}\right\rfloor}\\
&=\prod_{t=1}^n\prod_{d|t}{f_d}^{\mu(\frac td)\left\lfloor\frac mt\right\rfloor\left\lfloor\frac nt\right\rfloor}
\end{aligned}</script><p>这一步稍微交换一下求值顺序即可得到，然后就是中间多出来的那块求积的东西是可以预处理的，时间复杂度大概是$\ln n$级别的，最后的最后就是一个数论分块，因为预处理完后，这个就可以化简为：</p>
<script type="math/tex; mode=display">
ans=\prod_{t=1}^nF_t^{\left\lfloor\frac mt\right\rfloor\left\lfloor\frac nt\right\rfloor}</script><p>这样以来，就十分的显然了，那么到这里，这道题就是真的水完了</p>
<p>唯一值得注意的就是指数那一坨可能特别的大，于是乎可能需要一个欧拉定理之类的东西</p>
<p>但是看到$n,m\le1e6$，就知道只需要一个$ll$就够了，是否用欧拉定理只是对于常数优化的问题了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * x % mod;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ip[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn], cnt;</span><br><span class="line"><span class="type">int</span> mu[maxn], inv[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn], g[maxn], F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = g[<span class="number">1</span>] = F[<span class="number">0</span>] = F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">        g[i] = <span class="built_in">Pow</span>(f[i], mod - <span class="number">2</span>);</span><br><span class="line">        F[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ip[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            ip[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mu[j / i]) <span class="keyword">continue</span>;</span><br><span class="line">            F[j] = <span class="number">1ll</span> * F[j] * (mu[j / i] == <span class="number">1</span> ? f[i] : g[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) F[i] = <span class="number">1ll</span> * F[i] * F[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n = __read(), m = __read();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">1ll</span> * F[r] * <span class="built_in">Pow</span>(F[l - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">            ans = <span class="number">1ll</span> * ans * <span class="built_in">Pow</span>(temp, <span class="number">1ll</span> * (n / l) * (m / l) % (mod - <span class="number">1</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交了以后，发现这两种写法并没有多大的差别，如果想要优化的话，可以考虑离线一下所有的询问，然后可以排个序，这要确实是可以快很多的</p>
<p>至于更多的奇技淫巧可以看看$loj$上大佬们的做法</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>SP26037 DIVCNT1</title>
    <url>/AlanTuringLi/2020/09/21/SP26037-DIVCNT1/</url>
    <content><![CDATA[<h1 id="SP26073-DIVCNT1-Counting-Divisors"><a href="#SP26073-DIVCNT1-Counting-Divisors" class="headerlink" title="SP26073 DIVCNT1 - Counting Divisors"></a><a href="https://www.luogu.com.cn/problem/SP26073">SP26073 DIVCNT1 - Counting Divisors</a></h1><p>先看了一眼数据范围$n\le 2^{63}$，可以了，这与$Min_25$筛无缘了</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sigma_0(i)</script><h2 id="问题转化："><a href="#问题转化：" class="headerlink" title="问题转化："></a>问题转化：</h2><script type="math/tex; mode=display">
\begin{align*}
\sigma_0(n)&=\sum_{i=1}^n\left\lfloor\frac ni\right\rfloor\\
&=\sum_{i=1}^n\sum_{j=1}^n[i*j\le n]\\
&=\sum_{i=1}^\sqrt n\sum_{j=1}^{\left\lfloor\frac ni\right\rfloor}1+
\sum_{j=1}^\sqrt n\sum_{i=1}^{\left\lfloor\frac nj\right\rfloor}1-\sum_{i=1}^\sqrt n\sum_{j=1}^\sqrt n 1\\
&=2\sum_{i=1}^\sqrt n\left\lfloor\frac ni\right\rfloor-\left\lfloor\sqrt n\right\rfloor^2
\end{align*}</script><p>等价于求函数$y=\frac nx$直线$y=\sqrt n$与直线$y=1$与函数图像和坐标轴相交构成的闭合图形内的整点个数</p>
<p><img src="https://s1.ax1x.com/2020/09/21/w7Oq9P.png" alt=""></p>
<p>紫色阴影部分即为所求（图是嫖的其他巨佬的）</p>
<p>这样，这道题就变成了一道数点问题</p>
<p>通过在$Stern-Brocot$树上寻找斜率，借助单调栈去找一个背包</p>
<p>这部分没太明白，鸽~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> __int128 _ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">Point</span>(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="type">const</span> Point &amp;Temp) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + Temp.x, y + Temp.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;stk[maxn], L, R, M;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">In_R</span><span class="params">(ll x, ll y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)n / x / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ll <span class="title">Slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">_ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="number">0</span>)</span>, rt </span>= <span class="built_in">cbrt</span>(n);</span><br><span class="line">    stk[++t] = <span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    stk[++t] = <span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    ll m = <span class="built_in">sqrt</span>(n), x = n / m, y = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (L = stk[t--]; !<span class="built_in">In_R</span>(x + L.x, y - L.y); x += L.x, y -= L.y)</span><br><span class="line">            res += x * L.y + (L.y + <span class="number">1</span>) * (L.x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= rt) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (R = stk[t]; <span class="built_in">In_R</span>(x + R.x, y - R.y); R = stk[--t]) L = R;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            M = L + R;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">In_R</span>(x + M.x, y - M.y)) &#123;</span><br><span class="line">                stk[++t] = (R = M);</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Slope</span>(x + M.x) &lt;= (<span class="type">double</span>) R.y / R.x) <span class="keyword">break</span>;</span><br><span class="line">                L = M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; y; ++i) res += n / i;</span><br><span class="line">    <span class="keyword">return</span> res * <span class="number">2</span> - <span class="number">1ll</span> * m * m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(_ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        <span class="built_in">Print</span>(<span class="built_in">Slove</span>());</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面三道题确实是妥妥的$\text{Min_25}$筛了</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>鸽~</tag>
      </tags>
  </entry>
  <entry>
    <title>SDOI2015约数个数和</title>
    <url>/AlanTuringLi/2020/11/29/SDOI2015%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<h1 id="SDOI2015-约数个数和"><a href="#SDOI2015-约数个数和" class="headerlink" title="[SDOI2015]约数个数和"></a><a href="https://www.luogu.com.cn/problem/P3327">[SDOI2015]约数个数和</a></h1><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\sigma(ij)</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><script type="math/tex; mode=display">
\sigma(ij)=\sum_{x|i}\sum_{y|j}[x\perp y]</script><p><strong>证明：</strong></p>
<script type="math/tex; mode=display">
i=\prod_{k=1}{p_k}^{a_k},j=\prod_{k=1}{p_k}^{b_k}\\
ij=\prod_{k=1}{p_k}^{a_k+b_k},\sigma(ij)=\prod_{k=1}(a_k+b_k+1)</script><p>所以说，可以有这样的假设：</p>
<ul>
<li>当 $x\perp y\;\;\land {a_k}^\prime&gt;0$ 时，$x\times y$ 的 $p_k$ 的指数就是 ${a_k}^\prime$。</li>
<li>当 $x\perp y\;\;\land {b_k}^\prime&gt;0$ 时，$x\times y$ 的 $p_k$ 的指数就是 $a_k+{b_k}^\prime$</li>
</ul>
<p>所以这样可以不重不漏的枚举出所有 $ij$ 的约数。</p>
<h2 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h2><p>所以原式可以化为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^m\sigma(ij)&=\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[x\perp y]\\
&=\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}\sum_{d|\gcd(x,y)}\mu(d)\\
&=\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}\sigma(i)\sigma(j)\\
&=\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sigma(i)\sum_{j=1}^{\lfloor\frac md\rfloor}\sigma(j)\\
&=\sum_{d=1}^n\mu(d)g(\lfloor\frac nd\rfloor)g(\lfloor\frac md\rfloor)
\end{aligned}</script><p>所以就是 $O(n)$ 的预处理 $+\;O(T\sqrt n)$ 的查询，这道题就愉快的结束了。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="type">int</span> Cnt, Prim[Maxn + <span class="number">5</span>], Mu[Maxn + <span class="number">5</span>], C[Maxn + <span class="number">5</span>];</span><br><span class="line">ll D[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> T, N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = D[<span class="number">1</span>] = C[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Prim[++Cnt] = i, Mu[i] = <span class="number">-1</span>, C[i] = <span class="number">1</span>, D[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * Prim[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Prim[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                D[i * Prim[j]] = D[i] / (C[i] + <span class="number">1</span>) * (C[i] + <span class="number">2</span>);</span><br><span class="line">                C[i * Prim[j]] = C[i] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Mu[i * Prim[j]] = -Mu[i];</span><br><span class="line">            D[i * Prim[j]] = D[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            C[i * Prim[j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		Mu[i] += Mu[i - <span class="number">1</span>], D[i] += D[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">	T = <span class="built_in">read</span>();    </span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">		N = <span class="built_in">read</span>(), M = <span class="built_in">read</span>();        </span><br><span class="line">		<span class="keyword">if</span> (N &gt; M) <span class="built_in">swap</span>(N, M);</span><br><span class="line">        <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">min</span>(N / (N / l), M / (M / l));</span><br><span class="line">            Ans += (Mu[r] - Mu[l - <span class="number">1</span>]) * D[N / l] * D[M / l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>SP34096 DIVCNTK</title>
    <url>/AlanTuringLi/2020/09/21/SP34096-DIVCNTK/</url>
    <content><![CDATA[<h1 id="P34096-DIVCNTK-Counting-Divisors-general"><a href="#P34096-DIVCNTK-Counting-Divisors-general" class="headerlink" title="P34096 DIVCNTK - Counting Divisors (general)"></a><a href="https://www.luogu.com.cn/problem/SP34096">P34096 DIVCNTK - Counting Divisors (general)</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求：</p>
<script type="math/tex; mode=display">
S_k=\sum_{i=1}^n\sigma_0(i^k)\mod{2^{64}}</script><h2 id="Sulotion"><a href="#Sulotion" class="headerlink" title="Sulotion"></a>Sulotion</h2><p>观察发现，$\sigma_0(p^k)=k+1$，不完全积性函数，很好，满足$\text{Min_25}$筛的条件</p>
<p>令：$F(x)=\sigma_0(x^k)$，$f(p)=k+1$</p>
<p>好了，就可以直接套版子了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, p;</span><br><span class="line">ll sq, tot, pr[maxn], id1[maxn], id2[maxn], w[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(ll maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">id</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= sq) <span class="keyword">return</span> id1[x];</span><br><span class="line">    <span class="keyword">return</span> id2[n / x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x, ll j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[j] &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll k = <span class="built_in">id</span>(x);</span><br><span class="line">    ll ans = g[k] - j * (p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = j + <span class="number">1</span>; i &lt;= cnt &amp;&amp; pr[i] * pr[i] &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll e = <span class="number">1</span>, sp = pr[i]; sp &lt;= x; sp *= pr[i], ++e)</span><br><span class="line">            ans += (p * e + <span class="number">1</span>) * (<span class="built_in">S</span>(x / sp, i) + (e &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="built_in">ll</span>(<span class="number">1e6</span>));</span><br><span class="line"></span><br><span class="line">    ll t = __read();</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        n = __read(), p = __read();</span><br><span class="line">        sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">1</span>), r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = n / (n / l);</span><br><span class="line">            w[++tot] = n / l;</span><br><span class="line">            g[tot] = n / l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (w[tot] &lt;= sq) id1[w[tot]] = tot;</span><br><span class="line">            <span class="keyword">else</span> id2[n / w[tot]] = tot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= tot &amp;&amp; pr[i] * pr[i] &lt;= w[j]; ++j) &#123;</span><br><span class="line">                ll k = <span class="built_in">id</span>(w[j] / pr[i]);</span><br><span class="line">                g[j] -= g[k] - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= tot; ++i) g[i] *= (p + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, <span class="built_in">S</span>(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有两道题，一样的，只是手动改一下$p$就可以过了</p>
<p><a href="https://www.luogu.com.cn/problem/SP26073">SP26073 DIVCNT1 - Counting Divisors</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP20173">SP20173 DIVCNT2 - Counting Divisors (square)</a></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>SP7001 VLATTICE - Visible Lattice Points</title>
    <url>/AlanTuringLi/2020/10/12/SP7001-VLATTICE-Visible-Lattice-Points/</url>
    <content><![CDATA[<h1 id="SP7001-VLATTICE-Visible-Lattice-Points"><a href="#SP7001-VLATTICE-Visible-Lattice-Points" class="headerlink" title="SP7001 VLATTICE - Visible Lattice Points"></a><a href="https://www.luogu.com.cn/problem/SP7001">SP7001 VLATTICE - Visible Lattice Points</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求：</p>
<script type="math/tex; mode=display">
3+3\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)==1]+\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[\gcd(i,j,k)==1]</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没啥分析的，直接考虑化简</p>
<p>对于三元的部分有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[\gcd(i,j,k)==1]&=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n\sum_{d|\gcd(i,j,k)}\mu(d)\\
&=\sum_{i=1}^n\mu(i)\left\lfloor\frac ni\right\rfloor^3
\end{aligned}</script><p>对于二元的部分有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
3\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)==1]&=3\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\gcd(i,j)}\mu(d)\\
&=3\sum_{i=1}^n\mu(i)\left\lfloor\frac ni\right\rfloor^2
\end{aligned}</script><p>所以可以稍微整理一下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=3+3\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)==1]+\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[\gcd(i,j,k)==1]\\
&=3+3\sum_{i=1}^n\mu(i)\left\lfloor\frac ni\right\rfloor^2+\sum_{i=1}^n\mu(i)\left\lfloor\frac ni\right\rfloor^3\\
&=3+\sum_{i=1}^n\mu(i)\left\lfloor\frac ni\right\rfloor\times(3\left\lfloor\frac ni\right\rfloor+\left\lfloor\frac ni\right\rfloor^2)
\end{aligned}</script><p>然后数论分块一下就可以了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"><span class="type">int</span> mu[maxn], pr[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++pr[<span class="number">0</span>]] = i, mu[i] = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pr[<span class="number">0</span>] &amp;&amp; i * pr[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = n / (n / l);</span><br><span class="line">            ans += <span class="number">1ll</span> * (mu[r] - mu[l - <span class="number">1</span>]) * (n / l) * (<span class="number">3ll</span> * (n / l) + <span class="number">1ll</span> * (n / l) * (n / l));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>STEVE JOBS</title>
    <url>/AlanTuringLi/2021/05/15/STEVE-JOBS/</url>
    <content><![CDATA[<p>Today my topic is about Steve Jobs’ speech at stanford.</p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=17203668&bvid=BV1oW411h7Ea&cid=28116082&page=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<h2 id="Part-One-Reasons-of-Dropping-Out"><a href="#Part-One-Reasons-of-Dropping-Out" class="headerlink" title="Part One : Reasons of Dropping Out"></a>Part One : Reasons of Dropping Out</h2><p>I am honored to be with you today for your commencement from one of the finest universities in the world.</p>
<p>Truth be told, I never graduated from college. And this is the closest I’ve ever gotten to a collegegraduation.</p>
<p>Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p>
<p>The first story is about connecting the dots.</p>
<p><img src="https://ali.bczcdn.com/reading_image/rimg_999999999_1553845707_42208.jpeg" alt="img"></p>
<p>I dropped out of Reed College after the first six months, but then stayed around as a drop-in for another 18 months or so before I really quit.</p>
<p>So why did I drop out? It started before I was born. My biological mother was a young, unwed graduate student, and she decided to put me up for adoption.</p>
<p>She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided for the last minute that they really wanted a girl.</p>
<p>So my parents, who were on a waiting list, got a call in the middle of the night asking: “We’ve got an unexpected baby boy; do you want him?” They said: “Of course.”</p>
<p>My biological mother found out later that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers.</p>
<p>She only relented a few months later when my parents promised that I would go to college. This was the start in my life.</p>
<p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition.</p>
<p>After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.</p>
<p>So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made.</p>
<p>The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked far more interesting.</p>
<h2 id="Part-Two-Connect-the-Dots"><a href="#Part-Two-Connect-the-Dots" class="headerlink" title="Part Two : Connect the Dots"></a>Part Two : Connect the Dots</h2><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms.</p>
<p>I returned coke bottles for the $0.05 deposits to buy food with, and I would walk the seven miles across town every Sunday night to get one good meal a week at the Hare Krishna temple.</p>
<p>I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on.</p>
<p>Let me give you one example: Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed.</p>
<p>Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p>
<p>I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great.</p>
<p>It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p>
<p><img src="https://ali.bczcdn.com/reading_image/rimg_999999999_1553845741_94301.jpeg" alt="img"></p>
<p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designedit all into the Mac. It was the first computer with beautiful typography.</p>
<p>If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it’s likely that no personal computer would have them.</p>
<p>If I had never dropped out, I would have never dropped in on that calligraphy class, and personal computers might not have the wonderful typography that they do.</p>
<p>Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards 10 years later.</p>
<p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards.</p>
<p>So you have to trust that the dots will somehow connect in your future. You have to trust in something—your gut, destiny, life, karma, whatever.</p>
<p>Because believing that the dots will connect down the road will give you the confidence to follow your heart even when it leads you off the well-worn path and that will make all the difference.</p>
<h2 id="Part-Three-Love-And-LOSS"><a href="#Part-Three-Love-And-LOSS" class="headerlink" title="Part Three : Love And LOSS"></a>Part Three : Love And LOSS</h2><p>My second story is about love and loss.</p>
<p>I was lucky—I found what I loved to do early in life.</p>
<p>Woz and I started Apple in my parents’ garage when I was 20. We worked hard, and in ten years Apple had grown from just the two of us in a garage into a $2 billion company with over 4,000 employees.</p>
<p>We had just released our finest creation—the Macintosh—a year earlier, and I had just turned 30. And then I got fired.</p>
<p>How can you get fired from a company you started?</p>
<p>Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well.</p>
<p>But then our visions of the future began to diverge and eventually we had a falling out.</p>
<p>When we did, our Board of Directors sided with him. And so at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p>
<p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down—that I had dropped the baton as it was being passed to me.</p>
<p>I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.</p>
<p>But something slowly began to dawn on me—I still loved what I did.</p>
<p><img src="https://ali.bczcdn.com/reading_image/rimg_999999999_1553845771_47659.jpeg" alt="img"></p>
<p>The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p>
<p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me.</p>
<p>The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p>
<p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife.</p>
<p>Pixar went on to create the world’s first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.</p>
<p>In a remarkable turn of events, Apple bought NeXT, and I returned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laureneand I have a wonderful family together.</p>
<p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it.</p>
<p>Sometimes life is gonna hit you in the head with a brick. Don’t lose faith.</p>
<p>I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for work as it is for your lovers.</p>
<p>Your work is gonna fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.</p>
<p>If you haven’t found it yet, keep looking. And don’t settle.</p>
<p>As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on.</p>
<p>So keep looking. Don’t settle.</p>
<h2 id="Part-Four-Thoughts-on-Death"><a href="#Part-Four-Thoughts-on-Death" class="headerlink" title="Part Four : Thoughts on Death"></a>Part Four : Thoughts on Death</h2><p>My third story is about death.</p>
<p>When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.”</p>
<p>It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself:</p>
<p>“If today were the last day of my life, would I want to do what I am about to do today?”</p>
<p>And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p>
<p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help memake the big choices in life.</p>
<p>Because almost everything—all external expectations, all pride, all fear of embarrassment or failure—</p>
<p>these things just fall away in the face of death, leaving only what is truly important.</p>
<p>Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose.</p>
<p>You are already naked. There is no reason not to follow your heart.</p>
<p>About a year ago I was diagnosed with cancer.</p>
<p>I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was.</p>
<p>The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.</p>
<p>My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die.</p>
<p>It means to try and tell your kids everything you thought you’d have the next ten years to tell them in just a few months.</p>
<p>It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p>
<p>I lived with that diagnosis all day.</p>
<p><img src="https://ali.bczcdn.com/reading_image/rimg_999999999_1556268007_61746.jpeg" alt="img"></p>
<p>Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor.</p>
<p>I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery.</p>
<p>I had the surgery and thankfully I’m fine now.</p>
<p>This was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades.</p>
<p>Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept: No one wants to die.</p>
<p>Even people who want to go to heaven don’t want to die to get there.</p>
<p>And yet death is the destination we all share. No one has ever escaped it.</p>
<p>And that is as it should be, because Death is very likely the single best invention of Life.</p>
<p>It is Life’s change agent. It clears out the old to make way for the new.</p>
<h2 id="Part-Five-Stay-Hungry-Stay-Foolish"><a href="#Part-Five-Stay-Hungry-Stay-Foolish" class="headerlink" title="Part Five : Stay Hungry. Stay Foolish."></a>Part Five : Stay Hungry. Stay Foolish.</h2><p>Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it’s quite true.</p>
<p>Your time is limited, so don’t waste it living someone else’s life.</p>
<p>Don’t be trapped by dogma—which is living with the results of other people’s thinking. Don’t letthe noise of others’ opinions drown out your own inner voice.</p>
<p>And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p>
<p>When I was young, there was an amazing publication called <strong><em>The Whole Earth Catalog</em></strong>, which was one of the bibles of my generation.</p>
<p><img src="https://ali.bczcdn.com/reading_image/rimg_999999999_1556263733_68797.jpeg" alt="img"></p>
<p>It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.</p>
<p>This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras.</p>
<p>It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, overflowing with neat tools and great notions.</p>
<p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue.</p>
<p>It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous.</p>
<p>Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish.</p>
<p>And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.</p>
<p>Stay Hungry. Stay Foolish.</p>
<p>Thank you all very much.</p>
<ul>
<li>Stay Hungry. Stay Foolish. 求知若饥，虚心若愚。</li>
</ul>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>演讲</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200529</title>
    <url>/AlanTuringLi/2020/05/29/T20200529/</url>
    <content><![CDATA[<h1 id="单词-words"><a href="#单词-words" class="headerlink" title="单词(words)"></a>单词(words)</h1><p><strong>Description</strong></p>
<p> 给你两个由小写字母组成的单词$A$和$B$，我们称一个单词为<strong>幸运单词</strong>，当且仅当它是由$A$的某个非 空前缀和$B$的某个非空后缀拼接而成的（$A$的前缀在$B$的后缀的前面）。</p>
<p> 例如，当单词$A$为$tree$，单词$B$为$heap$时，$trap$就是一个幸运单词，而$traep,aptr$则不是。 请问对于给定的单词$A$和$B$，共有多少个不同的幸运单词？ </p>
<p><strong>Input</strong> </p>
<p>输入包含两行，第一行为单词$A$，第二行为单词$B$。 </p>
<p><strong>Output</strong> </p>
<p>输出一个整数，表示幸运单词的总个数。</p>
<p><strong>Examples</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>tree<br />heap</td>
<td>14</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong> </p>
<p>对于$20\%$的数据，单词$A$的长度$length_A$和单词B的长的$length_B$满足，$1\le length_A, length_B\le 100;$</p>
<p>对于$40\%$的数据， $1\le length_A, length_B\le 10^3;$</p>
<p>对于$100\%$的数据，$1\le length_A, length_B\le 10^5;$</p>
<blockquote>
<p>其实答案因该和$length_A\times length_B$有关</p>
<p>但是看$treap$， 他可以看成$tre+ap$和$tr+eap$</p>
<p>就是说如果直接按照上面直接乘的话，$treap$是被计算了两次的</p>
<p>所以可以一记录一下A，B串中除了首位字符，有多少个重复的字符，就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> A[Maxn], B[Maxn];</span><br><span class="line">ll CntA[<span class="number">30</span>], CntB[<span class="number">30</span>], Temp, Ans;</span><br><span class="line">ll LenA, LenB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;words.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;words.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s %s&quot;</span>, A, B);</span><br><span class="line">	LenA = <span class="built_in">strlen</span>(A), LenB = <span class="built_in">strlen</span>(B);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LenB - <span class="number">1</span>; ++i) CntB[B[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; LenA; ++i) CntA[A[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	Ans = LenA * LenB;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) Ans -= CntA[i] * CntB[i];</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="距离-distance"><a href="#距离-distance" class="headerlink" title="距离(distance)"></a>距离(distance)</h1><p><strong>Description</strong> </p>
<p>给你一个由$0$和$1$组成的$n × m$大小的矩阵$A$，其中第$i$行第$j$列$\left(1\le i\le n, 1 \le j \le m\right)$的元素的坐标 为$\left(i, j\right)$。 </p>
<p>请输出一个$n × m$大小的矩阵$B$。该矩阵第$i$行第$j$列$\left(1\le i\le n, 1 \le j \le m\right)$的元素表示的是，矩阵$A$中坐标为$\left(i, j\right)$的元素到矩阵$A$中欧几里得距离最近的$1$的欧几里得距离。 </p>
<p>对于位置$\left(x, y\right)$和位置$\left(a, b\right)$，它们的欧几里得距离定义为$\left(x - a\right)^2 + \left(y - b\right)^2$。</p>
<p><strong>Input</strong> </p>
<p>输入的第一行包括两个正整数$n, m$。 </p>
<p>接下来有$n$行$01$字符串，每一行字符串的长度为$m$，表示矩阵$B$。 </p>
<p><strong>Output</strong> </p>
<p>请输出$n$行，每一行有$m$个整数，表示矩阵$B$。 </p>
<p><strong>Examples</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 4<br />1000<br />0000<br />0010</td>
<td>0 1 4 5<br />1 2 1 2<br />4 1 0 1</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong></p>
<p>对于$20\%$的数据， $1\le n，m\le 100$</p>
<p>对于100%的数据 $1\le n， m\le 1000$</p>
<blockquote>
<p>对于这个问题，我们可以先看作是对于每一个$1$只对它右下方的$0$有约束作用</p>
<p>那么这道题会变得非常简单啊，就是一个$n^2$暴力就完了，$O(10^6)$还是可以接受的</p>
<p>但是理论上所有的$1$对所有的$0$都有约束作用，那么转一下，跑四遍 $Dp$就可以了 就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="type">char</span> Input[Maxn];</span><br><span class="line"><span class="type">int</span> Dp[Maxn][Maxn], Temp[Maxn][Maxn];<span class="comment">//权值</span></span><br><span class="line">pair &lt;<span class="type">int</span> , <span class="type">int</span>&gt; Pos[Maxn][Maxn], TP[Maxn][Maxn];<span class="comment">//位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (X - Y) * (X - Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Upt</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y, <span class="type">int</span> Nx, <span class="type">int</span> Ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Pos[X][Y].first | Pos[X][Y].second) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> NAns = <span class="built_in">Pow</span>(Nx, Pos[X][Y].first) + <span class="built_in">Pow</span>(Ny, Pos[X][Y].second);</span><br><span class="line">	<span class="keyword">if</span> (NAns &lt; Dp[Nx][Ny])</span><br><span class="line">	&#123;</span><br><span class="line">		Pos[Nx][Ny] = Pos[X][Y];</span><br><span class="line">		Dp[Nx][Ny] = NAns;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			Temp[j][N - i + <span class="number">1</span>] = Dp[i][j];</span><br><span class="line">			TP[j][N - i + <span class="number">1</span>].first = Pos[i][j].second;</span><br><span class="line">			TP[j][N - i + <span class="number">1</span>].second = N - Pos[i][j].first + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	N ^= M ^= N ^= M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) Dp[i][j] = Temp[i][j], Pos[i][j] = TP[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, Dp[i][j]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="built_in">Upt</span> (i - <span class="number">1</span>, j, i, j);</span><br><span class="line">			<span class="keyword">if</span> (j &gt; <span class="number">1</span>) <span class="built_in">Upt</span> (i, j - <span class="number">1</span>, i, j);</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="built_in">Upt</span> (i - <span class="number">1</span>, j - <span class="number">1</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;distance.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;distance.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">memset</span> (Dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, Input + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">			<span class="keyword">if</span> (Input[j] - <span class="string">&#x27;0&#x27;</span>)Dp[i][j] = <span class="number">0</span>, Pos[i][j].first = i, Pos[i][j].second = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i, <span class="built_in">Rotate</span>()) <span class="built_in">Work</span>();</span><br><span class="line">	<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后$std$给的方案是从四个方向分别跑一遍斜率优化$Dp$</p>
<p>大概还是一个意思</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y second</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; point;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n, m, f[maxn][maxn], a[maxn][maxn], tmp[maxn][maxn], d[maxn];</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line">point Q[maxn];</span><br><span class="line">point <span class="keyword">operator</span>-(point a, point b) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">point</span>(a.X - b.X, a.Y - b.Y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1LL</span> * a.X * b.Y - <span class="number">1LL</span> * a.Y * b.X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(point a, point b, point c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cross</span>(b - a, c - a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(point p, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p.Y - <span class="number">2</span> * k * p.X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		d[i] = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> h = <span class="number">0</span>, t = <span class="number">0</span>;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;1&#x27;</span>) d[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> ++d[j];</span><br><span class="line">			</span><br><span class="line">			point now = <span class="built_in">make_pair</span>(j, j * j + d[j] * d[j]);</span><br><span class="line">			<span class="keyword">while</span> (h + <span class="number">1</span> &lt; t &amp;&amp; <span class="built_in">cross</span>(Q[t - <span class="number">1</span>], Q[t], now) &lt;= <span class="number">0</span>) --t;</span><br><span class="line">			Q[++t] = now;</span><br><span class="line">			<span class="keyword">while</span> (h + <span class="number">1</span> &lt; t &amp;&amp; <span class="built_in">calc</span>(Q[h + <span class="number">1</span>], j) &gt; <span class="built_in">calc</span>(Q[h + <span class="number">2</span>], j)) ++h;</span><br><span class="line">			a[i][j] = <span class="built_in">calc</span>(Q[h + <span class="number">1</span>], j) + j * j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;distance.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;distance.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			tmp[i][j] = s[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = a[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">reverse</span>(s[i] + <span class="number">1</span>, s[i] + m + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = <span class="built_in">min</span>(f[i][j], a[i][m - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">			s[i][j] = tmp[n - i + <span class="number">1</span>][j];</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = <span class="built_in">min</span>(f[i][j], a[n - i + <span class="number">1</span>][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">reverse</span>(s[i] + <span class="number">1</span>, s[i] + m + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = <span class="built_in">min</span>(f[i][j], a[n - i + <span class="number">1</span>][m - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, f[i][j], j == m ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><del>又臭又长的$std$</del></p>
</blockquote>
<h1 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h1><p><strong>Description</strong></p>
<p>鼹鼠们在底下开凿了 $n$ 个洞，由 $n-1$ 条隧道连接，对于任意的$ i&gt;1$，第 $i$ 个洞都会和第 $\frac{i}{2}$（取下整）个洞间有一条隧道，第 $i$ 个洞内还有 $c_i$ 个食物能供最多 $c_i$ 只鼹鼠吃。一共有 $m$ 只鼹鼠，第 $i$ 只鼹鼠住在第 $p_i$ 个洞内。</p>
<p>一天早晨，前 $k$ 只 鼹鼠醒来了，而后 $n-k$ 只鼹鼠均在睡觉，前 $k$ 只鼹鼠就开始觅食，最终他们都会到达某一个洞，使得所有洞的 $c_i$ 均大于等于该洞内醒着的鼹鼠个数，而且要求鼹鼠行动路径总长度最小。现对于所有的 $1\le k \le m$，输出最小的鼹鼠行动 路径的总长度，保证一定存在某种合法方案。</p>
<p><strong>Input</strong></p>
<p>第一行两个数 $n,m$，表示有 $n$个洞，$m$只鼹鼠。 第二行 $n$个整数 $c_i$ 表示第 $i$个洞的食物数。 第三行 $m$ 个整数 $p_i$表示第 $i$只鼹鼠所在洞 $p_i$。</p>
<p><strong>Output</strong></p>
<p>输出一行$m$个整数，第$i$个整数表示当$k = i$时鼹鼠的最小行动路径长度。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 4 <br />0 0 4 1 1 <br />2 4 5 2</td>
<td>1 1 2 4</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong></p>
<p>$1\le n,m\le 10^5,\; 0\le c_i\le m,\;1 \le p_i\le n $</p>
<blockquote>
<p>所以第一想法就是贪心，这是毫无疑问的</p>
<p>但是考虑到后面的鼹鼠用剩余的点来贪心的话显然是不正确的</p>
<p>怎么办呐?</p>
<p>于是就可以借用网络流的反悔机制</p>
<p><img src="1.png" alt=""></p>
<p>这是$1$(黑)吃了上面的$1$的情况，显然如果$2$要吃饭了的话，$1$时占据了$2$的坑位的</p>
<p>所以其实$2$其实应该吃的是$1$上面的点，但是我们看见的$2$现在能吃的只是$1$下面的点了</p>
<p>让如果我们让这个时候的$2$经过$1$吃的点的时候的边权为$-1$就等价于$1$吃的是下面的点，而$2$吃的是$1$上面的点了</p>
<p><img src="2.png" alt=""></p>
<p>就是让后来的鼹鼠按相反的方向经过了之前的鼹鼠经过的边时，加上$-1$的边权即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> &amp;X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Y &lt; X ? (X = Y , <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, S;</span><br><span class="line"><span class="type">int</span> Dis[Maxn], C[Maxn], Pos[Maxn], Flow[Maxn];<span class="comment">//规定向上走flow + 1，向下走flow - 1，方便记录方向，以便确定边权</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LenU</span><span class="params">(<span class="type">int</span> X)</span> </span>&#123;<span class="keyword">return</span> Flow[X] &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LenD</span><span class="params">(<span class="type">int</span> X)</span> </span>&#123;<span class="keyword">return</span> Flow[X] &gt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dis[X] = INF, Pos[X] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (C[X]) Dis[X] = <span class="number">0</span>, Pos[X] = X;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Check</span>(Dis[X], Dis[X &lt;&lt; <span class="number">1</span>] + <span class="built_in">LenD</span>(X &lt;&lt; <span class="number">1</span>))) Pos[X] = Pos[X &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Check</span>(Dis[X], Dis[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + <span class="built_in">LenD</span>(X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))) Pos[X] = Pos[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="built_in">memset</span> (Dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, C + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; --i) <span class="built_in">UpDate</span>(i);<span class="comment">//先记录每个点的到子树中最近的洞及距离</span></span><br><span class="line">    <span class="type">int</span> Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;S);</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Cost</span><span class="params">(INF)</span>, <span class="title">Now</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">T</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> X = S; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">1</span>)<span class="comment">//从这个点到1更新相当于遍历了整棵树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Check</span>(Cost, Now + Dis[X])) T = X;</span><br><span class="line">            Now += <span class="built_in">LenU</span>(X);<span class="comment">//更新点S到X的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Target = Pos[T];<span class="comment">//这是目标食物的位置</span></span><br><span class="line">        Ans += Cost;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> X = S; X != T; X &gt;&gt;= <span class="number">1</span>) Flow[X]++;<span class="comment">//从X向上走flow应该+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> X = Target; X != T; X &gt;&gt;= <span class="number">1</span>) Flow[X]--;<span class="comment">//向下走的flow应该-1</span></span><br><span class="line">        C[Target]--;<span class="comment">//又被拿走一个，更新一下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> X = Target; X != T; X &gt;&gt;= <span class="number">1</span>) <span class="built_in">UpDate</span>(X);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> X = S; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">1</span>) <span class="built_in">UpDate</span>(X);<span class="comment">//走过的路径都要更新子树信息</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200603</title>
    <url>/AlanTuringLi/2020/06/03/T20200603/</url>
    <content><![CDATA[<h1 id="1、种树（trees-cpp-1S-128M）"><a href="#1、种树（trees-cpp-1S-128M）" class="headerlink" title="1、种树（trees. cpp/1S/128M）"></a>1、种树（trees. cpp/1S/128M）</h1><p><strong>【问题描述】</strong></p>
<p> 一条街的一边有几座房子。因为环保原因居民想要在路边种些树。路边的地区被分割成$n$块，并被编号为 $1„n$。每个块的大小为一个单位尺寸并最多可种一棵树。每个居民想在门前 种些树并指定了三个号码 $b,e,t$。这三个数表示该居民想在 $b$ 和 $e$ 之间最少种 $t$ 棵树。当 然，$b\le e$，居民必须保证在指定地区不能种多于地区被分割成块数的树，即要求 $t\le e-b+1$， 允许居民想种树的各自区域可以交叉。出于资金短缺的原因，环保部门请你求出能够满足所 有居民的要求，需要种树的最少数量。 </p>
<p><strong>【文件输入】</strong> 第一行为 $n$，表示区域的个数；第二行为 $h$，表示房子的数目；下面 $h$ 行描述居民的需要：$b\;e\;t\left(0&lt;b\le e \le 30000, r \le e-b+l\right)$分别用一个空格分开</p>
<p><strong>【文件输出】</strong> 输出为满足所有要求的最少树的数量。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>9 <br />4 <br />1 4 2 <br />4 6 2 <br />8 9 2 <br />3 5 2</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong></p>
<p>$30\%$的数据满足$0&lt;n\le 1000$, $0 &lt; h \le 500$;</p>
<p>$100\%$的数据满足$n \le 30000$, $h \le 5000$;</p>
<blockquote>
<p>怎么做？</p>
<p>贪心 + 线段树维护</p>
<p>其实数据水， $N^2$也可以$AC$</p>
<p>就是要注意排序的顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, H;</span><br><span class="line"><span class="type">int</span> Sum[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> B, E, T;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;Temp) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (E == Temp.E) <span class="keyword">return</span> T &lt; Temp.T;</span><br><span class="line">        <span class="keyword">return</span> E &lt; Temp.E;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;P[Maxn];<span class="comment">//需求</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushUp</span><span class="params">(<span class="type">int</span> X)</span></span>&#123;Sum[X] = Sum[X &lt;&lt; <span class="number">1</span>] + Sum[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sum[X] = (R - L + <span class="number">1</span>);</span><br><span class="line">    Tag[X] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(L, Mid, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">F</span>(Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) </span><br><span class="line">    &#123;</span><br><span class="line">        Sum[X] = R - L + <span class="number">1</span>;</span><br><span class="line">        Tag[X] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PushDown</span>(L, R, X);</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Tl &lt;= Mid) <span class="built_in">UpDate</span>(L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tr &gt; Mid) <span class="built_in">UpDate</span>(Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PushUp</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) <span class="keyword">return</span> Sum[X];</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, <span class="built_in">Ans</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">PushDown</span>(L, R, X);</span><br><span class="line">    <span class="keyword">if</span> (Tl &lt;= Mid) Ans += <span class="built_in">Query</span>(L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tr &gt; Mid) Ans += <span class="built_in">Query</span>(Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> TL, <span class="type">int</span> TR, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">L</span><span class="params">(TL)</span>, <span class="title">R</span><span class="params">(TR)</span>, <span class="title">Ans</span><span class="params">(TL)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, S = ((Mid - <span class="number">1</span>) &lt; TL ? <span class="number">0</span> : <span class="built_in">Query</span>(<span class="number">1</span>, N, TL, Mid - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (S + TR - Mid + <span class="number">1</span> &gt;= T) Ans = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen (&quot;trees.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen (&quot;trees.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; ++i) </span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;P[i].B, &amp;P[i].E, &amp;P[i].T);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span> (P, P + H);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> Num = <span class="built_in">Query</span>(<span class="number">1</span>, N, P[i].B, P[i].E);</span><br><span class="line">        <span class="keyword">if</span> (Num &gt;= P[i].T) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> Place = <span class="built_in">Get</span>(P[i].B, P[i].E, P[i].T);</span><br><span class="line">        <span class="built_in">UpDate</span>(<span class="number">1</span>, N, Place, P[i].E);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Sum[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="2-高一学堂-at-cpp-1S-256M"><a href="#2-高一学堂-at-cpp-1S-256M" class="headerlink" title="2.高一学堂 (at. cpp/1S/256M)"></a>2.高一学堂 (at. cpp/1S/256M)</h1><p><strong>【问题描述】</strong></p>
<p>在美丽的东辰中学里面，有一座高一学堂。所谓山不在高，有仙则名；水不</p>
<p>在深，有龙则灵。高一学堂，因为有了 $YJYX$，就成了现在这个样子 = =。</p>
<p>由于 $YJYX$ 的语言太过雷人，每次他发微往往都会有一石激起千层浪的效果，</p>
<p>具体就是所有关注他的人都会转发，同时$@$他，接着关注这些人的人也会转</p>
<p>发，同时$@$他关注的人（注意转发内容本身会有$@YJYX$），以此类推。这样导致每</p>
<p>次 llj 发微博都会被$@$上兆次，而 $llj$ 又特别喜欢发，$sina$ 支持不了如此庞大的数</p>
<p>据量，特出规定，每次转发时，$@$的人不能超过 $K$ 人，好友在转发时如果超过</p>
<p>了，就把最早那人删掉。现在 $YJYX$ 刚发了一条微博“求$AK$”，他想知道每个与</p>
<p>他有联系的人分别会被$@$多少次。</p>
<p><strong>【输入】</strong> </p>
<p>输入第一行有三个整数$,N,K,$表示人数和 $K$。</p>
<p>接下来 $N-1$ 行，每行有 $2$ 个整数 $a，b，$表示 $a$ 和 $b$ 有关注关系。</p>
<p>输入给出一棵以 $1$ 号点为根的树，一号点代表 $YJYX$，对于任意一个点，他的</p>
<p>儿子都关注他。</p>
<p><strong>【输出】</strong> </p>
<p>输出有 $N$ 行，每行有一个整数，这个人会被$@$多少次。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 2<br />1 2<br />2 3<br />2 4<br />4 5</td>
<td>3<br />3<br />0<br />1<br />0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong> </p>
<p>对于 $30\%$的数据，$N≤100$；</p>
<p>对于 $60\%$的数据，$N≤2000，k≤100$；</p>
<p>对于 $100\%$的数据，$N≤100000$。</p>
<blockquote>
<p>倍增 + 树上差分一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, K, U, V, Cur;</span><br><span class="line"><span class="type">int</span> Sum[Maxn], Val[Maxn], CF[Maxn], F[Maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[X][<span class="number">0</span>] = Fa; CF[Fa]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i) F[X][i] = F[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> TO = X, TK = K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; TK; ++i)</span><br><span class="line">        <span class="keyword">if</span> (TK &amp; (<span class="number">1</span> &lt;&lt; i)) </span><br><span class="line">        &#123;</span><br><span class="line">            TK ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            TO = F[TO][i];</span><br><span class="line">        &#125;</span><br><span class="line">    CF[F[TO][<span class="number">0</span>]]--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i] ==  Fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span> (E[i], X);</span><br><span class="line">        CF[X] += CF[E[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;at.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;at.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">Read</span>(), K = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        U = <span class="built_in">Read</span>(), V = <span class="built_in">Read</span>();</span><br><span class="line">        <span class="built_in">AddEdge</span>(U, V), <span class="built_in">AddEdge</span>(V, U);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, CF[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="3-高二学堂-poker-cpp-1S-256M"><a href="#3-高二学堂-poker-cpp-1S-256M" class="headerlink" title="3.高二学堂 (poker.cpp/1S/256M)"></a>3.高二学堂 (poker.cpp/1S/256M)</h1><p><strong>【问题描述】</strong></p>
<p>在美丽的东辰中学里，有座高二学堂，同样也是因为一个人，让它们变成了</p>
<p>现在这个样子~那就是我们伟大的级主任。</p>
<p>因为他，我们又迎来了一个木有电影，只有对答案的段考日；又迎来了一个</p>
<p>不是大礼拜，而是小礼拜的周末。因为是小礼拜，同学们都不回家，所以干脆就</p>
<p>回到宿舍去玩牌了。而由于三国杀太$ out $了，所以现在他们都玩四国杀。</p>
<p>四国杀（说白了就是扑克牌~）是 $Wayne$ 发明的，源于他对升级、斗地主、</p>
<p>锄大地等等玩法都感到厌倦了。于是他提出了这个新的玩法：</p>
<p>$Wayne$ 有一副加强版的扑克牌，强大到任意取一个自然数 $x$，在牌堆里都恰</p>
<p>有 $4$ 张数值为 $x$ 的牌。每次，$Wayne$ 随机生成两个正整数 $n$ 和 $k$，然后在牌堆里</p>
<p>选取不超过 $k$ 张牌，使得牌面数字之和恰为 $n$。已知 $Wayne$ 玩了若干盘，每盘都</p>
<p>算出了对应的方案数，他想请你也算出各盘方案数，以验算他的结果是否正确。</p>
<p>结果可能比较大，你只需要求出方案数 $mod 1000000009$ 的值即可。</p>
<p><strong>【输入】</strong> </p>
<p>输入文件包含不超过 $10$ 组数据。</p>
<p>每行包含两个整数，表示上文中的 $n$ 和 $k$。</p>
<p>输入数据以两个 $0$ 表示结束。</p>
<p><strong>【输出】</strong> </p>
<p>输出文件中，每组数据输出一行，为对应的方案数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 1<br />2 2<br />2 3<br />50 5<br />0 0</td>
<td>4<br />10<br />10<br />1823966<br /></td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong> </p>
<p>对于 $10\%$的数据，$k=1$；</p>
<p>对于 $20\%$的数据，$n≤10，k≤4$；</p>
<p>对于 $40\%$的数据，$n≤1000$；</p>
<p>对于 $60\%$的数据，$n≤100000$；</p>
<p>对于另外 $20\%$的数据，只有 $1$ 组数据；</p>
<p>对于 $100\%$的数据，$n≤10^9，k≤10$。</p>
<blockquote>
<p>【算法1】</p>
<p>​    输出n，不解释。。。</p>
<p>​    期望得分：10。</p>
<p>【算法2】</p>
<p>​    利用上式对Ai和Xi进行搜索，同样不解释。。。</p>
<p>​    期望得分：20。</p>
<p>【算法3】</p>
<p>​    把牌按数值大小编号，数值相同的编上4个不同号码。</p>
<p>​    用f[i][j][k]表示现在处理完前i张牌，一共用了j张，构成和为k的方案数。转移只要使用类似背包的方法即可。</p>
<p>方程为：f’[i][j][k]=f[i][j][k]+Σf[i-1][j-1][k-w(i)]。</p>
<p>其中w(i)为i的牌面。</p>
<p>为免MLE，可把第一维省去。</p>
<p>期望得分：40。</p>
<p>【算法4】</p>
<p>​    这是Symbol提出来的方法。</p>
<p>​    如果现在所有的牌面都大于1，假设有k’张，那么把所有牌面都减小1，总和减少k’之后，问题显然是等价的；而如果有牌面等于1，那么只要把这几张牌去掉，剩下的牌面就又都是大于1的了。</p>
<p>​    所以可以使用f[i][j]表示用j张牌构成和为i的方案数，转移的时候分情况：1）所有牌面大于1，则f[i][j]+=f[i-j][j]；2）有牌面等于1，那么我们可以枚举这些牌的数量t（≤4），则f[i][j]+=f[i-j][j-t]。</p>
<p>​    最后答案就是f[n][1~k]的最小值。</p>
<p>​    时间复杂度为O(nk)。</p>
<p>​    期望得分：60。</p>
<p>【算法5】</p>
<p>​    对算法4进行优化，考虑到k比较小，而转移只需要用到前k层的值。</p>
<p>我们可以把连续k层的f压在一个矩阵内，并按一维编号，最多不超过k^2个。然后我们每次转移1层的f，也就是如果现在矩阵记录的是f[1~k][]的值，那么转移一次，矩阵记录的就变成了f[2~k+1][]的值。然后填矩阵就是了。</p>
<p>时间复杂度为O(logn*k^6)，多组数据下，这个方法会由于常数大被卡掉。</p>
<p>期望得分：80。</p>
<p>【算法6】</p>
<p>​    首先，假设牌面的集合为{xi}，集合中的每个元素对应一个ai（≤4），表示这个牌面用了多少张。那么问题就转化成了求Σai*xi=n的正整数解个数，其中x1&lt;x2&lt;…&lt;xm，Σai≤k。由于ai和k都比较小，我们可以暴力枚举所有情况，再去解方程。而现在约束还是比较多的，我们得想办法除去约束。</p>
<p>​    设yi=xi-x(i-1)，换元后方程变为Σbi*yi=n的形式，其中bi≤k。至此，我们成功把未知数单调这个棘手的约束解决了。</p>
<p>​    接下来，我们发现bi比较小（≤10），那么可以把bi的lcm算出来，最多为2520。然后把bi<em>yi表示成pi</em>lcm+qi的形式，其中qi必须能被bi整除。</p>
<p>​    现在方程转化为lcm*Σpi+Σqi=n。</p>
<p>​    考虑到Σqi还是比较小的（≤3W），可以枚举Σqi的每个可能值，那么pi的方案数就可以用经典的隔板法来计算。而对于Σqi的计算，我们可以用背包来实现。背包的时候要注意各种细节，而且注意复杂度的把握。</p>
<p>​    期望得分：100。</p>
<p>然而并没有看懂？？？</p>
<p>当时打了个表就交了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poker Hewr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,a,b) for (int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,a,b) for (int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 1000000009</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mn=<span class="number">11</span>,mm=<span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> a[mn],d[mn],Rev[mn],f[mm],F[mm];</span><br><span class="line"><span class="type">int</span> n,k,m,L,Ans,NowS,N,A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> (c=(a%b)) a=b,b=c;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret=Rev[b];</span><br><span class="line">	<span class="built_in">fo</span> (i,a-b+<span class="number">1</span>,a) ret=(LL)ret*i%mo;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=(LL)ret*a%mo;</span><br><span class="line">		a=(LL)a*a%mo,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">0</span>,NowS) F[i]=f[i];</span><br><span class="line">	<span class="type">int</span> l=L/x*x;</span><br><span class="line">	<span class="built_in">fo</span> (i,NowS+<span class="number">1</span>,<span class="built_in">min</span>(n,NowS+l)) F[i]=<span class="number">0</span>;</span><br><span class="line">	NowS=<span class="built_in">min</span>(n,NowS+l);</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">0</span>,NowS)&#123;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=x)&#123;</span><br><span class="line">			F[i]=(F[i]+(f[i]=F[i-x]))%mo;</span><br><span class="line">			<span class="keyword">if</span> (i&gt;=l+x) f[i]=(f[i]-F[i-l-x]+mo)%mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*int y=x;</span></span><br><span class="line"><span class="comment">	while (y&lt;=L)&#123;</span></span><br><span class="line"><span class="comment">		fd (i,min(n-y,NowS),0) f[i+y]=(f[i+y]+F[i])%mo;</span></span><br><span class="line"><span class="comment">		y+=x;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	NowS=min(n,NowS+L/x*x);*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	d[m]=a[m];</span><br><span class="line">	<span class="built_in">fd</span> (i,m<span class="number">-1</span>,<span class="number">1</span>) d[i]=d[i+<span class="number">1</span>]+a[i];</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,NowS=<span class="number">0</span>,L=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">1</span>,m) L=L*d[i]/<span class="built_in">gcd</span>(L,d[i]);</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">1</span>,m) <span class="built_in">dp</span>(d[i]);</span><br><span class="line">	<span class="built_in">fo</span> (nn,m,NowS) <span class="keyword">if</span> (!((N=n-nn)%L) &amp;&amp; (A=f[nn]))&#123;</span><br><span class="line">		B=<span class="built_in">C</span>(N/L+m<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">		Ans=((LL)A*B+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> K,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (M&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		m=M<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">work</span>();</span><br><span class="line">		Ans=((LL)tmp*W+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!K) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> (i&lt;=K)&#123;</span><br><span class="line">		a[M]=i;</span><br><span class="line">		<span class="built_in">dfs</span>(M+<span class="number">1</span>,K-i,(LL)W*<span class="built_in">C</span>(<span class="number">4</span>,i)%mo);</span><br><span class="line">		a[M]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Rev[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span> (i,<span class="number">1</span>,mn<span class="number">-1</span>) Rev[i]=(LL)Rev[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mo<span class="number">-2</span>)%mo;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;poker.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;poker.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n+k)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,k,<span class="number">1</span>);</span><br><span class="line">		cout&lt;&lt;Ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200607</title>
    <url>/AlanTuringLi/2020/06/07/T20200607/</url>
    <content><![CDATA[<h2 id="题一：答题比赛"><a href="#题一：答题比赛" class="headerlink" title="题一：答题比赛"></a>题一：答题比赛</h2><p><strong>【问题描述】</strong></p>
<p>$YYH$报名参加了一个特殊的电视问答节目。这个节目共有$n$个问题，每回答正确$1$题，$YYH$就会获得$1$分，而每当$YYH$连续答对k题，那么他的现有得分乘以$2$，注意答对第$k$题后，是先加$1$分到总分中，再把总分乘以$2$，此时连续答对题目计数器会清零。现在$YYH$成功对了$m$题，他想知道他的最小得分。因为这个数字可能很大，你只需要输出这个数对$1,000,000,009$取模的结果即可。</p>
<p><strong>【输入格式】</strong></p>
<p>仅一行，三个数$n,m,k$如题目描述。</p>
<p><strong>【输出】</strong></p>
<p>仅一行，一个数，$YYH$的最小得分。</p>
<p><strong>【输入输出样例1】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>exam.in</th>
<th>exam.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 3 2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例2】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>exam.in</th>
<th>exam.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 4 2</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例解释】</strong></p>
<p>样例$1$答对第$1,3,5$题可以获得最低分$3$分；</p>
<p>样例$2$只答错第$4$题，可以获得最低分$6$分。</p>
<p><strong>【数据范围】</strong></p>
<p>对于$30%$的数据，$n,m,k&lt;=10$</p>
<p>对于$60%$的数据，$n,m,k&lt;=1000$</p>
<p>对于$100%$的数据，$1&lt;=k&lt;=n&lt;=10^9，0&lt;=m&lt;=n$</p>
<blockquote>
<p>贪心一下应该就可以了</p>
</blockquote>
<h2 id="题二：人类基因组"><a href="#题二：人类基因组" class="headerlink" title="题二：人类基因组"></a>题二：人类基因组</h2><p><strong>【问题描述】</strong></p>
<p>$L$教授最近正在研究一个关于人类基因的项目，基因可以被看作一个长度为$n$的序列 $A_1,A_2,\dots,An$: 。对于这个基因序列循环移动$k$位之后，就可以得到一个新的基因序列为：$A_k,\dots,A_1,A_2,…,A_k$ 。当一个基因序列满足对于任意的前$i(1&lt;=i&lt;=n)$项和都满足不小于 $0$，我们就称这个基因序列为优质基因序列。</p>
<p>由于$L$教授最近工作比较繁忙，所以找到了正在实验室闲逛的你，你的任务就是帮$L$教授统计出所有优质基因序列的个数。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行一个整数$n$，表示基因序列的长度。<br>第二行$n$个整数，依次为$A_1,A_2,……,A_n$的值。</p>
<p><strong>【输出格式】</strong></p>
<p>输出仅一个整数，表示优质基因序列的个数。</p>
<p><strong>【输入输出样例1】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>genes.in</th>
<th>genes.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>3<br />2 2 3</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例1说明】</strong></p>
<p>  $3$个元素的序列：$2\;2\;3$，循环移动情况如下：<br>  循环移动0位得到序列：$2\;2\;3$，前$i$项和分别为：$2\;4\;7$，符合条件；<br>  循环移动1位得到序列：$2 \;3 \;2$，前$i$项和分别为：$2\;5\;7$；符合条件；<br>  循环移动2位得到序列：$3 \;2 \;2$，前$i$项和分别为：$3 \;5 \;7$；符合条件；</p>
<p><strong>【输入输出样例2】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>genes.in</th>
<th>genes.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5<br />3 -1 2 -3 4</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据范围】</strong></p>
<p>  对于$30%$的数据，满足$1&lt;=N&lt;=5,000 $<br>          对于$50%$的数据，满足$1&lt;=N&lt;=10,000 $<br>          对于$100%$的数据，满足$1&lt;=N&lt;=1,000,000，-1,000&lt;=Ai&lt;=1,000 $</p>
<blockquote>
<p>拼成$2N$的链，单调队列维护一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, Sum, Cut, Ans, H, <span class="built_in">T</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> Arr[Maxn &lt;&lt; <span class="number">1</span>], Q[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">T</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (O == <span class="string">&#x27;-&#x27;</span>) T = <span class="number">-1</span>;</span><br><span class="line">		O = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X * T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;genes.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;genes.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	N = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Arr[i] =  Arr[i + N] = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N * <span class="number">2</span>; ++i) Arr[i] += Arr[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[H]] &gt;= Arr[i]) H++;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[T]] &gt;= Arr[i]) --T;</span><br><span class="line">		Q[++T] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = N; i &lt; N * <span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; i - Q[H] &gt;= N) H++;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[T]] &gt;= Arr[i]) --T;</span><br><span class="line">		Q[++T] = i;</span><br><span class="line">		<span class="keyword">if</span> (Arr[Q[H]] &gt;= Arr[i - N + <span class="number">1</span>]) ++Ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="题三：最短路径"><a href="#题三：最短路径" class="headerlink" title="题三：最短路径"></a>题三：最短路径</h2><p><strong>【问题描述】</strong></p>
<p>平面内给出 $n$个点，记横坐标最小的点为 $A$，最大的点为 $B$，现在$Zxd$想要知道在每个点经过一次（$A$点两次）的情况下从$A$走到$B$，再回到$A$的最短路径。但他是个强迫症患者，他有许多奇奇怪怪的要求与限制条件：</p>
<ul>
<li><p>从 $A$ 走到 $B$ 时，只能由横坐标小的点走到大的点。</p>
</li>
<li><p>由 $B$ 回到 $A$ 时，只能由横坐标大的点走到小的点。</p>
</li>
<li><p>有两个特殊点 $b1$ 和 $b2$， $b1$ 在 $0$ 到 $n-1$ 的路上，$b2$ 在 $n-1$ 到 $0$ 的路上。</p>
</li>
</ul>
<p>请你帮他解决这个问题助他治疗吧！</p>
<p><strong>【输入格式】</strong></p>
<p>第一行三个整数 $n,b1,b2,( 0 &lt; b1，b2 &lt; n-1 且 b1 \neq b2)$。n 表示点数，从 $0$ 到 $n-1$ 编号，$b1$ 和 $b2$ 为两个特殊点的编号。</p>
<p>以下 $n$ 行，每行两个整数 $x,y$ 表示该点的坐标$(0 &lt;= x，y &lt;= 2000)$，从 $0$ 号点顺序给出。$Doctor Gao$为了方便他的治疗，已经将给出的点按 $x$ 增序排好了。</p>
<p><strong>【输出格式】</strong></p>
<p>仅一行，输出最短路径长度（精确到小数点后面 $2$ 位）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>【样例输入】</th>
<th>【样例输出】</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 1 3<br />1 3<br />3 4<br />4 1<br />7 5<br />8 3</td>
<td>18.18</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例解释】</strong></p>
<p>最短路径：$0-&gt;1-&gt;4-&gt;3-&gt;2-&gt;0$</p>
<p><strong>【数据范围】</strong></p>
<p>$20%$的数据$n&lt;=20$</p>
<p>$60%$的数据$n&lt;=300$</p>
<p>$100%$的数据$n&lt;=1000$</p>
<p>对于所有数据$x,y,b1,b2$如题目描述。</p>
<blockquote>
<p>对于这种问题，发现他的数据很小，考虑Dp：</p>
<blockquote>
<p>就是$Dp\left[i\right]\left[j\right]$表示来经过$i$, 回去经过$j$</p>
<p>所以有:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">k = <span class="built_in">max</span>(i, j) + <span class="number">1</span>;</span><br><span class="line">Dp[i][k] = <span class="built_in">max</span>(Dp[i][k], Dp[i][j] + <span class="built_in">Dis</span>(j, k));</span><br><span class="line">Dp[k][j] = <span class="built_in">max</span>(Dp[k][j], Dp[i][j] + <span class="built_in">Dis</span>(i, k));</span><br></pre></td></tr></table></figure>
<p>所以就可以愉快的切掉了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, B1, B2;</span><br><span class="line"><span class="type">double</span> Ans, F[Maxn][Maxn];</span><br><span class="line"><span class="type">int</span> X[Maxn], Y[Maxn], Pre[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((X[A] - X[B]) * (X[A] - X[B]) + (Y[A] - Y[B]) * (Y[A] - Y[B]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">UpDate</span><span class="params">(<span class="type">double</span> &amp;X, <span class="type">double</span> Upt)</span> </span>&#123; <span class="keyword">if</span> (Upt &lt; X) X = Upt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;paths.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;paths.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;N, &amp;B1, &amp;B2);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, X + i, Y + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= N; ++j) </span><br><span class="line">			F[i][j] = INF;</span><br><span class="line">	F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == N - <span class="number">1</span> &amp;&amp; j == N - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> K = <span class="built_in">max</span>(i, j);</span><br><span class="line">			<span class="keyword">if</span> (K == N - <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i != N - <span class="number">1</span> &amp;&amp; K != B2) <span class="built_in">UpDate</span>(F[K][j], F[i][j] + <span class="built_in">Get</span>(i, K));</span><br><span class="line">				<span class="keyword">if</span> (j != N - <span class="number">1</span> &amp;&amp; K != B1) <span class="built_in">UpDate</span>(F[i][K], F[i][j] + <span class="built_in">Get</span>(j, K));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				++K;</span><br><span class="line">				<span class="keyword">if</span> (K != B2) <span class="built_in">UpDate</span>(F[K][j], F[i][j] + <span class="built_in">Get</span>(i, K));</span><br><span class="line">				<span class="keyword">if</span> (K != B1) <span class="built_in">UpDate</span>(F[i][K], F[i][j] + <span class="built_in">Get</span>(j, K));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%.2lf\n&quot;</span>, F[N - <span class="number">1</span>][N - <span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200610</title>
    <url>/AlanTuringLi/2020/06/10/T20200610/</url>
    <content><![CDATA[<h2 id="1-第一题-eat-cpp-c-pas"><a href="#1-第一题-eat-cpp-c-pas" class="headerlink" title="1.第一题 (eat.cpp/c/pas)"></a>1.第一题 (eat.cpp/c/pas)</h2><p><strong>【问题描述】</strong></p>
<p>凶猛的XX出来吃人了!</p>
<p>每天早晨，XX从大山里出来，到达一个城市，然后花费一整天的时间把这座城市里的人 吃光。直到夜晚，XX才回到山中去。当XX经过一个城市时，不管是否吃人，它都会把这座城 市彻底破坏，以至于下次不能再到这个城市吃人了。 </p>
<p>显然，城市里的居民无法忍受这样的状况。所以，每天夜晚，每座城市里都会有一个人 逃到乡下去，到了乡下以后XX就永远吃不到他了。</p>
<p>城市之间有一些双向道路连接着。其中 1 号城市连接着大山，即XX每天的旅途的起点。 当然，XX只能沿着这些道路走。XX意识到必须抓紧时间吃人，所以它每天都要认真选取要去的城市，当然它不能选择已 经被吃过或破坏过的城市。现在问题来了，在所有城市没有人居住之前，XX最多能吃掉多少 人？ </p>
<p><strong>【输入】</strong></p>
<p>​    输入文件名为 eat.in。</p>
<p>​     第一行两个整数𝑛, 𝑚，用一个空格隔开，表示城市的个数和道路数。 </p>
<p>​    第二行𝑛个整数𝑎𝑖，表示每座城市初始的人数。两个数之间用一个空格隔开。 </p>
<p>​    接下来𝑚行，每行两个整数𝑢, 𝑣(1 ≤ 𝑢, 𝑣 ≤ 𝑛, 𝑢 ≠ 𝑣)，用一个空格隔开，表示城市𝑢和城 市𝑣之间有一条双向道路。城市 1 和大山之间也有一条双向道路。 数据保证所有城市都存在到城市 1 的路径。 </p>
<p><strong>【输出】</strong></p>
<p>​     输出文件名为 eat.out。 输出共一行一个整数，表示在所有城市没有人居住之前，**最多能吃掉的人数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th style="text-align:left">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 5 <br />1 3 2 4 7 <br />1 2 <br />1 3 <br />2 3 <br />2 4 <br />3 5</td>
<td style="text-align:left">11</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据说明】</strong> </p>
<p>​    对于 10%的数据，1 ≤ 𝑛 ≤ 5，0 ≤ 𝑚 ≤ 10，0 ≤ 𝑎𝑖 ≤ 5。 </p>
<p>​    对于 30%的数据，1 ≤ 𝑛 ≤ 200，0 ≤ 𝑚 ≤ 500，0 ≤ 𝑎𝑖 ≤ 200。 </p>
<p>​    对于 60%的数据，1 ≤ 𝑛 ≤ 2,000，0 ≤ 𝑚 ≤ 10,000，0 ≤ 𝑎𝑖 ≤ 20,000。 </p>
<p>​    对于 100%的数据，1 ≤ 𝑛 ≤ 200,000，0 ≤ 𝑚 ≤ 2,000,000，0 ≤ 𝑎𝑖 ≤ 2,000,000。</p>
<blockquote>
<p>所以怎么做呢?</p>
<p>考虑贪心: 吃的最多本着上就是走的人最少, 那么就意味着要最先吃掉人最多的地方, 能够有机会离开的人才最少</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll N, M, Ans;</span><br><span class="line">ll Num[Maxn]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;eat.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;eat.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, Num + i);</span><br><span class="line">    <span class="built_in">sort</span> (Num, Num + N, cmp);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Num[i] &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        Ans += (Num[i] - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">&#125;<span class="comment">//一定要开long long, 后面40分爆int了!!!</span></span><br></pre></td></tr></table></figure>
<h2 id="2-整数划分-division-cpp-c-pas"><a href="#2-整数划分-division-cpp-c-pas" class="headerlink" title="2.整数划分 (division.cpp/c/pas)"></a>2.整数划分 (division.cpp/c/pas)</h2><p><strong>【问题描述】</strong> </p>
<p>​    BG 得到了一个整数𝑁，他想要把𝑁分解成若干个小整数的乘积。 </p>
<p>​    BG 给出了他的分解规则： </p>
<ul>
<li>分解出的整数必须来自集合𝑆； </li>
<li>分解出的整数必须互不相同，且两两互质。 现在给出整数𝑁，集合大小𝑀和集合𝑆，求 BG 有多少种分解方法。</li>
</ul>
<p><strong>【输入】</strong> </p>
<pre><code> 输入文件名为 division.in。
</code></pre><p>​     第一行两个整数𝑁, 𝑀，表示要分解的数和集合大小。</p>
<p>​     第二行包含𝑀个互不相同的整数𝑎𝑖，描述了集合𝑆，即𝑆 = {𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑀}。 </p>
<p><strong>【输出】</strong></p>
<p>​     输出文件名为 division.out。 </p>
<p>​    输出共一行一个整数，表示方案数。</p>
<p>​    数据保证答案在 64 位带符号整数范围内。 如果没有方案，输出一个 0。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>12  5<br />2 3 4 5 6<br /></td>
<td>1</td>
</tr>
<tr>
<td>42 8 <br />1 2 3 6 7 14 21 42</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例说明】</strong></p>
<p>​     共 10 种方案：42，1 × 42，2 × 21，3 × 14，6 × 7，1 × 2 × 21，1 × 3 × 14，1 × 6 × 7， 2 × 3 × 7 和 1 × 2 × 3 × 7。</p>
<blockquote>
<p>打一个表:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">30</span></span><br><span class="line"><span class="number">7</span> <span class="number">210</span></span><br><span class="line"><span class="number">11</span> <span class="number">2310</span></span><br><span class="line"><span class="number">13</span> <span class="number">30030</span></span><br><span class="line"><span class="number">17</span> <span class="number">510510</span></span><br><span class="line"><span class="number">19</span> <span class="number">9699690</span></span><br><span class="line"><span class="number">23</span> <span class="number">223092870</span></span><br><span class="line"><span class="number">29</span> <span class="number">6469693230</span></span><br><span class="line"><span class="number">31</span> <span class="number">200560490130</span></span><br><span class="line"><span class="number">37</span> <span class="number">7420738134810</span></span><br><span class="line"><span class="number">41</span> <span class="number">304250263527210</span></span><br><span class="line"><span class="number">43</span> <span class="number">13082761331670030</span></span><br><span class="line"><span class="number">47</span> <span class="number">614889782588491410</span></span><br><span class="line"><span class="number">53</span> <span class="number">-4304329670229058502</span></span><br></pre></td></tr></table></figure>
<p>当我们乘到第$16$的质数时已经是爆$long \; long$了,  那么就是说$N$的不同的质因子最多最多就只有$15$个</p>
<p>那么再看我们的性质$2$ : 分解出的整数必须互不相同，且两两互质</p>
<p>那么说明了什么?</p>
<p>换句话讲,  就是说你每次分解出的整数中, 至少包含了一个质因子, 且这个质因子的所有指数一定会全部被分解出去</p>
<p>否则不能保证分解出的所有整数能够两两互质</p>
<p>那么剩下的就是一个状压DP惹</p>
</blockquote>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> M, P[Maxn], Q[Maxn], S[Maxn &gt;&gt; <span class="number">2</span>], p[Maxn &gt;&gt; <span class="number">2</span>][<span class="number">20</span>], q[Maxn &gt;&gt; <span class="number">2</span>][<span class="number">20</span>];<span class="comment">//p[i][j],q[i][j]分别表示i的第j个质因子的底数和指数, S是记录i有多少个质因子</span></span><br><span class="line">ll N, f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; F;<span class="comment">//F[i] 表示质因子i的指数的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;division.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;division.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">nn</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> X;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= X; ++j)</span><br><span class="line">            <span class="keyword">if</span> (X % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (p[i][++S[i]] = j, P[++nn] = j; X % j == <span class="number">0</span>; X /= j, q[i][S[i]]++);<span class="comment">//记录S集合中的点的信息</span></span><br><span class="line">        <span class="keyword">if</span> (X &gt; <span class="number">1</span>) p[i][++S[i]] = X, q[i][S[i]] = <span class="number">1</span>, P[++nn] = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nn; ++i)</span><br><span class="line">        <span class="keyword">if</span> (N % P[i] == <span class="number">0</span> &amp;&amp; !F[P[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            P[++n] = P[i], F[P[i]] = n;</span><br><span class="line">            <span class="keyword">for</span> (; N % P[i] == <span class="number">0</span>; N /= P[i], Q[n]++);<span class="comment">//分解N, 得到N的一些列质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>) &amp; <span class="number">0</span>;<span class="comment">//如果N此时还有值, 显然S集合中的数是不可行的</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> X = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= S[i]; j++)</span><br><span class="line">            <span class="keyword">if</span> (F[p[i][j]] &amp;&amp; Q[F[p[i][j]]] == q[i][j]) X |= <span class="number">1</span> &lt;&lt; (F[p[i][j]] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                X = <span class="number">-1</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">                <span class="keyword">if</span> (!(j &amp; X)) f[j | X] += f[j];<span class="comment">//累加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);<span class="comment">//顺利切掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考场上想的是暴力:</p>
<p>就是在输入$S$集合的时候，只保留$N$的因子，然后 伪$Dp$求解：</p>
</blockquote>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">map &lt;ll, ll&gt; Dp;</span><br><span class="line">priority_queue &lt;ll&gt; K;</span><br><span class="line">ll N, M, Temp;</span><br><span class="line"><span class="type">bool</span> GRD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Gcd</span><span class="params">(ll X, ll Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span> (Y, X % Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;division.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;division.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;Temp);</span><br><span class="line">        <span class="keyword">if</span> (Temp == <span class="number">1</span>) GRD = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Temp &lt;= N &amp;&amp; <span class="built_in">Gcd</span>(N, Temp) != <span class="number">1</span>) K.<span class="built_in">push</span>(Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!K.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ll Now = K.<span class="built_in">top</span>();</span><br><span class="line">        K.<span class="built_in">pop</span>();</span><br><span class="line">        map &lt;ll, ll&gt; :: iterator P = Dp.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (P != Dp.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> NewK = (P -&gt; first) * Now;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">Gcd</span>(N, NewK) == <span class="number">1</span>) || (NewK &gt; N) || (<span class="built_in">Gcd</span>(Now, P -&gt; first) != <span class="number">1</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                ++P;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Dp[NewK] += P -&gt; second;</span><br><span class="line">            ++P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (GRD) Dp[N] *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Dp[N]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么这份代码当时没有AC呢，非常的简单：</p>
<p>首先：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Temp &lt;= N &amp;&amp; <span class="built_in">Gcd</span>(N, Temp) != <span class="number">1</span>) K.<span class="built_in">push</span>(Temp);</span><br></pre></td></tr></table></figure>
<p>这个就错了， $gcd(N,Temp)\;!= \;\&amp;\&amp; \; gcd(N, Temp) == Temp$才能保证Temp是N的约数</p>
<p>然后还有个$ZZ$错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> NewK = (P -&gt; first) * Now;</span><br></pre></td></tr></table></figure>
<p>$int$显然是爆掉了的</p>
<p>改了以后竟然就有90分了</p>
<p>$TLE$了$2$个点，其实这两个点就是在输入的时候，判断这个数是否取尽了$N$的质因数的指数</p>
<p>可能这样写着不太明白？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">map &lt;ll, ll&gt; Dp;</span><br><span class="line">priority_queue &lt;ll&gt; K;</span><br><span class="line">ll N, M, Temp;</span><br><span class="line"><span class="type">bool</span> GRD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Gcd</span><span class="params">(ll X, ll Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Gcd</span> (Y, X % Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Check</span><span class="params">(ll X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll Temp = N, B = N;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= B; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (X % i) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">while</span> (X % i == <span class="number">0</span> &amp;&amp; Temp % i == <span class="number">0</span>) X /= i, Temp /= i;</span><br><span class="line">  <span class="keyword">if</span> ((Temp % i == <span class="number">0</span>) || (X % i == <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//只要有一个素数的指数不相等就是不可行的方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (X &gt; <span class="number">1</span>) <span class="keyword">return</span> (Temp &gt;= X) &amp;&amp; (Temp % X == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (Temp &gt;= X);</span><br><span class="line">&#125;<span class="comment">//就是加了一个这个，Temp必须取完N中Temp有的所有素数，然后95了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span> (<span class="string">&quot;division.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span> (<span class="string">&quot;division.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;N, &amp;M);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;Temp);</span><br><span class="line">  <span class="keyword">if</span> (Temp == <span class="number">1</span>) GRD = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Check</span>(Temp)) K.<span class="built_in">push</span>(Temp);</span><br><span class="line">&#125;</span><br><span class="line">Dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!K.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ll Now = K.<span class="built_in">top</span>();</span><br><span class="line">  K.<span class="built_in">pop</span>();</span><br><span class="line">  map &lt;ll, ll&gt; :: iterator P = Dp.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span> (P != Dp.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">      ll NewK = (P -&gt; first) * Now;</span><br><span class="line">      <span class="keyword">if</span> ((NewK &gt; N) || (<span class="built_in">Gcd</span>(Now, P -&gt; first) != <span class="number">1</span>)) </span><br><span class="line">      &#123;</span><br><span class="line">          ++P;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Dp[NewK] += P -&gt; second;</span><br><span class="line">      ++P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GRD) Dp[N] *= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Dp[N]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>其实个人认为这个算法理论上是可以过的，但是只有95，猜测是Map遍历太慢了</del></p>
<p>其实就是我太菜了</p>
</blockquote>
<h2 id="3-观光旅行-trip-cpp-c-pas"><a href="#3-观光旅行-trip-cpp-c-pas" class="headerlink" title="3.观光旅行 (trip.cpp/c/pas)"></a>3.观光旅行 (trip.cpp/c/pas)</h2><p><strong>【问题描述】</strong></p>
<p> BG 来到了一个美丽的风景区旅行，这个景区共有𝑛个景点，编号从1到𝑛。这𝑛个景点之 间共有𝑚条双向的观光道路，每条观光道路都有一个魅力值，第𝑖条观光道路的魅力值为𝑤𝑖。</p>
<p> 现在 BG 想从任意一个景点出发，沿着一条路径旅行其它景点。为了避免旅途的枯燥， BG 每次经过的道路的魅力值都要严格大于之前经过的任何道路。同时，他想让旅途尽可能 长。 </p>
<p>请问在满足他的要求的情况下，路径的最长长度是多少，并求出不同的最长路径共有多 少条。路径的长度即它经过的道路数。两条路径被认为不同，当且仅当它们经过的景点序列 不同。为了防止输出的数字过大，你只需输出路径数对$1,000,000,007$取模的结果。 </p>
<p><strong>【输入】</strong></p>
<p> 输入文件名为 trip.in。 </p>
<p>输入文件的第一行有两个用一个空格隔开的整数𝑛、𝑚，表示该景区有𝑛个景点和𝑚条观 光道路。 </p>
<p>接下来𝑚行每行三个整数𝑢𝑖 , 𝑣𝑖 , 𝑤𝑖，每两个整数之间用一个空格隔开，表示第𝑖条道路的 魅力值为𝑤𝑖，在景点𝑢𝑖和𝑣𝑖之间。 输入数据保证𝑢𝑖 ≠ 𝑣𝑖，两个景点之间最多只有一条观光道路，第一问的答案至少为 2。</p>
<p><strong>【输出】</strong></p>
<p> 输出文件名为 trip.out。 </p>
<p>输出的第一行一个整数，表示最长的路径长度。 输出的第二行一个整数，表示不同的最长路径数对$1,000,000,007$取模的结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 5 <br />1 2 4 <br />1 3 5 <br />2 4 3 <br />2 3 1 <br />2 5 2</td>
<td>3<br />3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例说明】</strong></p>
<p> 共有 3 条长度为 3 的合法路径： </p>
<p>3—2—1—3，经过道路的魅力值为 1、4、5；</p>
<p>4—2—1—3，经过道路的魅力值为 3、4、5； </p>
<p>5—2—1—3，经过道路的魅力值为 2、4、5。 </p>
<p><strong>【数据说明】</strong> </p>
<p>对于 10%的数据，1 ≤ 𝑛 ≤ 10，1 ≤ 𝑚 ≤ 20； </p>
<p>对于 30%的数据，1 ≤ 𝑛 ≤ 100，1 ≤ 𝑚 ≤ 500； </p>
<p>对于 60%的数据，1 ≤ 𝑛 ≤ 1,000，1 ≤ 𝑚 ≤ 3,000；</p>
<p>对于 80%的数据，1 ≤ 𝑛 ≤ 2,000，1 ≤ 𝑚 ≤ 100,000； </p>
<p>对于 100%的数据，1 ≤ 𝑛 ≤ 50,000，1 ≤ 𝑚 ≤ 200,000，0 ≤ 𝑤𝑖 ≤ 109。</p>
<blockquote>
<p>所以对于这道题，考试的时候我爆零了，that is 我太菜了！！！</p>
<p>怎么处理路径上的边权单调上升呢？</p>
<p>考虑：</p>
<blockquote>
<p>从小的边到大的边再建一条新的边，易证得到的新图是一个DAG</p>
<p>怎么建图？</p>
<p>首先有出边$j$的虚点$j’$向$j$ 建一条边权为$1$的边那么只要经过了这个点，就会对路径长度产生贡献</p>
<p>从入边向边权比它大的边的虚边建一条边权为$0$的点</p>
<p>然后再拓扑一便就统计答案即可</p>
</blockquote>
</blockquote>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pr pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = (<span class="number">2e5</span> + <span class="number">5</span>) * <span class="number">4</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, N, M, Cur, X, Y, Z;</span><br><span class="line"><span class="type">int</span> F[Maxn], G[Maxn], In[Maxn], Q[Maxn];</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], W[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">vector &lt; Pr &gt; V[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">	W[Cur] = A;</span><br><span class="line">	In[V]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;c, <span class="type">int</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; c) c = a, d = b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == c) d = (d + b) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = （M + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">t</span>(<span class="number">0</span>); i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sort</span> (V[i].<span class="built_in">begin</span>(), V[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">j</span>(<span class="number">0</span>), <span class="built_in">k</span>(<span class="number">0</span>); j &lt; V[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="built_in">AddEdge</span>(n + j, V[i][j].second, <span class="number">1</span>);<span class="comment">//从j&#x27;到j建一条1的边</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; V[i].<span class="built_in">size</span>() &amp;&amp; V[i][j].first == V[i][k].first) ++k;<span class="comment">//保证严格单调</span></span><br><span class="line">			<span class="keyword">if</span> (k &lt; V[i].<span class="built_in">size</span>()) <span class="built_in">AddEdge</span>(V[i][j].second ^ <span class="number">1</span>, n + k, <span class="number">0</span>);<span class="comment">//从另一条边进来，从这条边（k）出去</span></span><br><span class="line">			<span class="keyword">if</span> (j) <span class="built_in">AddEdge</span>(n + j - <span class="number">1</span>, n + j, <span class="number">0</span>);<span class="comment">//因为都是同一个点的边，所以可以0贡献换边</span></span><br><span class="line">		&#125;</span><br><span class="line">		n += V[i].<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;trip.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;trip.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;X, &amp;Y, &amp;Z);</span><br><span class="line">		V[X].<span class="built_in">push_back</span>(<span class="built_in">Pr</span>(Z, i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		V[Y].<span class="built_in">push_back</span>(<span class="built_in">Pr</span>(Z, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Build</span>();</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">L</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">R</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="keyword">if</span> (!In[i]) F[i] = <span class="number">0</span>, G[i] = <span class="number">1</span>, Q[++R] = i;</span><br><span class="line">	<span class="keyword">for</span> (; L &lt;= R; ++L)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> u = Q[L], i = Head[u], v; v = E[i], i; i = Next[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UpDate</span>(F[u] + W[i], G[u], F[v], G[v]);</span><br><span class="line">			<span class="keyword">if</span> (!--In[v]) Q[++R] = v;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Y</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">UpDate</span>(F[i], G[i], X, Y);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n%d\n&quot;</span>, X, Y);</span><br><span class="line">&#125;<span class="comment">//切掉惹</span></span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>细节处理还是有问题，比如说$T1，T2$ 没有开$long\;long$少了整整$60$</p>
<p>然后加上对$T2$的优化又多$5$分， 也就是说理论应该是$200$分， 实际得分$125$</p>
<p>还要加油呀😆</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>考试</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200824</title>
    <url>/AlanTuringLi/2020/08/24/T20200824/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-基因合成"><a href="#T1-基因合成" class="headerlink" title="T1 基因合成"></a>T1 基因合成</h1><p>神奇的题面描述，这个不管</p>
<p>简言之，求通过给定操作，求到目标状态的最少操作次数</p>
<p>操作如下：</p>
<ul>
<li>在串的头部或尾部插入一个字符</li>
<li>将串复制一次，逆序接在原串的后面</li>
</ul>
<h2 id="60-分做法"><a href="#60-分做法" class="headerlink" title="$60$分做法"></a>$60$分做法</h2><p>先说说$Dp$，状态设计:</p>
<script type="math/tex; mode=display">
f(i,j)=min
\begin{cases}
f(i+1, j)+1
\\f(i,j-1)+1
\\f(i,mid)+1\quad\text{i到j长度为偶数，且这是回文串}
\end{cases}</script><p>$60$就到手了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> T, Dp[Maxn][Maxn];</span><br><span class="line"><span class="type">char</span> S[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, S);</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(S);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) Dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt; len; ++l)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = i + l; j &lt; len; ++i, ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				Dp[i][j] = <span class="built_in">min</span>(Dp[i + <span class="number">1</span>][j], Dp[i][j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span> (l &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="function"><span class="type">bool</span> <span class="title">k</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">					<span class="type">int</span> le = i, re = j;</span><br><span class="line">					<span class="keyword">for</span> (; le &lt; re; ++le, --re)</span><br><span class="line">						<span class="keyword">if</span> (S[le] != S[re]) k = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span> (k) Dp[i][j] = <span class="built_in">min</span>(Dp[i][j], <span class="built_in">min</span>(Dp[i][le - <span class="number">1</span>], Dp[re + <span class="number">1</span>][j]));</span><br><span class="line">                    <span class="comment">//这里的话，le、re都跑过了，要往回走一步</span></span><br><span class="line">				&#125;</span><br><span class="line">				Dp[i][j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Dp[<span class="number">0</span>][len - <span class="number">1</span>]);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="100-分做法"><a href="#100-分做法" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>再看看这道题，我们发现有一个性质：</p>
<ul>
<li>某个复制操作可能是被另一个复制操作所包含的，但是两个复制操作是不可能并列的</li>
</ul>
<p>那么我们就可以找到每个长度为偶数的回文串，用$f(i)$表示在回文数下节点编号为$i$的回文串的最小生成步数，$len(i)$表示回文串长度</p>
<p>那么答案就可以这样更新$ans=min(ans,n-len(i)+f(i))$，因为回文串以外的字符只能选择插入了</p>
<p>考虑如何更新$f(i)$：</p>
<script type="math/tex; mode=display">
f(i)=\min\{f(j)+1,len(i)/2-len(tran(i))+1\}</script><p>其中$tran(i)$表示回文串$i$的某个能够通过最少次操作得到$i$的子串</p>
<p>这道题就差不多结束了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> S[Maxn];</span><br><span class="line"><span class="type">int</span> T, N, P, Q, Tot, Ans, Last, F[Maxn];</span><br><span class="line"><span class="type">int</span> Len[Maxn], Fail[Maxn], Tras[Maxn], Ch[Maxn][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Fail[<span class="number">0</span>] = F[<span class="number">0</span>] = Tot = <span class="number">1</span>, S[<span class="number">0</span>] = Len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">	Last = Len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(Ch, <span class="number">0</span>, <span class="keyword">sizeof</span> Ch);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, S + <span class="number">1</span>);</span><br><span class="line">	N = Ans = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Newnode</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Len[++Tot] = X;</span><br><span class="line">	<span class="keyword">return</span> Tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetFail</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (S[N - Len[X] - <span class="number">1</span>] != S[N]) X = Fail[X];</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">HASH</span><span class="params">(<span class="type">char</span> O)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span> ();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> X = <span class="built_in">HASH</span>(S[i]);</span><br><span class="line">		P = <span class="built_in">GetFail</span> (Last, i);</span><br><span class="line">		<span class="keyword">if</span> (!Ch[P][X])</span><br><span class="line">		&#123;</span><br><span class="line">			Q = <span class="built_in">Newnode</span>(Len[P] + <span class="number">2</span>);</span><br><span class="line">			Fail[Q] = Ch[<span class="built_in">GetFail</span>(Fail[P], i)][X];</span><br><span class="line">			Ch[P][X] = Q;</span><br><span class="line">			<span class="keyword">if</span> (Len[Q] &lt;= <span class="number">2</span>) Tras[Q] = Fail[Q];</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> Temp = Tras[P];</span><br><span class="line">				<span class="keyword">while</span> (S[i - Len[Temp] - <span class="number">1</span>] != S[i] || (Len[Temp] + <span class="number">2</span>) * <span class="number">2</span> &gt; Len[Q]) Temp = Fail[Temp];</span><br><span class="line">                Tras[Q] = Ch[Temp][X];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Last = Ch[P][X];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span> (<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">			<span class="keyword">if</span> (Ch[x][i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> t = Ch[x][i];</span><br><span class="line">				F[t] = F[x] + <span class="number">1</span>;</span><br><span class="line">				F[t] = <span class="built_in">min</span>(F[t], Len[t] / <span class="number">2</span> - Len[Tras[t]] + F[Tras[t]] + <span class="number">1</span>);</span><br><span class="line">				Ans = <span class="built_in">min</span>(Ans, N - Len[t] + F[t]);</span><br><span class="line">				Q.<span class="built_in">push</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Build</span> ();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Tot; ++i)</span><br><span class="line">			<span class="keyword">if</span> (Len[i] &amp; <span class="number">1</span>) F[i] = Len[i];</span><br><span class="line">		<span class="built_in">BFS</span>();</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-染色"><a href="#T2-染色" class="headerlink" title="T2 染色"></a>T2 染色</h1><p>给定一棵树，初始状态所有的点全为白点</p>
<p>有如下两种操作：</p>
<ul>
<li>$opt=1$，将$x$染为黑色</li>
<li>$opt=2$，求所有黑点到$x$的简单路径长</li>
</ul>
<h2 id="30-分做法"><a href="#30-分做法" class="headerlink" title="$30$分做法"></a>$30$分做法</h2><p>直接暴力跑，这个树是随机的，嗯就完了吧</p>
<h2 id="100-分做法-1"><a href="#100-分做法-1" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>考虑根为$1$的树上，一对简单路径长度:</p>
<script type="math/tex; mode=display">
len = dis(u,1)+dis(v,1)-2\times dis(lca(u,v),1)</script><p>这个显然是正确的，那么所有黑点到$x$的距离为：</p>
<script type="math/tex; mode=display">
\begin{align*}
Ans&=\sum_{i=1}^{cnt}(dis(u_i)+dis(x)-2\times dis(lca(u_i,x)))
\\&=\sum_{i=1}^{cnt}dis(u_i)+cnt\times dis(x)-2\sum_{i=1}^{cnt}dis(lca(u_i,x))
\end{align*}</script><p>那么这个问题就变得相对简单了，$dis(x)$直接预处理，$\sum_{i=1}dis(u_i)$可以直接暴力加上去</p>
<p>那么问题就变成了求$\sum_{i=1}dis(lca(u_i,x))$，这个我们可以发现，$lca(u,x)$一定在$u$到根和$x$到根的路径上</p>
<p>就是说我们要求$dis(lca(u,x))$的话，可以直接求$Dis(x)$</p>
<p>即，每次插入一个黑点，将这个点到根的路径上的所有的边权的加入贡献，再求$x$到根经过的边的贡献之和</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N, M, U, V, Cost, Opt, Q;</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>], Cur, W[Maxn &lt;&lt; <span class="number">1</span>], Arr[Maxn], Cnt;</span><br><span class="line"><span class="type">int</span> Son[Maxn], Dep[Maxn], Size[Maxn], F[Maxn], Top[Maxn], SE[Maxn], ID[Maxn];<span class="comment">//树剖</span></span><br><span class="line">ll Sum[Maxn &lt;&lt; <span class="number">2</span>], Ans[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>], Len[Maxn], A;<span class="comment">//线段树</span></span><br><span class="line"><span class="type">int</span> Temp[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F[X] = Fa, Dep[X] = Dep[Fa] + <span class="number">1</span>, Size[X] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == Fa)<span class="keyword">continue</span>;</span><br><span class="line">		Size[X] += <span class="built_in">DFS</span>(E[i], X);</span><br><span class="line">		<span class="keyword">if</span> (Size[E[i]] &gt; Size[Son[X]]) Son[X] = E[i], SE[X] = W[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Size[X];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Tp, <span class="type">int</span> Edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Top[X] = Tp, ID[X] = ++Cnt, Arr[Cnt] = Edge, Len[X] = Len[F[X]] + Edge;</span><br><span class="line">	<span class="keyword">if</span> (Son[X]) <span class="built_in">DFS</span>(Son[X], Tp, SE[X]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == F[X] || E[i] == Son[X]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(E[i], E[i], W[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushUp</span><span class="params">(<span class="type">int</span> X)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sum[X] = Sum[X &lt;&lt; <span class="number">1</span>] + Sum[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	Ans[X] = Ans[X &lt;&lt; <span class="number">1</span>] + Ans[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R) </span><br><span class="line">	&#123;</span><br><span class="line">		Sum[X] = Arr[L];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Build</span> (L, Mid, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Build</span> (Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">PushUp</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> X, ll Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tag[X] += Val;</span><br><span class="line">	Ans[X] += Val * Sum[X];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">Down</span> (X &lt;&lt; <span class="number">1</span>, Tag[X]);</span><br><span class="line">	<span class="built_in">Down</span> (X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, Tag[X]);</span><br><span class="line">	Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> Val, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Down</span>(X, Val);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PushDown</span>(X);</span><br><span class="line">	<span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) <span class="built_in">UpDate</span> (L, Mid, Tl, Tr, Val, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) <span class="built_in">UpDate</span> (Mid + <span class="number">1</span>, R, Tl, Tr, Val, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">PushUp</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) <span class="keyword">return</span> Ans[X];</span><br><span class="line">	<span class="built_in">PushDown</span>(X);</span><br><span class="line">	<span class="type">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) Ans += <span class="built_in">Query</span> (L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) Ans += <span class="built_in">Query</span> (Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> Ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Top[U] != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UpDate</span> (<span class="number">1</span>, N, ID[Top[U]], ID[U], <span class="number">1</span>);</span><br><span class="line">		U = F[Top[U]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">UpDate</span> (<span class="number">1</span>, N, ID[<span class="number">1</span>], ID[U], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="type">int</span> U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Top[U] != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Ans += <span class="built_in">Query</span> (<span class="number">1</span>, N, ID[Top[U]], ID[U]);</span><br><span class="line">		U = F[Top[U]];</span><br><span class="line">	&#125;</span><br><span class="line">	Ans += <span class="built_in">Query</span> (<span class="number">1</span>, N, ID[<span class="number">1</span>], ID[U]);</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> Cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">	W[Cur] = Cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;color.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;color.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	N = <span class="built_in">Read</span>(), M = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) Temp[i] = <span class="built_in">Read</span>() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) <span class="built_in">AddEdge</span>(Temp[i], i, <span class="built_in">Read</span>());</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		Opt = <span class="built_in">Read</span>(), U = <span class="built_in">Read</span>() + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (Opt == <span class="number">1</span> &amp;&amp; !Vis[U]) <span class="built_in">UpDate</span>(U), A += Len[U], Q++, Vis[U] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里要注意一下，因为一个点只能被染色一次，所以如果已经是黑色了就不能在操作了</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Opt == <span class="number">2</span>) <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, A + Q * Len[U] - <span class="number">2</span> * <span class="built_in">Query</span>(U));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T3-圈地游戏"><a href="#T3-圈地游戏" class="headerlink" title="T3 圈地游戏"></a>T3 圈地游戏</h1><p>这，我就懒得描述了</p>
<p>考场上没有思路，怎么设计状态？如何进行转移？</p>
<p>啥都没想到，都不会。。。</p>
<p><strong>BUT</strong></p>
<p><del>赛后诸葛</del>。。。</p>
<p>我这里没有部分分做法</p>
<h2 id="100-分做法-2"><a href="#100-分做法-2" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>状态设计$f(x,y,state_t, state_b)$，表示当前位置为$(x,y)$，在路径内部的宝箱状态为$state_t$，路径障碍状态为$state_b$</p>
<p>规定射线垂直$y$轴，没有斜率方便表示</p>
<p>那么判定依据如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((New.X == Tx[i] - <span class="number">1</span> &amp;&amp; Now.X == Tx[i]) || (New.X == Tx[i] &amp;&amp; Now.X == Tx[i] - <span class="number">1</span>)) </span><br><span class="line">    New.St ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>就是没经过这条射线一次，就对这个宝箱/障碍进行一次亦或操作，因为异或操作有一个性质，相信大家都明白，就不细说的</p>
<p>这个就很好的满足了经过奇数条边，那么就在图形内，偶数条边就在图形外的条件</p>
<p>那么最难的部分就结束了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> My[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> N, M, Sx, Sy;<span class="comment">//起点坐标</span></span><br><span class="line"><span class="type">int</span> Tx[<span class="number">10</span>], Ty[<span class="number">10</span>], TVal[<span class="number">10</span>], Tcnt;<span class="comment">//宝藏坐标、价值、计数</span></span><br><span class="line"><span class="type">int</span> Bx[<span class="number">10</span>], By[<span class="number">10</span>], Bcnt;<span class="comment">//陷阱坐标、计数</span></span><br><span class="line"><span class="type">int</span> F[<span class="number">21</span>][<span class="number">21</span>][<span class="number">256</span>][<span class="number">256</span>], Sum[<span class="number">256</span>], Ans;</span><br><span class="line"><span class="type">char</span> Map[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> X, Y, St, Sb;</span><br><span class="line">    <span class="built_in">Node</span> () &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> X, <span class="type">int</span> Y, <span class="type">int</span> St, <span class="type">int</span>  Sb) : <span class="built_in">X</span>(X), <span class="built_in">Y</span>(Y), <span class="built_in">St</span>(St), <span class="built_in">Sb</span>(Sb) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue &lt;Node&gt; Q;</span><br><span class="line">    F[Sx][Sy][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">Node</span>(Sx, Sy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node Now = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; <span class="number">4</span>; ++S)</span><br><span class="line">        &#123;</span><br><span class="line">            Node New = Now;</span><br><span class="line">            New.X += Mx[S];</span><br><span class="line">            New.Y += My[S];<span class="comment">//在图上随机游走</span></span><br><span class="line">            <span class="keyword">if</span> (Map[New.X][New.Y] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; Map[New.X][New.Y] != <span class="string">&#x27;S&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= Ty[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Tx[i] - <span class="number">1</span> &amp;&amp; Now.X == Tx[i]) || (New.X == Tx[i] &amp;&amp; Now.X == Tx[i] - <span class="number">1</span>))</span><br><span class="line">                    New.St ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录宝箱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Bcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= By[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Bx[i] - <span class="number">1</span> &amp;&amp; Now.X == Bx[i]) || (New.X == Bx[i] &amp;&amp; Now.X == Bx[i] - <span class="number">1</span>)) </span><br><span class="line">                    New.Sb ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录陷阱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (F[New.X][New.Y][New.St][New.Sb] &lt;= F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            F[New.X][New.Y][New.St][New.Sb] = F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新答案，我们要求的是周长最小</span></span><br><span class="line">            Q.<span class="built_in">push</span> (New);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Tcnt; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) Sum[i] += TVal[j];<span class="comment">//统计每种情况下宝箱权值之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        Ans = <span class="built_in">max</span>(Ans, Sum[i] - F[Sx][Sy][i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, Map[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Map[i][j] == <span class="string">&#x27;S&#x27;</span>) Sx = i, Sy = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; Map[i][j] &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">                Tx[Map[i][j] - <span class="string">&#x27;0&#x27;</span>] = i, Ty[Map[i][j] - <span class="string">&#x27;0&#x27;</span>] = j, Tcnt++;<span class="comment">//记录宝箱的位置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] == <span class="string">&#x27;B&#x27;</span>) </span><br><span class="line">                Bx[++Bcnt] = i, By[Bcnt] = j;<span class="comment">//记录陷阱的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, TVal + i);</span><br><span class="line">    <span class="built_in">memset</span> (F, <span class="number">0x5f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确实是非常好的一道状压$\text{Dp}$</p>
<p>这道题大家就栽在不知到如何用二进制表示宝箱、陷阱的状态</p>
<p>虽然题目对于路径内外有十分详细的描述，但是没有做过的话，还是不容易想到这种表示方法</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>数据结构</tag>
        <tag>考试</tag>
        <tag>状压</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200825</title>
    <url>/AlanTuringLi/2020/08/25/T20200825/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-运动-move"><a href="#T1-运动-move" class="headerlink" title="T1 运动(move)"></a>T1 运动(move)</h1><p>给你两个字符串，其中第二个字符串为环状字符串，问将第二个字符串转几次（初始状态就是$0$次）可以使$A, B$串有最大匹配</p>
<h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>暴力。。。</p>
<h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>$KMP$求$A$串在$B$串中的最大匹配，就是个$O(n)$的了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> A[Maxn], B[Maxn];</span><br><span class="line"><span class="type">int</span> N, Fail[Maxn], Len, Pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s %s&quot;</span>, A + <span class="number">1</span>, B + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = Fail[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; A[j + <span class="number">1</span>] != A[i]) j = Fail[j];</span><br><span class="line">		<span class="keyword">if</span> (A[j + <span class="number">1</span>] == A[i]) Fail[i] = j + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span> (B + <span class="number">1</span>, B + N + <span class="number">1</span>, B + N + <span class="number">1</span>);</span><br><span class="line">	N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">0</span>); i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; A[j + <span class="number">1</span>] != B[i]) j = Fail[j];</span><br><span class="line">		<span class="keyword">if</span> (A[j + <span class="number">1</span>] == B[i]) ++j;</span><br><span class="line">        <span class="comment">//j表示当前匹配长度</span></span><br><span class="line">		<span class="keyword">if</span> (j &gt; Len) Pos = i - j + <span class="number">1</span>, Len = j;<span class="comment">//Pos就是当前匹配的起点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Pos - <span class="number">1</span>);<span class="comment">//就完了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-烹饪-cook"><a href="#T2-烹饪-cook" class="headerlink" title="T2 烹饪(cook)"></a>T2 烹饪(cook)</h1><p>给你一串数字$1\sim n$, 然后有$m$个条件形如$a, b$表示$a$在$b$前出现</p>
<p>求问满足这$m$个条件且小的数字尽量靠前</p>
<p><del>暴力挂了，直接上100分做法</del></p>
<h2 id="100分做法-1"><a href="#100分做法-1" class="headerlink" title="100分做法"></a>100分做法</h2><p>倒叙、反向建边的拓扑</p>
<p>我们然大的数尽可能靠后，这是为啥呢</p>
<p>自己造几组数据，你就会发现这貌似是正确的？</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> T, N, M, Cur, Tot, X, Y;</span><br><span class="line"><span class="type">int</span> D[Maxn], Ans[Maxn];</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxn], Next[Maxn];</span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X =(X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">		Cur = Tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="built_in">sizeof</span>(Head));</span><br><span class="line">		<span class="built_in">memset</span> (D, <span class="number">0</span>, <span class="built_in">sizeof</span>(D));</span><br><span class="line">		<span class="keyword">while</span> (M--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;X, &amp;Y);</span><br><span class="line">			<span class="built_in">AddEge</span>(Y, X);</span><br><span class="line">			D[X]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">if</span> (!D[i]) Q.<span class="built_in">push</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> X = Q.<span class="built_in">top</span>();</span><br><span class="line">			Q.<span class="built_in">pop</span>();</span><br><span class="line">			Ans[++Tot] = X;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">			&#123;</span><br><span class="line">				D[E[i]]--;</span><br><span class="line">				<span class="keyword">if</span> (!D[E[i]]) Q.<span class="built_in">push</span>(E[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Tot == N) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = N; i; --i) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, Ans[i]);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-方块-block"><a href="#T3-方块-block" class="headerlink" title="T3 方块(block)"></a>T3 方块(block)</h1><p>鸽了鸽了，不会做。。。</p>
<p>先贴个$std$，会者自会</p>
<p><del>这不是我写的</del></p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hash(a,b,c) Ha[a][b][c]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>,a[N],Min[<span class="number">1</span>&lt;&lt;<span class="number">12</span>],ID[<span class="number">1</span>&lt;&lt;<span class="number">12</span>],Ha[<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span>&#123;</span><br><span class="line">    <span class="type">int</span> v[N][N];</span><br><span class="line">    <span class="built_in">Mat</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Mat</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">            v[i][i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="built_in">M</span>(<span class="number">0</span>);</span><br><span class="line">Mat <span class="keyword">operator</span> * (Mat A,Mat B)&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">C</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)</span><br><span class="line">                C.v[i][j]=(<span class="number">1LL</span>*A.v[i][k]*B.v[k][j]+C.v[i][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x,LL y)</span></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=x*x)</span><br><span class="line">        <span class="keyword">if</span> (y&amp;<span class="number">1LL</span>)</span><br><span class="line">            ans=ans*x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapD</span><span class="params">(<span class="type">int</span> &amp;v,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (((v&gt;&gt;i)^(v&gt;&gt;j))&amp;<span class="number">1</span>)</span><br><span class="line">        v^=(<span class="number">1</span>&lt;&lt;i)^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkWB</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">if</span> (s&gt;&gt;<span class="built_in">Hash</span>(i,j,k)&amp;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> ((i+j+k)&amp;<span class="number">1</span>)</span><br><span class="line">                        ans++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ans--;</span><br><span class="line">    <span class="keyword">return</span> ans==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">        <span class="type">int</span> v=s;</span><br><span class="line">        <span class="keyword">if</span> (t&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                    <span class="built_in">SwapD</span>(v,<span class="built_in">Hash</span>(<span class="number">1</span>,j,k),<span class="built_in">Hash</span>(<span class="number">2</span>,j,k));</span><br><span class="line">        <span class="keyword">if</span> (t&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">                    <span class="built_in">SwapD</span>(v,<span class="built_in">Hash</span>(i,j,<span class="number">1</span>),<span class="built_in">Hash</span>(i,j,<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++,res=<span class="built_in">min</span>(res,v))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">SwapD</span>(v,<span class="built_in">Hash</span>(<span class="number">1</span>,<span class="number">1</span>,i),<span class="built_in">Hash</span>(<span class="number">1</span>,<span class="number">2</span>,i));</span><br><span class="line">                <span class="built_in">SwapD</span>(v,<span class="built_in">Hash</span>(<span class="number">1</span>,<span class="number">2</span>,i),<span class="built_in">Hash</span>(<span class="number">2</span>,<span class="number">2</span>,i));</span><br><span class="line">                <span class="built_in">SwapD</span>(v,<span class="built_in">Hash</span>(<span class="number">2</span>,<span class="number">2</span>,i),<span class="built_in">Hash</span>(<span class="number">2</span>,<span class="number">1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">6</span>]=&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>&#125;,_x[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> dy[<span class="number">6</span>]=&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,_y[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> dz[<span class="number">6</span>]=&#123; <span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,_z[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetXYZ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">if</span> ((i+j+k)&amp;<span class="number">1</span>)</span><br><span class="line">                    cnt++,_x[cnt]=i,_y[cnt]=j,_z[cnt]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetM</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> v,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t&gt;<span class="number">6</span>)&#123;</span><br><span class="line">        M.v[S][ID[Min[v]]]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GetM</span>(S,v,t+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> x=_x[t],y=_y[t],z=_z[t],xx,yy,zz;</span><br><span class="line">    <span class="keyword">if</span> (v&gt;&gt;<span class="built_in">Hash</span>(x,y,z)&amp;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        xx=x+dx[i],yy=y+dy[i],zz=z+dz[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span>&lt;=xx&amp;&amp;xx&lt;=<span class="number">2</span>&amp;&amp;<span class="number">1</span>&lt;=yy&amp;&amp;yy&lt;=<span class="number">2</span>&amp;&amp;<span class="number">1</span>&lt;=zz&amp;&amp;zz&lt;=<span class="number">3</span>)&amp;&amp;(~v&gt;&gt;<span class="built_in">Hash</span>(xx,yy,zz)&amp;<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">GetM</span>(S,v^(<span class="number">1</span>&lt;&lt;<span class="built_in">Hash</span>(x,y,z))^(<span class="number">1</span>&lt;&lt;<span class="built_in">Hash</span>(xx,yy,zz)),t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;block.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;block.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> sz=<span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                Ha[i][j][k]=(i<span class="number">-1</span>)*<span class="number">6</span>+(j<span class="number">-1</span>)*<span class="number">3</span>+k<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkWB</span>(i))</span><br><span class="line">            <span class="keyword">if</span> ((Min[i]=<span class="built_in">calc</span>(i))==i)</span><br><span class="line">                a[++t]=i,ID[i]=t;</span><br><span class="line">    <span class="built_in">GetXYZ</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="built_in">GetM</span>(i,a[i]^(sz<span class="number">-1</span>),<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    M=<span class="built_in">Pow</span>(M,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,M.v[ID[Min[sz<span class="number">-1</span>]]][ID[Min[sz<span class="number">-1</span>]]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>鸽~</tag>
        <tag>KMP</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200826</title>
    <url>/AlanTuringLi/2020/08/26/T20200826/</url>
    <content><![CDATA[<h1 id="T1-砍树-tree"><a href="#T1-砍树-tree" class="headerlink" title="T1 砍树(tree)"></a>T1 砍树(tree)</h1><p>树型$Dp$吧，水水过</p>
<p>注意开$long\;long$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll N, X, U, V, Cur;</span><br><span class="line">ll Sum[Maxn], Ans[Maxn];</span><br><span class="line"><span class="type">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ans[U] = Sum[U];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == F) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(E[i], U);</span><br><span class="line">		Sum[U] += Ans[E[i]];<span class="comment">//Sum表示以U为根的最大答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	Ans[U] = <span class="built_in">max</span>(-X, Sum[U]);<span class="comment">//如果-X比Sum[U]大，这个节点就可以直接砍掉了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;N, &amp;X);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, Sum + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;U, &amp;V);</span><br><span class="line">		<span class="built_in">AddEdge</span>(U, V), <span class="built_in">AddEdge</span>(V, U); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T2-异或-xor"><a href="#T2-异或-xor" class="headerlink" title="T2 异或(xor)"></a>T2 异或(xor)</h1><p>求在$1\sim n$范围内满足方程$x\otimes2x=3x$的解的个数</p>
<h2 id="做法1"><a href="#做法1" class="headerlink" title="做法1"></a>做法1</h2><p>我们发现当$x\;\&amp;\;2x=0$时，$x$就是方程的一个解</p>
<p>简言之，就是在$x\;\&amp;\;(x&lt;&lt;1)=0$时， $x$就是方程的一个解</p>
<p>这就非常显然了吧</p>
<p>我们可以统计二进制下$1\sim n$中，任意两个$1$都不相邻的树的个数</p>
<p>用$f(cnt,up,last)$表示在第$cnt$位，是否到达峰值，上一位为$last$的方案数</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll T, N, F[<span class="number">70</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> Num[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">DFS</span><span class="params">(<span class="type">int</span> Cnt, <span class="type">int</span> Up, <span class="type">bool</span> Jud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (F[Cnt][Up][Jud] != <span class="number">-1</span>) <span class="keyword">return</span> F[Cnt][Up][Jud];</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span>, Lim</span>;</span><br><span class="line">	<span class="keyword">if</span> (Jud) Lim = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Up) Lim = Num[Cnt];</span><br><span class="line">	<span class="keyword">else</span> Lim = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Lim; ++i) Ans += <span class="built_in">DFS</span>(Cnt - <span class="number">1</span>, Up &amp;&amp; i == Num[Cnt], i == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> F[Cnt][Up][Jud] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">		ll Temp = N, <span class="built_in">Cnt</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (Temp) Num[++Cnt] = Temp &amp; <span class="number">1</span>, Temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">DFS</span>(Cnt, <span class="number">1</span>, <span class="number">0</span>) - <span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h2><p>先打个表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">1</span></span><br><span class="line"><span class="number">2</span>: <span class="number">2</span></span><br><span class="line"><span class="number">4</span>: <span class="number">3</span></span><br><span class="line"><span class="number">8</span>: <span class="number">5</span></span><br><span class="line"><span class="number">16</span>: <span class="number">8</span></span><br><span class="line"><span class="number">32</span>: <span class="number">13</span></span><br><span class="line"><span class="number">64</span>: <span class="number">21</span></span><br><span class="line"><span class="number">128</span>: <span class="number">34</span></span><br><span class="line"><span class="number">256</span>: <span class="number">55</span></span><br><span class="line"><span class="number">512</span>: <span class="number">89</span></span><br><span class="line"><span class="number">1024</span>: <span class="number">144</span></span><br></pre></td></tr></table></figure>
<p>然后发先在$2^k$范围内的数确实挺像斐波那契数列的</p>
<p>那么先预处理出最高位为$1$的所有数的答案，然后去加上下一个$1$的位置的答案</p>
<p>如果某两个$1$相邻，那么先加上我们得到的答案然后$-1$，$break$掉， 就可以了</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll T, N, Feb[<span class="number">70</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">65</span>; ++i) Feb[i] = Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Res</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> ((N &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Res += Feb[i];</span><br><span class="line">                <span class="keyword">if</span> ((N &gt;&gt; (i + <span class="number">1</span>)) &amp; <span class="number">1</span>)&#123;--Res; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是$SYK$巨佬一直在讲的，打表找规律是个好方法的体现啊</p>
<h1 id="T3-等式-equ"><a href="#T3-等式-equ" class="headerlink" title="T3  等式(equ)"></a>T3  等式(equ)</h1><p>先给出两个式子：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_ix_i=S\\
\sum_{i=1}^nb_ix_i=T</script><p>求${x}$, $x$为非负实数，使其在满足上述两个式子的情况下使$\sum_{i=1}^nc_ix_i$最大</p>
<p>求$\sum_{i=1}^nc_ix_i$， 输出五位浮点数，若无解，输出$\text{“impossible”}$</p>
<h2 id="15分做法"><a href="#15分做法" class="headerlink" title="15分做法"></a>15分做法</h2><p>那就是对$n=1$或者$n=2$的数据直接解方程</p>
<p><del>考场上的丢人代码</del></p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, S, T;</span><br><span class="line"><span class="type">double</span> Ans;</span><br><span class="line"><span class="type">int</span> A[<span class="number">5</span>], B[<span class="number">5</span>], C[<span class="number">5</span>];</span><br><span class="line"><span class="type">double</span> X[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">N1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S * B[<span class="number">1</span>] != T * A[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	Ans = <span class="built_in">double</span>(S) / <span class="built_in">double</span>(A[<span class="number">1</span>]) * <span class="built_in">double</span> (C[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">N2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> D = A[<span class="number">2</span>] * B[<span class="number">1</span>], E = B[<span class="number">2</span>] * A[<span class="number">1</span>], F = S * B[<span class="number">1</span>], G = T * A[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> ((D - E == <span class="number">0</span>) &amp;&amp; (G - G != <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	X[<span class="number">2</span>] = <span class="built_in">double</span>(F - G) / <span class="built_in">double</span>(D - E);</span><br><span class="line">	X[<span class="number">1</span>] = (<span class="built_in">double</span> (S) - A[<span class="number">2</span>] * X[<span class="number">2</span>]) / A[<span class="number">1</span>];</span><br><span class="line">	Ans = C[<span class="number">1</span>] * X[<span class="number">1</span>] + C[<span class="number">2</span>] * X[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span> (X[<span class="number">1</span>] &lt; <span class="number">0</span> || X[<span class="number">2</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, A + i, B + i, C + i);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;S, &amp;T);</span><br><span class="line">		<span class="type">bool</span> Flag;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">1</span>) Flag = <span class="built_in">N1</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) Flag = <span class="built_in">N2</span>();</span><br><span class="line">		<span class="keyword">if</span> (Flag) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%.5lf\n&quot;</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>根据$XZC$巨佬的结论，答案只与其中最多两个$x_i$的值有关，那么剩下的就是一个暴力了</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL int </span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> f ?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	LL x,y,c;</span><br><span class="line">	<span class="built_in">Point</span>() &#123;x=<span class="number">0</span>;y=<span class="number">0</span>;c=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> _x,<span class="type">int</span> _y,<span class="type">int</span> _c = <span class="number">0</span>) &#123;x=_x;y=_y;c=_c;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (<span class="type">const</span> Point a)<span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(a.x+x,a.y+y);&#125;</span><br><span class="line">&#125;v[N],P;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(Point a,Point b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">LL n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point a,Point b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.c / <span class="number">1.0</span> * <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y) &gt; b.c / <span class="number">1.0</span> * <span class="built_in">sqrt</span>(b.x * b.x + b.y * b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> limit1 = <span class="number">1e18</span>,limit2 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) v[i].x = <span class="built_in">read</span>(), v[i].y = <span class="built_in">read</span>(), v[i].c = <span class="built_in">read</span>();</span><br><span class="line">	v[<span class="number">0</span>].x = <span class="number">0</span>, v[<span class="number">0</span>].y = <span class="number">0</span>, v[<span class="number">0</span>].c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		limit1 = <span class="built_in">min</span>(limit1, <span class="built_in">atan2</span>(v[i].y, v[i].x));</span><br><span class="line">		limit2 = <span class="built_in">max</span>(limit2, <span class="built_in">atan2</span>(v[i].y, v[i].x));</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> s = <span class="built_in">read</span>(), t = <span class="built_in">read</span>();</span><br><span class="line">		P.x = s;P.y = t;P.c = <span class="number">0</span>;</span><br><span class="line">		<span class="type">double</span> K = <span class="built_in">atan2</span>(P.y,P.x);</span><br><span class="line">		<span class="keyword">if</span>(K &lt; limit1 || K &gt; limit2) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(P.x * v[i].y == v[i].x * P.y)&#123;</span><br><span class="line">					ans = <span class="built_in">max</span>((<span class="type">double</span>)P.x / v[i].x * v[i].c, ans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="type">double</span> X2 = <span class="number">1.0</span> * <span class="built_in">cross</span>(v[i],P) / (<span class="type">double</span>)<span class="built_in">cross</span>(v[i], v[j]);</span><br><span class="line">					<span class="type">double</span> X1 = (<span class="number">1.0</span> * P.x - X2 * v[j].x) / v[i].x;</span><br><span class="line">					<span class="keyword">if</span>(X1 &lt;= <span class="number">0.0</span> || X2 &lt;= <span class="number">0.0</span>) <span class="keyword">continue</span>;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, X2 * v[j].c + X1 * v[i].c);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h2><p>对偶线性规划</p>
<p>平面半交</p>
<p>二分答案</p>
<p>鸽他！！</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树型Dp</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>数位Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200827</title>
    <url>/AlanTuringLi/2020/08/27/T20200827/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-achen"><a href="#T1-achen" class="headerlink" title="T1 achen"></a>T1 achen</h1><p>就是考虑目标节点可能从那些地方转移过来，然后就得到了$f[i]=f[i-1]+f[i-3]$</p>
<p>然后基本上就结束了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll Feb[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">ll T, N, A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i) Feb[i] %= Mod, Feb[i + <span class="number">1</span>] += Feb[i], Feb[i + <span class="number">3</span>] += Feb[i];</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		N = <span class="built_in">Read</span>(), A = <span class="built_in">Read</span>(), B = <span class="built_in">Read</span>();</span><br><span class="line">		<span class="keyword">if</span> (A &gt; B) <span class="built_in">swap</span>(A, B);</span><br><span class="line">		<span class="keyword">if</span> (A &gt; <span class="number">1</span>) A += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; N) B -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; A) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Feb[B - A]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T2-Tree"><a href="#T2-Tree" class="headerlink" title="T2 Tree"></a>T2 Tree</h1><blockquote>
<p>  考场思路：</p>
<p>  对于$Subtas1$：暴力换根</p>
<p>  对于$Subtas2$：树的直径</p>
<p>  非常好，全写挂了，又因为是$Subtask$， 就只有零分</p>
</blockquote>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line"><span class="type">int</span> Col[Maxn], Fa[Maxn][<span class="number">20</span>], Dep[Maxn], Max[Maxn];</span><br><span class="line"><span class="type">int</span> In[Maxn], Se[Maxn], Out[Maxn], Tim;</span><br><span class="line"><span class="type">bool</span> Vis1[Maxn], Vis2[Maxn];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; V[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">char</span> O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	In[U] = ++Tim, Max[U] = Dep[U] = Dep[Fa[U][<span class="number">0</span>] = F] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i]) </span><br><span class="line">		<span class="keyword">if</span> (E[i] != F) <span class="built_in">DFS</span>(E[i], U);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (E[i] != F)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Max[E[i]] &gt;= Max[U]) Se[U] = Max[U], Max[U] = Max[E[i]];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Max[E[i]] &gt;= Se[U]) Se[U] = Max[E[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	Out[U] = Tim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F_LCA</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Dep[U] &lt; Dep[V]) <span class="built_in">swap</span>(U, V);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">		<span class="keyword">if</span> (((Dep[U] - Dep[V]) &gt;&gt; i) &amp; <span class="number">1</span>) U = Fa[U][i];</span><br><span class="line">	<span class="keyword">if</span> (U == V) <span class="keyword">return</span> U;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (Fa[U][i] != Fa[V][i]) U = Fa[U][i], V = Fa[V][i];</span><br><span class="line">	<span class="keyword">return</span> Fa[U][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span></span>&#123;<span class="keyword">return</span> In[X] &lt; In[Y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[Maxn], L, R, Cnt, Ans;</span><br><span class="line"><span class="type">int</span> Ct[Maxn], Rit[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_2</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (!Vis1[E[i]]) Ans = <span class="built_in">max</span>(Ans, Max[E[i]] - Dep[U] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Vis2[U]) Ans = <span class="built_in">max</span>(Ans, Dep[U] + Val);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (E[i] != Fa[U][<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Max[E[i]] == Max[U]) <span class="built_in">DFS_2</span>(E[i], <span class="built_in">max</span>(Val, Se[U] - <span class="number">2</span> * Dep[U] + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">DFS_2</span>(E[i], <span class="built_in">max</span>(Val, Max[U] - <span class="number">2</span> * Dep[U] + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> N = <span class="built_in">Read</span>(), M = <span class="built_in">Read</span>(), X, Y, LCA;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) V[Col[i] = <span class="built_in">Read</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		X = <span class="built_in">Read</span>(), Y = <span class="built_in">Read</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span> (X, Y), <span class="built_in">AddEdge</span>(Y, X);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">			Fa[j][i] = Fa[Fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		X = V[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; V[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">			LCA = <span class="built_in">F_LCA</span>(V[i][j], V[i][j - <span class="number">1</span>]), X = Dep[X] &lt; Dep[LCA] ? X : LCA;</span><br><span class="line">		<span class="keyword">while</span> (X &amp;&amp; !Vis1[X]) Vis1[X] = <span class="number">1</span>, X = Fa[X][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) A[In[i]] = Col[i];</span><br><span class="line">	<span class="keyword">for</span> (L = <span class="number">1</span>; L &lt;= N; ++L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Cnt != M &amp;&amp; R &lt;= N)</span><br><span class="line">		&#123;</span><br><span class="line">			++R;</span><br><span class="line">			<span class="keyword">if</span> (!Ct[A[R]]) ++Cnt;</span><br><span class="line">			++Ct[A[R]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Cnt != M &amp;&amp; R == N)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= N; ++i) Rit[i] = N + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Rit[L] = R, --Ct[A[L]];</span><br><span class="line">		<span class="keyword">if</span> (!Ct[A[L]]) --Cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">if</span> (Out[i] &gt;= Rit[In[i]]) Vis2[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">DFS_2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-easy"><a href="#T3-easy" class="headerlink" title="T3 easy"></a>T3 easy</h1><p>没看出来这道题有多么$easy$， <del>mdzz</del></p>
<blockquote>
<p>  考场$n^2$暴力：枚举$l,\;r$， 用$map$维护乱搞一通，检验连续的数的个数和区间长度的关系，就完了</p>
</blockquote>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Val first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pos second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LS (X &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RS (X &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Node(X, Y) make_pair(X, Y)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, Last[Maxn], Now[Maxn];</span><br><span class="line"><span class="type">int</span> A[Maxn], B[Maxn];</span><br><span class="line">ll Ans;</span><br><span class="line"><span class="type">int</span> Min[Maxn &lt;&lt; <span class="number">2</span>], Cnt[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushUp</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Min[X] = <span class="built_in">min</span>(Min[LS], Min[RS]), Cnt[X] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Min[X] == Min[LS]) Cnt[X] += Cnt[LS];</span><br><span class="line">	<span class="keyword">if</span> (Min[X] == Min[RS]) Cnt[X] += Cnt[RS];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Min[X] += V;</span><br><span class="line">	Tag[X] += V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">F</span>(LS, Tag[X]), <span class="built_in">F</span>(RS, Tag[X]);</span><br><span class="line">	Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R)</span><br><span class="line">	&#123;</span><br><span class="line">		Min[X] = <span class="number">0</span>, Cnt[X] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Build</span>(L, Mid, LS);</span><br><span class="line">	<span class="built_in">Build</span>(Mid + <span class="number">1</span>, R, RS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> V, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">F</span>(X, V) ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PushDown</span>(X);</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) <span class="built_in">UpDate</span> (L, Mid, Tl, Tr, V, LS);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) <span class="built_in">UpDate</span> (Mid + <span class="number">1</span>, R, Tl, Tr, V, RS);</span><br><span class="line">	<span class="built_in">PushUp</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> Tl, <span class="type">int</span> Tr, <span class="type">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Min[X] == <span class="number">-1</span>) <span class="keyword">return</span> Cnt[X];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="built_in">PushDown</span>(X);</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) Ans += <span class="built_in">Query</span> (L, Mid, Tl, Tr, LS);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) Ans += <span class="built_in">Query</span> (Mid + <span class="number">1</span>, R, Tl, Tr, RS);</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack &lt;pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Gtr, Les;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, A + i), B[i] = A[i];</span><br><span class="line">	<span class="built_in">sort</span> (B + <span class="number">1</span>, B + N + <span class="number">1</span>);</span><br><span class="line">	M = <span class="built_in">unique</span> (B + <span class="number">1</span>, B + N + <span class="number">1</span>) - B - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> Temp = <span class="built_in">lower_bound</span>(B + <span class="number">1</span>, B + M + <span class="number">1</span>, A[i]) - B;</span><br><span class="line">		Last[i] = Now[Temp], Now[Temp] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">1</span>, N);</span><br><span class="line">	Gtr.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>)), Les.<span class="built_in">push</span>(<span class="built_in">Node</span>(Mod, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Les.<span class="built_in">size</span>() &amp;&amp; Les.<span class="built_in">top</span>().Val &lt;= A[i])</span><br><span class="line">		&#123;</span><br><span class="line">			pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Top = Les.<span class="built_in">top</span>(); Les.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="built_in">UpDate</span>(<span class="number">1</span>, N, Les.<span class="built_in">top</span>().Pos + <span class="number">1</span>, Top.Pos, A[i] - Top.Val);</span><br><span class="line">		&#125;</span><br><span class="line">		Les.<span class="built_in">push</span>(<span class="built_in">Node</span>(A[i], i));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Gtr.<span class="built_in">size</span>() &amp;&amp; Gtr.<span class="built_in">top</span>().Val &gt;= A[i])</span><br><span class="line">		&#123;</span><br><span class="line">			pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Top = Gtr.<span class="built_in">top</span>(); Gtr.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="built_in">UpDate</span>(<span class="number">1</span>, N, Gtr.<span class="built_in">top</span>().Pos + <span class="number">1</span>, Top.Pos, Top.Val - A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		Gtr.<span class="built_in">push</span>(<span class="built_in">Node</span>(A[i], i));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UpDate</span>(<span class="number">1</span>, N, Last[i] + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">		Ans += <span class="built_in">Query</span>(<span class="number">1</span>, N, <span class="number">1</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>因为人懒，今天就先放一个官方题解吧</del></p>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>Dp优化</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200828</title>
    <url>/AlanTuringLi/2020/08/29/T20200828/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-doubt"><a href="#T1-doubt" class="headerlink" title="T1 doubt"></a>T1 doubt</h1><p>贪心，让亦或最小的，就是二进制下最相近的亦或在一起</p>
<p>用$01$字典树贪心乱搞</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">100</span>,M = (<span class="number">2e5</span>+<span class="number">100</span>) * <span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> rt[<span class="number">2</span>],ch[M][<span class="number">2</span>],cnt[M],si;</span><br><span class="line"><span class="type">int</span> A[N],B[N],n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> t,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> i = (x&gt;&gt;t)&amp;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!ch[a][i]) ch[a][i] = ++si;</span><br><span class="line">	cnt[ch[a][i]]++;</span><br><span class="line">	<span class="built_in">insert</span>(ch[a][i],t<span class="number">-1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> x,<span class="type">int</span> t,<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &lt; <span class="number">0</span>) &#123;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= num;i++) Ans.<span class="built_in">push_back</span>(x);<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">0</span>]] &amp;&amp; cnt[ch[b][<span class="number">0</span>]])&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="built_in">min</span>(cnt[ch[a][<span class="number">0</span>]],cnt[ch[b][<span class="number">0</span>]]);</span><br><span class="line">		sum = <span class="built_in">min</span>(num,sum);</span><br><span class="line">		<span class="built_in">print</span>(ch[a][<span class="number">0</span>],ch[b][<span class="number">0</span>],x,t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">0</span>]] -= sum;cnt[ch[b][<span class="number">0</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">1</span>]] &amp;&amp; cnt[ch[b][<span class="number">1</span>]])&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="built_in">min</span>(cnt[ch[a][<span class="number">1</span>]],cnt[ch[b][<span class="number">1</span>]]);</span><br><span class="line">		sum = <span class="built_in">min</span>(sum,num);</span><br><span class="line">		<span class="built_in">print</span>(ch[a][<span class="number">1</span>],ch[b][<span class="number">1</span>],x,t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">1</span>]] -= sum;cnt[ch[b][<span class="number">1</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">1</span>]] &amp;&amp; cnt[ch[b][<span class="number">0</span>]])&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="built_in">min</span>(cnt[ch[a][<span class="number">1</span>]],cnt[ch[b][<span class="number">0</span>]]);</span><br><span class="line">		sum = <span class="built_in">min</span>(sum,num);</span><br><span class="line">		<span class="built_in">print</span>(ch[a][<span class="number">1</span>],ch[b][<span class="number">0</span>],x+(<span class="number">1</span>&lt;&lt;t),t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">1</span>]] -= sum;cnt[ch[b][<span class="number">0</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">0</span>]] &amp;&amp; cnt[ch[b][<span class="number">1</span>]])&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="built_in">min</span>(cnt[ch[a][<span class="number">0</span>]],cnt[ch[b][<span class="number">1</span>]]);</span><br><span class="line">		sum = <span class="built_in">min</span>(sum,num);</span><br><span class="line">		<span class="built_in">print</span>(ch[a][<span class="number">0</span>],ch[b][<span class="number">1</span>],x+(<span class="number">1</span>&lt;&lt;t),t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">0</span>]] -= sum;cnt[ch[b][<span class="number">1</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>();rt[<span class="number">0</span>] = ++si;rt[<span class="number">1</span>] = ++si;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = <span class="built_in">read</span>(),<span class="built_in">insert</span>(rt[<span class="number">0</span>],<span class="number">30</span>,A[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = <span class="built_in">read</span>(),<span class="built_in">insert</span>(rt[<span class="number">1</span>],<span class="number">30</span>,B[i]);</span><br><span class="line">	<span class="built_in">print</span>(rt[<span class="number">0</span>],rt[<span class="number">1</span>],<span class="number">0</span>,<span class="number">30</span>,n);</span><br><span class="line">	<span class="built_in">sort</span>(Ans.<span class="built_in">begin</span>(),Ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; Ans.<span class="built_in">size</span>();i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-block"><a href="#T2-block" class="headerlink" title="T2 block"></a>T2 block</h1><p>日常鸽一题</p>
<p>状压Dp</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = (<span class="type">int</span>) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, h[MAXN], sorted[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1LL</span> * res * a % MOD;</span><br><span class="line">        a = <span class="number">1LL</span> * a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> added[MAXN];</span><br><span class="line"><span class="type">int</span> R_L[MAXN], L_R[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> last_h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> dp_l[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">int</span> dp_r[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">int</span> res[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ll = <span class="number">0</span>; ll &lt; <span class="number">2</span>; ++ll)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> rr = <span class="number">0</span>; rr &lt; <span class="number">2</span>; ++rr)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sl = <span class="number">0</span>; sl &lt; <span class="number">2</span>; ++sl)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sr = <span class="number">0</span>; sr &lt; <span class="number">2</span>; ++sr) &#123;</span><br><span class="line">            <span class="type">int</span> t = sl | sr | (ll == rr);</span><br><span class="line">            tmp[l][r][t] = (tmp[l][r][t] + <span class="number">1LL</span> * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(res, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> h_now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_h[L] == h_now) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> t = (last_h[L] - h_now) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">        tmp[l][r][<span class="number">1</span>] = dp[L][l ^ t][r ^ t][<span class="number">1</span>];</span><br><span class="line">        tmp[l][r][<span class="number">0</span>] = <span class="number">1LL</span> * (dp[L][l][r][<span class="number">0</span>] + dp[L][l ^ <span class="number">1</span>][r ^ <span class="number">1</span>][<span class="number">0</span>]) * <span class="built_in">qpow</span>(<span class="number">2</span>, last_h[L] - h_now - <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dp[L], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;block.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;block.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, h + i);</span><br><span class="line">        sorted[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(sorted + <span class="number">1</span>, sorted + n + <span class="number">1</span>, [&amp;] (<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> h[a] &gt; h[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> j = sorted[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> L = j, R = j;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        tmp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = tmp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (R_L[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> l = R_L[j - <span class="number">1</span>], r = j - <span class="number">1</span>;</span><br><span class="line">            L_R[l] = R_L[r] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">calc</span>(l, h[j]);</span><br><span class="line">            <span class="built_in">merge</span>(dp[l], tmp, tmp);</span><br><span class="line">            L = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L_R[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> l = j + <span class="number">1</span>, r = L_R[j + <span class="number">1</span>];</span><br><span class="line">            L_R[l] = R_L[r] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">calc</span>(l, h[j]);</span><br><span class="line">            <span class="built_in">merge</span>(tmp, dp[l], tmp);</span><br><span class="line">            R = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        added[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp[L], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        L_R[L] = R;</span><br><span class="line">        R_L[R] = L;</span><br><span class="line">        last_h[L] = h[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h[sorted[n]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> t = (h[sorted[n]] - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">            tmp[l][r][<span class="number">1</span>] = dp[<span class="number">1</span>][l ^ t][r ^ t][<span class="number">1</span>];</span><br><span class="line">            tmp[l][r][<span class="number">0</span>] = <span class="number">1LL</span> * (dp[<span class="number">1</span>][l][r][<span class="number">0</span>] + dp[<span class="number">1</span>][l ^ <span class="number">1</span>][r ^ <span class="number">1</span>][<span class="number">0</span>]) * <span class="built_in">qpow</span>(<span class="number">2</span>, h[sorted[n]] - <span class="number">1</span> - <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memcpy</span>(dp[<span class="number">1</span>], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        ans = (ans + dp[<span class="number">1</span>][i][j][k]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std码风好评</span></span><br></pre></td></tr></table></figure>
<h1 id="T3-road"><a href="#T3-road" class="headerlink" title="T3 road"></a>T3 road</h1><p>考场上只有<a href="https://widsnoy.top/"><strong>widsnoy​</strong></a>巨佬想到了正解， %%%</p>
<p>这道就是说，给你$n$个点，$n+1$条边，让你随意删一条边都能使这个图联通的连边方案数</p>
<blockquote>
<p>  问题转化：</p>
<blockquote>
<p>我们发现，不能有点的度数为$1$</p>
<p>所以绝大多数的点的度数为$2$</p>
<p>那么就有如下两种情况：</p>
<ul>
<li>有一个点度数为$4$</li>
<li>有两个点度数为$3$</li>
</ul>
</blockquote>
</blockquote>
<p>那么有这样一个式子：$Ans = \frac{n!(n-3)}4+\frac{n!(n-4)}8+\frac{n!(n-3)(n-4)}{24}$</p>
<p>然后分段打表处理阶乘</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>, inv2 = <span class="number">5e8</span> + <span class="number">4</span>, inv3 = <span class="number">333333336</span>;</span><br><span class="line">ll n, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">	ll mi = <span class="number">1</span>, t = inv2 * inv2 % mod;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) mi = mi * i % mod;<span class="comment">//n!</span></span><br><span class="line">	ans += (n - <span class="number">3</span>) * t % mod;</span><br><span class="line">	t = t * inv2 % mod;</span><br><span class="line">	ans += (n - <span class="number">4</span>) * t % mod;<span class="comment">//8</span></span><br><span class="line">	ans += (n - <span class="number">3</span>) * (n - <span class="number">4</span>) % mod * t % mod * inv3 % mod;</span><br><span class="line">	ans = ans % mod * mi % mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>



<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字典树</tag>
        <tag>数学</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200831</title>
    <url>/AlanTuringLi/2020/08/31/T20200831/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-教师节的问候"><a href="#T1-教师节的问候" class="headerlink" title="T1 教师节的问候"></a>T1 教师节的问候</h1><p>那么就是说，我们有一个矩阵</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
 0&a_1+a_2&a_1+a_3&\cdots&a_1+a_n
 \\a_2+a_1&0&a_2+a_3&\cdots&a_2+a_n
 \\a_3+a_1&a_3+a_2&0&\cdots&a_3+a_n
 \\\vdots&\vdots&\vdots&\ddots&\vdots
 \\a_n+a_1&a_n+a_2&a_n+a_3&\cdots&0
 \end{vmatrix}</script><p>康康最前面两行，我们发现从第三项开始$a_1-a_2=(a_1+a_3)-(a_2+a_3)$</p>
<p>那么就有了$a_1+a_2=x$和$a_1-a_2=y$</p>
<p>那么$a_1$和$a_2$就都可以解出来了</p>
<p>那么所有的元素都可以解出来了</p>
<p>但是要注意的是，当<code>n = 2</code>时可以乱搞的</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> N, S[Maxn][Maxn], A[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, S[i] + j), S[i][<span class="number">0</span>] += S[i][j];</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span> (<span class="string">&quot;2 %d&quot;</span>, S[<span class="number">1</span>][<span class="number">2</span>] - <span class="number">2</span>), <span class="number">0</span>;</span><br><span class="line">	A[<span class="number">1</span>] = (S[<span class="number">1</span>][<span class="number">2</span>] + (S[<span class="number">1</span>][<span class="number">0</span>] - S[<span class="number">2</span>][<span class="number">0</span>]) / (N - <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) A[i] = S[i][i - <span class="number">1</span>] - A[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-追逐闹剧"><a href="#T2-追逐闹剧" class="headerlink" title="T2 追逐闹剧"></a>T2 追逐闹剧</h1><p>这个就是正反一边最短路，还只能用$\text{SPFA}$</p>
<p>对于加油点扩展的话，离开加油点时，我们就可以把他的$\text{dis}$设为$0$</p>
<p>然后对可以卖油的点处理一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> N, M, C, P, U, V, L;</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[Maxn], E[Maxn], W[Maxn], Cur;</span><br><span class="line"><span class="type">int</span> Bead[Maxn], Bext[Maxn], B[Maxn];</span><br><span class="line"><span class="type">int</span> Dist[Maxn], Bist[Maxn], <span class="built_in">Ans</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">bool</span> Vis[Maxn], Plus[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U], Head[U] = Cur;</span><br><span class="line">	E[Cur] = V, W[Cur] = L;</span><br><span class="line">	</span><br><span class="line">	Bext[Cur] = Bead[V], Bead[V] = Cur;</span><br><span class="line">	B[Cur] = U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (Dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dist);</span><br><span class="line">	<span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">	Dist[S] = <span class="number">0</span>;</span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> Now = Q.<span class="built_in">front</span>();</span><br><span class="line">		Vis[Now] = <span class="number">0</span>;</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (Plus[Now]) Dist[Now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = Head[Now]; i; i = Next[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Dist[E[i]] &lt;= Dist[Now] + W[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (Dist[Now] + W[i] &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">			Dist[E[i]] = Dist[Now] + W[i];</span><br><span class="line">			<span class="keyword">if</span> (!Vis[E[i]]) Q.<span class="built_in">push</span>(E[i]), Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BSPFA</span><span class="params">(<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (Bist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Bist);</span><br><span class="line">	<span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">	Bist[S] = <span class="number">0</span>;</span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> Now = Q.<span class="built_in">front</span>();</span><br><span class="line">		Vis[Now] = <span class="number">0</span>;</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (Plus[Now]) Bist[Now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = Bead[Now]; i; i = Bext[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Bist[B[i]] &lt;= Bist[Now] + W[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (Bist[Now] + W[i] &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">			Bist[B[i]] = Bist[Now] + W[i];</span><br><span class="line">			<span class="keyword">if</span> (!Vis[B[i]]) Q.<span class="built_in">push</span>(B[i]), Vis[B[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;N, &amp;M, &amp;C);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;U, &amp;V, &amp;L);</span><br><span class="line">		<span class="built_in">AddEdge</span>(U, V, L);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;P);</span><br><span class="line">	<span class="keyword">while</span> (P--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;U);</span><br><span class="line">		Plus[U] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;P);</span><br><span class="line">	<span class="built_in">SPFA</span>(<span class="number">1</span>), <span class="built_in">BSPFA</span>(N);</span><br><span class="line">	<span class="keyword">if</span> (Dist[N] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) &amp; <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (P--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;U, &amp;L);</span><br><span class="line">		<span class="keyword">if</span> (Plus[U]) Ans = <span class="built_in">max</span>(Ans, C * L);</span><br><span class="line">		<span class="keyword">else</span> Ans = <span class="built_in">max</span>(Ans, L * (C - Dist[U] - Bist[U]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-chase"><a href="#T3-chase" class="headerlink" title="T3 chase"></a>T3 chase</h1><p>就是用总的减去不合法的</p>
<p>不合法的就是达不到$2048$的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> N, Temp, T[<span class="number">20</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>&#125;;</span><br><span class="line">ll Fac[Maxn] = &#123;<span class="number">1</span>&#125;, Inv[Maxn], C[Maxn] = &#123;<span class="number">1</span>&#125;, F[Maxn], Cnt[Maxn];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">		X = X * X % Mod;</span><br><span class="line">		Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); T[i]; ++i) Vis[T[i]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; ++i) Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	Inv[<span class="number">100000</span>] = <span class="built_in">Pow</span>(Fac[<span class="number">100000</span>], Mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">99999</span>; i &gt;= <span class="number">0</span>; --i) Inv[i] = Inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;Temp);</span><br><span class="line">		<span class="keyword">if</span> (!Vis[Temp]) Temp = <span class="number">0</span>;</span><br><span class="line">		Cnt[Temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2047</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (Cnt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = Cnt[i];</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">2048</span> / i &lt; j) j = <span class="number">2048</span> / i;</span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) C[j] = Fac[Cnt[i]] * Inv[Cnt[i] - j] % Mod * Inv[j] % Mod;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2047</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">				<span class="keyword">if</span> (F[j])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= Cnt[i]; ++k)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> L = j + i * k;</span><br><span class="line">						<span class="keyword">if</span> (L &gt;= <span class="number">2048</span>) <span class="keyword">break</span>;</span><br><span class="line">						F[L] = (F[L] + F[j] * C[k]) % Mod;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line">		&#125;</span><br><span class="line">	ll Ans = <span class="built_in">Pow</span>(<span class="number">2</span>, N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i) Ans = (Ans - F[i] * <span class="built_in">Pow</span>(<span class="number">2</span>, Cnt[<span class="number">0</span>]) % Mod + Mod) % Mod;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>图论</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200901</title>
    <url>/AlanTuringLi/2020/09/01/T20200901/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-锻造-forging"><a href="#T1-锻造-forging" class="headerlink" title="T1 锻造(forging)"></a>T1 锻造(forging)</h1><p>就是一期望$\text{Dp}$</p>
<script type="math/tex; mode=display">
\begin{align*}
f(i)&=f(i-1)+f(i-2)+(1-K)(f(i)-f(i-2))\\
f(i)&=f(i-1)+f(i-2)+f(i)-f(i-2)-Kf(i)+Kf(i-2)\\
Kf(i)&=f(i-1)+Kf(i-2)\\
f(i)&=\frac{c_{i-1}}kf(i-1)+f(i-2)
\end{align*}</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e7</span> + <span class="number">15</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, a;</span><br><span class="line"><span class="type">int</span> bx, by, cx, cy, p;</span><br><span class="line"><span class="type">int</span> b[Maxn], c[Maxn], f[Maxn], inv[Maxn] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;a);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;bx, &amp;by, &amp;cx, &amp;cy,&amp;p);</span><br><span class="line">	b[n] = b[<span class="number">0</span>] = by + <span class="number">1</span>, c[n] = c[<span class="number">0</span>] = cy + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = (<span class="number">1ll</span> * b[i - <span class="number">1</span>] * bx + by) % p + <span class="number">1</span>; b[n] = <span class="built_in">max</span>(b[i], b[n]);</span><br><span class="line">		c[i] = (<span class="number">1ll</span> * c[i - <span class="number">1</span>] * cx + cy) % p + <span class="number">1</span>; c[n] = <span class="built_in">max</span>(c[i], c[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	b[n] = <span class="built_in">max</span>(b[n], c[n]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= b[n]; ++i) inv[i] = <span class="number">1ll</span> * (Mod - Mod / i) * inv[Mod % i] % Mod;</span><br><span class="line">	f[<span class="number">0</span>] = a, f[<span class="number">1</span>] = (<span class="number">1ll</span> * inv[<span class="built_in">min</span>(c[<span class="number">0</span>], b[<span class="number">0</span>])] * c[<span class="number">0</span>] % Mod * f[<span class="number">0</span>] % Mod + f[<span class="number">0</span>]) % Mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) f[i] = (<span class="number">1ll</span> * inv[<span class="built_in">min</span>(c[i - <span class="number">1</span>], b[i - <span class="number">2</span>])] * c[i - <span class="number">1</span>] % Mod * f[i - <span class="number">1</span>] % Mod + f[i - <span class="number">2</span>]) % Mod;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, f[n] % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-整除-division"><a href="#T2-整除-division" class="headerlink" title="T2  整除(division)"></a>T2  整除(division)</h1><p>$n|x^m-x$，求在$[1,n]$有多少个解</p>
<p>考虑乱搞一下式子</p>
<script type="math/tex; mode=display">
x^m-x=kn\\
x^m\equiv x\pmod n</script><p>然后$\text{n}$又是一个无平方因子数</p>
<p>所以时可以拆开乱搞的</p>
<p>对$\text{n}$的每个因子进行一次操作，把答案乘起来即可</p>
<p>这个严格的证明应该是同余方程之类的东西？</p>
<p><del>做题的话其实是可以猜结论的</del></p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e4</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> ID, T;</span><br><span class="line"><span class="type">int</span> C, M, Tmp;</span><br><span class="line"><span class="type">int</span> Pr[Maxn + <span class="number">10</span>], Pw[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Vis[i]) Pr[++Pr[<span class="number">0</span>]] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Pr[<span class="number">0</span>] &amp;&amp; i * Pr[j] &lt;= Maxn; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Vis[i * Pr[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % Pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y, <span class="type">int</span> Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = <span class="number">1ll</span> * Ans * X % Mod;</span><br><span class="line">		X = X * X % Mod;</span><br><span class="line">		Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetAns</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pw[<span class="number">1</span>]= <span class="number">1</span>, Pw[P] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; P; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Vis[i]) Pw[i] = <span class="built_in">Pow</span>(i, M, P);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Pr[<span class="number">0</span>] &amp;&amp; i * Pr[j] &lt;= P; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Pw[i * Pr[j]] = Pw[i] * Pw[Pr[j]] % P;</span><br><span class="line">			<span class="keyword">if</span> (i % P == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; P; ++i)</span><br><span class="line">		<span class="keyword">if</span> (Pw[i] == i) ++Pw[P];</span><br><span class="line">	<span class="keyword">return</span> Pw[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;division.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;division.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	ID = <span class="built_in">Read</span>(), T = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		 C = <span class="built_in">Read</span>(), M = <span class="built_in">Read</span>();</span><br><span class="line">		 <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">		 <span class="keyword">while</span> (C--) Ans = <span class="number">1ll</span> * Ans * <span class="built_in">GetAns</span>(M, <span class="built_in">Read</span>()) % Mod;</span><br><span class="line">		 <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-欠钱-money"><a href="#T3-欠钱-money" class="headerlink" title="T3 欠钱(money)"></a>T3 欠钱(money)</h1><p>树上启发式合并</p>
<p>有根树$LCT$</p>
<p>鸽着？</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p>$\text{YJYX}$巨佬的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>,MAXM=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Last,Total,Test;</span><br><span class="line"><span class="type">int</span> Next[MAXM&lt;&lt;<span class="number">1</span>],End[MAXM&lt;&lt;<span class="number">1</span>],Head[MAXN],Val[MAXM&lt;&lt;<span class="number">1</span>],Kind[MAXM&lt;&lt;<span class="number">1</span>],Cur;</span><br><span class="line"><span class="type">int</span> Root[MAXN],Dep[MAXN],Size[MAXN];</span><br><span class="line"><span class="type">int</span> Anc[MAXN][<span class="number">20</span>],Min[MAXN][<span class="number">20</span>],Dir[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> u,v,w,Opt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;money.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;money.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> New,<span class="type">int</span> Pre,<span class="type">int</span> Top)</span> </span>&#123;</span><br><span class="line">	Root[New]=Top;</span><br><span class="line">	Dep[New]=Dep[Pre]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">17</span>) &#123;</span><br><span class="line">		Anc[New][i]=Anc[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		Min[New][i]=<span class="built_in">min</span>(Min[New][i<span class="number">-1</span>],Min[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">		Dir[New][i]=(Dir[New][i<span class="number">-1</span>] | Dir[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FOR_SIDE</span>(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		Anc[End[i]][<span class="number">0</span>]=New;</span><br><span class="line">		Min[End[i]][<span class="number">0</span>]=Val[i];</span><br><span class="line">		Dir[End[i]][<span class="number">0</span>]=(Kind[i] ^ <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">DFS</span>(End[i],New,Top);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="type">int</span> From,<span class="type">int</span> To,<span class="type">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">1</span>;</span><br><span class="line">	Next[++Cur]=Head[To];</span><br><span class="line">	Head[To]=Cur;</span><br><span class="line">	End[Cur]=From;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> From,<span class="type">int</span> To,<span class="type">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Add_Edge</span>(From,To,Temp);</span><br><span class="line">	<span class="type">int</span> Base=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(Size[Root[From]]&gt;Size[Root[To]]) Base=<span class="number">2</span>,<span class="built_in">swap</span>(From,To);</span><br><span class="line">	Size[Root[To]]+=Size[Root[From]];</span><br><span class="line">	Anc[From][<span class="number">0</span>]=To;</span><br><span class="line">	Min[From][<span class="number">0</span>]=Temp;</span><br><span class="line">	Dir[From][<span class="number">0</span>]=Base;</span><br><span class="line">	<span class="built_in">DFS</span>(From,To,Root[To]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> From,<span class="type">int</span> To)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> Base=<span class="number">1</span>,Ans=INF;</span><br><span class="line">	<span class="keyword">if</span>(Dep[From]&lt;Dep[To]) Base=<span class="number">2</span>,<span class="built_in">swap</span>(From,To);</span><br><span class="line">	<span class="built_in">BOR</span>(i,<span class="number">17</span>,<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">if</span>(Dep[From]-(<span class="number">1</span>&lt;&lt;i)&gt;=Dep[To]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=<span class="built_in">min</span>(Ans,Min[From][i]);</span><br><span class="line">			From=Anc[From][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(From==To) <span class="keyword">return</span> Ans;</span><br><span class="line">	<span class="built_in">BOR</span>(i,<span class="number">17</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Anc[From][i]!=Anc[To][i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base || Dir[To][i]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=<span class="built_in">min</span>(Ans,<span class="built_in">min</span>(Min[From][i],Min[To][i]));</span><br><span class="line">			From=Anc[From][i]; </span><br><span class="line">			To=Anc[To][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Dir[From][<span class="number">0</span>]!=Base || Dir[To][<span class="number">0</span>]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Ans=<span class="built_in">min</span>(Ans,<span class="built_in">min</span>(Min[From][<span class="number">0</span>],Min[To][<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;Total,&amp;Test);</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,Total) Root[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;Opt,&amp;u,&amp;v);</span><br><span class="line">		u=(u+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		v=(v+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Opt==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">			w=(w+Last)%Total+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">Update</span>(u,v,w);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Last=<span class="built_in">Get</span>(u,v)); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>期望Dp</tag>
        <tag>期望</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200902</title>
    <url>/AlanTuringLi/2020/09/02/T20200902/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-石头剪刀布-rps"><a href="#T1-石头剪刀布-rps" class="headerlink" title="T1 石头剪刀布(rps)"></a>T1 石头剪刀布(rps)</h1><p>那么，我们就枚举最后赢得人是谁</p>
<p>然后归并保证字典序最小</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, _a[<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> s[] = <span class="string">&quot;RPS&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">		string ans;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(s[x]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	string a = <span class="built_in">Get</span>(n - <span class="number">1</span>, x), b = <span class="built_in">Get</span>(n - <span class="number">1</span>, (x + <span class="number">1</span>) % <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a + b : b + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>] = &#123;&#125;, a0[<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line">	a[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) a0[j] = a[j];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) a[(j + <span class="number">1</span>) % <span class="number">3</span>] += a0[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i) <span class="keyword">if</span> (a[i] != _a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Get</span>(n, x) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, _a + <span class="number">0</span>, _a + <span class="number">1</span>, _a + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; n) != _a[<span class="number">0</span>] + _a[<span class="number">1</span>] + _a[<span class="number">2</span>]) ++n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Check</span>(i)) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-投票-vote"><a href="#T2-投票-vote" class="headerlink" title="T2 投票(vote)"></a>T2 投票(vote)</h1><p>将 $p_i$ 从小到大排好序，则存在一个最优方案，其中选择的同学是一段前缀和一段后缀</p>
<blockquote>
<p>  证明：</p>
<p>  ​    假设有一个选择的同学，他前后都存在未选的同学，考虑固定其他选中的同学时这个同学的概率的贡献，是一个一次函数，所以换成前后一定不劣。</p>
<p>  Q.E.D</p>
</blockquote>
<p>现在的问题是，对 $\forall i$，求出选择前$i$个和后$k-i$个时平票的概率</p>
<p>一个想法是支持插入删除的 $dp$，但有精度问题</p>
<p>$pre<em>{i,j},\;suf</em>{i,j}$表示选择前/后$i$个同学，有 个投”好”的概率</p>
<p>时间复杂度$O(n)$</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">double</span> p[Maxn], ans;</span><br><span class="line"><span class="type">double</span> Pre[Maxn][Maxn], Suf[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span> (<span class="string">&quot;%lf&quot;</span>, p + i);</span><br><span class="line">	<span class="built_in">sort</span> (p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	Pre[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; --j) Pre[i][j] = p[i] * Pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="number">1</span> - p[i]) * Pre[i - <span class="number">1</span>][j];</span><br><span class="line">		Pre[i][<span class="number">0</span>] = (<span class="number">1</span> - p[i]) * Pre[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Suf[n + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; --j) Suf[i][j] = p[i] * Suf[i + <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="number">1</span> - p[i]) * Suf[i + <span class="number">1</span>][j];</span><br><span class="line">		Suf[i][<span class="number">0</span>] = (<span class="number">1</span> - p[i]) * Suf[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> j = n + i + <span class="number">1</span> - k;</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= k; ++t) temp += Pre[i][t] * Suf[j][m - t];</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%.9f&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-工厂-factory"><a href="#T3-工厂-factory" class="headerlink" title="T3 工厂(factory)"></a>T3 工厂(factory)</h1><p><del>还没有改</del></p>
<p>首先把问题转化为二分图模型，左边 $n$ 个点表示工人，右边 $n$ 个点表示机器，左右两个点有边当且仅当对应工人会操作对应机器。无论哪种情况下所有机器都能有人操作，就等价于，任意一个极大匹配都是完美匹配</p>
<p>考虑问题的一个弱化版本：判断是否任意一个极大匹配都是完美匹配</p>
<p>观察发现，任意一个极大匹配都是完美匹配$(a)$ ，如果任意一个联通块都是左右点数相等的完全二分图$(b)$。</p>
<p>证明：</p>
<p>从$b$推出$a$是显然的，下面只用证明从$a$推出$b$。</p>
<p>反证法。</p>
<p>假设存在一张二分图，存在一个联通块不是左右点数相等的完全二分图，同时满足任意一个极大匹配都是完美匹配。如果这个联通块左右点数不相等，那么它就不存在完美匹配，显然矛盾。否则这个联通块不是完全二分图，设左边的$a$点和右边的$b$点之间没有边，随便找一条从$a$到$b$的简单路径，记作$p$。选择$p$上的奇数边，再随便选一些边构造一个极大匹配，那么这个极大匹配必定是完美匹配。把奇数边改成偶数边，其他的边不变，那么除了$a,b$以外的点都在匹配上，所以得到了一个非完美匹配的极大匹配，矛盾。</p>
<p>Q.E.D.</p>
<p>回到原问题，对每个联通块求出它在左右的点数，记作$(x<em>i, y_i)$ ，现在的问题相当于，将 $(x_i,y_i)$ 分成若干个集合，$\forall s$ 满足$\sum</em>{i\in s}x<em>i=\sum</em>{i\in s}y<em>i$，最小化 $\sum_s(\sum</em>{i\in s}x_i)^2$。</p>
<p>状压 $dp$。 $dp_{s,i}$表示集合 中已经划出的满足要求的集合的 $\sum x=i$ 的最小代价。</p>
<p>转移就枚举 $x$，从$dp<em>s$ 转移到 $dp</em>{s\cup{x}}$。</p>
<p>对所有相同的 $(x_i,y_i)$ 只用关心个数，当 $n=30$ 时，本质不同的集合个数的最大值是 $173032$ ，可以通过本题。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">chmin</span><span class="params">(T &amp;x,<span class="type">const</span> T &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)x=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>+<span class="number">2</span>,U=<span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="type">int</span> dp[U][N];</span><br><span class="line">pii q[N*<span class="number">2</span>];<span class="type">int</span> m,cnt[N*<span class="number">2</span>],w[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pii <span class="keyword">operator</span> +(<span class="type">const</span> pii &amp;a,<span class="type">const</span> pii &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pii</span>(a.first+b.first,a.second+b.second);</span><br><span class="line">&#125;</span><br><span class="line">pii <span class="keyword">operator</span> *(<span class="type">const</span> pii &amp;a,<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pii</span>(a.first*x,a.second*x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> +=(pii &amp;a,<span class="type">const</span> pii &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	a=a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqr</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">		m=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n*<span class="number">2</span>)vis[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n*<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			deque&lt;<span class="type">int</span>&gt;nq;</span><br><span class="line">			<span class="keyword">auto</span> push=[&amp;](<span class="type">int</span> x) &#123; <span class="keyword">if</span>(!vis[x])&#123;nq.<span class="built_in">push_back</span>(x);vis[x]=<span class="number">1</span>;&#125; &#125;; </span><br><span class="line">			<span class="built_in">push</span>(i);</span><br><span class="line">			pii now=<span class="built_in">pii</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">while</span>(!nq.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=nq.<span class="built_in">front</span>();nq.<span class="built_in">pop_front</span>();</span><br><span class="line">				<span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">				&#123;</span><br><span class="line">					++now.first;</span><br><span class="line">					<span class="built_in">rep</span>(y,<span class="number">1</span>,n)</span><br><span class="line">					<span class="keyword">if</span>(s[x][y]==<span class="string">&#x27;1&#x27;</span>)<span class="built_in">push</span>(y+n);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					++now.second;</span><br><span class="line">					<span class="built_in">rep</span>(y,<span class="number">1</span>,n)</span><br><span class="line">					<span class="keyword">if</span>(s[y][x-n]==<span class="string">&#x27;1&#x27;</span>)<span class="built_in">push</span>(y);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			q[++m]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> m0=m;m=<span class="number">1</span>;</span><br><span class="line">		cnt[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,m0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i]==q[m])++cnt[m];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				q[++m]=q[i];</span><br><span class="line">				cnt[m]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		w[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,m+<span class="number">1</span>)w[i]=w[i<span class="number">-1</span>]*(cnt[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(s,<span class="number">0</span>,w[m+<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n)dp[s][i]=N*N;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		cerr&lt;&lt;w[m+<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">rep</span>(s,<span class="number">0</span>,w[m+<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pii sum=<span class="built_in">pii</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,m)sum+=q[i]*(s%w[i+<span class="number">1</span>]/w[i]);</span><br><span class="line">			<span class="keyword">if</span>(sum.first==sum.second)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">rep</span>(i,<span class="number">0</span>,sum.first<span class="number">-1</span>)<span class="built_in">chmin</span>(dp[s][sum.first],dp[s][i]+<span class="built_in">sqr</span>(sum.first-i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,m)</span><br><span class="line">			<span class="keyword">if</span>(s%w[i+<span class="number">1</span>]/w[i]&lt;cnt[i])</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,n)<span class="built_in">chmin</span>(dp[s+w[i]][j],dp[s][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n)sum+=s[i][j]==<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[w[m+<span class="number">1</span>]<span class="number">-1</span>][n]-sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>P4900食堂</title>
    <url>/AlanTuringLi/2020/11/29/P4900%E9%A3%9F%E5%A0%82/</url>
    <content><![CDATA[<h1 id="P4900-食堂"><a href="#P4900-食堂" class="headerlink" title="P4900 食堂"></a><a href="https://www.luogu.com.cn/problem/P4900">P4900 食堂</a></h1><h2 id="方案一-O-n-sqrt-n-："><a href="#方案一-O-n-sqrt-n-：" class="headerlink" title="方案一 $O(n\sqrt n)$："></a>方案一 $O(n\sqrt n)$：</h2><p>首先可以考虑一下这个小数部分该如何处理，显然是可以利用这个高斯函数的性质的：${p}=p-[p]$。</p>
<p>所以第 $n$ 行的和就可以写作：</p>
<script type="math/tex; mode=display">
\begin{aligned}
sum_n&=\sum_{i=1}^n\frac {n\mod i}i\\
&=\sum_{i=1}^n\frac ni-\sum i\times[\frac ni]\\
\end{aligned}</script><p>所以后面那个可以整数分块，前面的 $O(n)$ 预处理，整体时间复杂度 $O(n\sqrt n)$，过不了的。</p>
<p>期望得分：$50$ 分</p>
<h2 id="方案二-O-n-log-n"><a href="#方案二-O-n-log-n" class="headerlink" title="方案二 $O(n\log n)$"></a>方案二 $O(n\log n)$</h2><p>考虑这一行的分子理论上应该是上一行的分子 $+1$，所以理论上是可以直接继承的，但是分子的值域却只能是 $[0,n)$，所以要考虑剪去变成零的数的贡献，那么这个就应该是 $\sigma(i)$，就可以 $O(n\log n)$ 预处理了。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> infile[] = <span class="string">&quot;.in&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> outfile[] = <span class="string">&quot;.out&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> t ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">file</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (infile, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (outfile, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn], cnt[maxn], inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) </span><br><span class="line">        inv[i] = <span class="number">1ll</span> * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; maxn; ++i)</span><br><span class="line">        inv[i] = (inv[i] + inv[i - <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt; maxn; j += i)</span><br><span class="line">            cnt[j]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        ll temp = ((f[i - <span class="number">1</span>] - f[i - <span class="number">2</span>]) % mod + mod) % mod + inv[i - <span class="number">1</span>];</span><br><span class="line">        f[i] = (temp - cnt[i] + f[i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, (f[b] - f[a - <span class="number">1</span>] + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="方案三-O-n"><a href="#方案三-O-n" class="headerlink" title="方案三 $O(n)$"></a>方案三 $O(n)$</h2><p>事实证明确实是可以 $O(n)$ 的，就是一个线性筛就可以了。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> infile[] = <span class="string">&quot;.in&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> outfile[] = <span class="string">&quot;.out&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> t ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">file</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (infile, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (outfile, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn], cnt[maxn], inv[maxn], sum[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn], idx[maxn], tot;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">		inv[i] = <span class="number">1ll</span> * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">		sum[i] = (sum[i - <span class="number">1</span>] + inv[i]) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++tot] = i, idx[i] = <span class="number">1</span>, cnt[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[i * p[j]] = cnt[i] / (idx[i] + <span class="number">1</span>) * (idx[i] + <span class="number">2</span>);</span><br><span class="line">                idx[i * p[j]] = idx[i] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[i * p[j]] = cnt[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            idx[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">		ll tmp = ((f[i - <span class="number">1</span>] - f[i - <span class="number">2</span>]) % mod + mod) % mod + sum[i - <span class="number">1</span>];</span><br><span class="line">        f[i] = (tmp - (cnt[i] - <span class="number">2</span>) + f[i - <span class="number">1</span>] + mod) % mod;    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, (f[b] - f[a - <span class="number">1</span>] + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200903赛后总结(转载)</title>
    <url>/AlanTuringLi/2020/09/03/T20200903(%E8%BD%AC%E8%BD%BD)/</url>
    <content><![CDATA[<h2 id="特别鸣谢：DeNeRATe"><a href="#特别鸣谢：DeNeRATe" class="headerlink" title="特别鸣谢：DeNeRATe"></a>特别鸣谢：<a href="https://denerate-cool.github.io/DeNeRATe.github.io/">DeNeRATe</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是真的全考<strong>数学</strong>了<strong>/kk</strong></p>
<p><strong>死磕T1</strong>，结果自我感觉最难的就是T1了。。。</p>
<p>最后直接<strong>雪崩</strong>。。。</p>
<p><img src="https://i.loli.net/2020/09/03/AqSZ17Qp6j28UWe.gif" alt="T20200903-1.gif"></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/VrWSsyaoKw95gX6.png" alt="T20200903-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr>
<p>我们先考虑<strong>弱化版</strong>：</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{i=1} \sum^{n}_{j=i+1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k)</script><p>发现，非常简单，<strong>化简一下</strong></p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} \sum^{j-1}_{i=1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \\
=\sum^{n}_{j=1} \left( \sum^{j-1}_{i=1} A_i \bigoplus A_j \right) \times \left( \sum^{n}_{k=j+1} A_j \bigoplus A_k \right)</script><p>我们令</p>
<script type="math/tex; mode=display">
L[j] = \sum^{j-1}_{i=1} A_i \bigoplus A_j \\
R[j] = \sum^{n}_{k=j+1} A_j \bigoplus A_k</script><p>所以我们可以得到</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} L[j] \times R[j]</script><p>我们进而化简</p>
<p>设，$ Bit(i,j) $表示$i$的第$j$位是$ 1/0 $</p>
<script type="math/tex; mode=display">
L[j] = \sum^{30}_{k=0} 2^k \times \sum^{j-1}_{i=0} [Bit(A_j,k) \neq Bit(A_i,k)] \\
R[j] = \sum^{30}_{k=0} 2^k \times \sum^{n}_{i=j+1} [Bit(A_j,k) \neq Bit(A_i,k)]</script><hr>
<p>有了上边的<strong>基础</strong></p>
<p>对于<strong>升级版</strong></p>
<p>我们就可以<strong>轻松切了</strong></p>
<p>（当时推到这儿了，结果还是没有维护出来。。。<strong>wtcl</strong>）</p>
<script type="math/tex; mode=display">
Ans = \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (A_i \bigoplus A_k) \\
= \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times \sum^{30}_{b=0} 2^b \times (Bit(A_i,b) \neq Bit(A_k,b)) \\
= \sum^{30}_{b=0} 2^b \times \sum_{i<j<K} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (Bit(A_i,b) \neq Bit(A_k,b))</script><p>所以，我们只需要枚举$ Bit(A_i,b) \neq Bit(A_k,b) $时的<strong>每一位</strong>即可统计答案</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>吐槽一下：</strong>实现是真的<strong>闹心</strong>。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>,Limit=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Num[MAXN],Ans;</span><br><span class="line">LL L[MAXN][<span class="number">2</span>],R[MAXN][<span class="number">2</span>];</span><br><span class="line">LL Suf[Limit][<span class="number">2</span>][<span class="number">2</span>],Pre[Limit][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">LL Two[Limit]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Solve</span><span class="params">(LL Temp)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Cl</span>(Suf,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		L[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		L[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(L[i][<span class="number">0</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(L[i][<span class="number">1</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Suf[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Cl</span>(Pre,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">BOR</span>(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		R[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		R[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(R[i][<span class="number">0</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(R[i][<span class="number">1</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Pre[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Val=(L[i][<span class="number">0</span>]*R[i][<span class="number">1</span>]+L[i][<span class="number">1</span>]*R[i][<span class="number">0</span>])%MOD;</span><br><span class="line">		(Res+=(Val*Two[Temp]))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;Total);</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,<span class="number">30</span>) Two[i]=Two[i<span class="number">-1</span>]*<span class="number">2</span>%MOD;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;Num[i]);</span><br><span class="line">	<span class="built_in">FOR</span>(Loc,<span class="number">0</span>,<span class="number">30</span>) (Ans+=<span class="built_in">Solve</span>(Loc))%=MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans%MOD);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/ocVUwvBbyXCkKgZ.png" alt="T20200903-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>吐槽一下：</strong>由于我把题读错了？导致对着<strong>题解</strong>搞了好久</p>
<p>我们如果直接枚举$n,k$状态，那么算重是一定的了</p>
<p>所以，我们需要<strong>枚举每一个数选的个数</strong></p>
<p>自然，我们就可以设计出状态<code>DP[i][j]</code>表示<strong>选了$i$个数，总和位$j$的集合数</strong></p>
<p>所以我们可以先求出<code>DP[i][j]</code>，最后来枚举每一个数的个数即可</p>
<p>但我们不能像通常一样枚举$i,j$，这样是$ O(n^3) $</p>
<p>我们可以考虑两种<strong>转移方式</strong>：</p>
<ul>
<li>在当前集合状态下<strong>加一个1</strong></li>
<li>将当前集合中的<strong>所有数加1</strong></li>
</ul>
<p>所以，我们的转移就是$ O(n^2) $了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> LL MAXN=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[MAXN][MAXN],Ans;</span><br><span class="line">LL Total,Base,Limit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;set.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;set.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; Res=(Res*A)%MOD; &#125;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;Total,&amp;Limit,&amp;Base);</span><br><span class="line">	DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">0</span>,Limit<span class="number">-1</span>) </span><br><span class="line">		<span class="built_in">FOR</span>(j,<span class="number">0</span>,Total) &#123;</span><br><span class="line">			(DP[i+<span class="number">1</span>][j+<span class="number">1</span>]+=DP[i][j])%=MOD;</span><br><span class="line">			<span class="keyword">if</span>(i &amp;&amp; j+i&lt;=Total) (DP[i][j+i]+=DP[i][j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(LL j=<span class="number">1</span>;j&lt;=(Total/i) &amp;&amp; j&lt;=Limit;j++) </span><br><span class="line">			(Sum+=DP[Limit-j][Total-i*j])%=MOD;</span><br><span class="line">		(Ans+=Sum*<span class="built_in">Fast</span>(i,Base))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans%MOD);</span><br><span class="line">    <span class="built_in">fclose</span>(stdin); <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>组合数学+构造</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/decQ8gDUjRNKpi6.png" alt="T20200903-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>因为我们直接<strong>正面解决</strong>问题是很困难的</p>
<p>所以我们考虑计算无法满足题目要求的集合的个数，即：</p>
<ul>
<li><strong>最大值不超过$k$</strong></li>
<li><strong>所有数异或之和位0</strong></li>
</ul>
<hr>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><p><strong>从高到低</strong>考虑，<strong>一定存在</strong>一个$A_i$满足$ Bit(A_i,j) \neq Bit(k,j) $</p>
<p>证明<strong>显然</strong>，<strong>故咕</strong></p>
<p>因为$ \forall i \in [1,n],A_i \leq k $</p>
<p>所以当存在时，<strong>当且仅当</strong>$A_i$的第$j$位为<strong>0</strong></p>
<hr>
<p>有了这个引理，这道题基本就可以<strong>宣告结束</strong>了</p>
<p>对于剩下的$n-1$个数，他们的剩下$j-1$位可以<strong>乱填</strong>都是没有问题的</p>
<p>所以我们来考虑$ Bit(A_i,j)==0 $，他的$ [0,j-1] $有$ 2^j $种情况</p>
<p>对于$ Bit(A_i,j)==1 $，他的$ [0,j-1] $有$ k \,\,\, \&amp; \,\,\, (2^j-1)+1 $</p>
<p>所以，我们可以<strong>枚举</strong>满足$ Bit(A_i,j)==0 $的数的个数</p>
<p><strong>方案数</strong>为：</p>
<script type="math/tex; mode=display">
{n \choose v} \times (2^j)^{v-1} \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v}</script><p>我们必须要保证$v$和$n$的<strong>奇偶性相同</strong>，才能使得最后异或和为0</p>
<p>进而，我们可以通过<strong>二项式定理</strong>来化简</p>
<p>对于$n$为<strong>偶数</strong>的情况（<strong>奇数</strong>很简单的啦）</p>
<script type="math/tex; mode=display">
Ans = (2^{-j-1}) \times \sum^{n}_{n=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times ((-1)^v + 1^v)</script><p>所以</p>
<script type="math/tex; mode=display">
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times (-1)^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1-2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n) \\
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times 1^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1+2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n)</script><p><strong>时间复杂度：$ O(log^2n) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">LL Total,Ans,Limit,Temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor2.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor2.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	A=((A%MOD+MOD)%MOD);</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%MOD;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;Total,&amp;Limit);</span><br><span class="line">	<span class="keyword">if</span>(!(Total%<span class="number">2</span>)) Temp++;</span><br><span class="line">	<span class="built_in">BOR</span>(i,<span class="number">29</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Limit &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">			LL Last=(Limit &amp; ((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">			LL Val=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">if</span>(Total%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				Ans=<span class="built_in">Fast</span>(Last+Val,Total)%MOD;</span><br><span class="line">				(Ans+=<span class="built_in">Fast</span>(Last-Val,Total))%=MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				Ans=((Ans-<span class="built_in">Fast</span>(Last,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Temp+=(Ans*<span class="built_in">Fast</span>(Val,MOD<span class="number">-2</span>)))%=MOD;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Ans=<span class="built_in">Fast</span>(Last+Val,Total)%MOD;</span><br><span class="line">				Ans=((Ans-<span class="built_in">Fast</span>(Last-Val,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				(Temp+=Ans*<span class="built_in">Fast</span>(Val,MOD<span class="number">-2</span>)%MOD)%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(Total &amp; <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,((<span class="built_in">Fast</span>(Limit+<span class="number">1</span>,Total)-Temp)%MOD+MOD)%MOD);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>考试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200904</title>
    <url>/AlanTuringLi/2020/09/04/T20200904/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="day8(8.25).pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-count"><a href="#T1-count" class="headerlink" title="T1(count)"></a>T1(count)</h1><h2 id="45分做法"><a href="#45分做法" class="headerlink" title="45分做法"></a>45分做法</h2><p>直接暴力乱搞！！！</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, <span class="built_in">nm</span>(<span class="number">1</span>), cnt, ans;</span><br><span class="line"><span class="type">int</span> son[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep, <span class="type">int</span> fac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fac &gt; nm) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (dep == m * <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		++ans;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">		<span class="built_in">dfs</span>(dep + <span class="number">1</span>, fac * son[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;count.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;count.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) nm *= n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) son[++cnt] = i;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为你大概算一下，发现其实$100$以内的答案还是真的挺少的</p>
<h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>下面上PDF，先鸽着</p>
<h1 id="T2-delet"><a href="#T2-delet" class="headerlink" title="T2(delet)"></a>T2(delet)</h1><p>题解说，贪心删即可</p>
<p>然后根据某高级定理</p>
<p>每次删除一个最长单调的链，他的长度大概是一个$\log$级别的</p>
<p>所以最多$800$次可以删完</p>
<p>然后题解保证的是$500$次能删完</p>
<p>那么有$n\log n$求最长上升/下降子序列的做法</p>
<p>总时间复杂度$O(500\;n\log n)$</p>
<p>乱搞也能过。。。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">64005</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn],a0[maxn],n,tot,f[maxn],g[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[maxn];</span><br><span class="line"><span class="type">int</span> mx1[maxn],mx2[maxn],bac[maxn],del[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len=vec[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=len<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,vec[i][j],<span class="string">&quot; \n&quot;</span>[j==<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		mx1[i]=<span class="built_in">max</span>(mx1[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		mx2[i]=<span class="built_in">max</span>(mx2[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		res=<span class="built_in">max</span>(res,mx1[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		res=<span class="built_in">max</span>(res,mx2[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++tot;</span><br><span class="line">	<span class="built_in">memset</span>(mx1,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">memset</span>(mx2,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=<span class="built_in">query1</span>(a[i])+<span class="number">1</span>;</span><br><span class="line">		g[i]=<span class="built_in">query2</span>(a[i])+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">insert1</span>(a[i],f[i]);</span><br><span class="line">		<span class="built_in">insert2</span>(a[i],g[i]);</span><br><span class="line">		ans1=<span class="built_in">max</span>(ans1,f[i]);</span><br><span class="line">		ans2=<span class="built_in">max</span>(ans2,g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(del,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ans1&gt;ans2) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> t=ans1,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (f[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].<span class="built_in">pb</span>(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> t=ans2,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (g[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].<span class="built_in">pb</span>(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		bac[i]=bac[i<span class="number">-1</span>]+<span class="number">1</span>-del[i];</span><br><span class="line">	<span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span> (!del[a[i]]) a0[++pos]=a0[i],a[pos]=bac[a[i]];</span><br><span class="line">	n=pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		<span class="built_in">freopen</span>(<span class="string">&quot;delete.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">		<span class="built_in">freopen</span>(<span class="string">&quot;delete.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),a0[i]=a[i];</span><br><span class="line">	<span class="keyword">while</span> (n) <span class="built_in">DP</span>();</span><br><span class="line">	<span class="built_in">Print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std</span></span><br></pre></td></tr></table></figure>
<h1 id="T3-floor"><a href="#T3-floor" class="headerlink" title="T3(floor)"></a>T3(floor)</h1><p>这是我今天特别失败的地方</p>
<p>我$TM$花了$2h$来打表找规律，结果，结果！！</p>
<p>我$TM$打错表了！！！</p>
<p><img src="https://i.loli.net/2020/09/03/AqSZ17Qp6j28UWe.gif" alt="T20200903-1.gif"></p>
<p>最后还是搞出来了，真是惊悚啊</p>
<h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   	1</span><br><span class="line">2    	3</span><br><span class="line">4 		4</span><br><span class="line">6 	 	7</span><br><span class="line">11 		11</span><br><span class="line">17  	18</span><br><span class="line">29   	29</span><br><span class="line">46   	47</span><br><span class="line">76   	76</span><br><span class="line">122     123</span><br><span class="line">199     199</span><br><span class="line">321     322</span><br><span class="line">521     .</span><br><span class="line">842     .</span><br><span class="line">1364    .</span><br><span class="line">2206    .</span><br><span class="line">3571    .</span><br><span class="line">5777    .</span><br><span class="line">9349    .</span><br><span class="line">15126   .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>左边这个是没有取模的值</p>
<p>右边这个是不是有点像斐波那契数列呢？</p>
<p>看看数据范围$n\le10^{18}$</p>
<p>矩阵乘法，那就结束了？</p>
<script type="math/tex; mode=display">
\begin{vmatrix}f_i&f_{i-1}\\0&0\end{vmatrix}\qquad \begin{vmatrix}1&1\\1&0\end{vmatrix}</script><p>就用这两个矩阵做快速幂</p>
<p>然后因为没有对$1$做贡献的数，所以我们让矩阵的$0$次方的值为$3$</p>
<p>如果$n$是个偶数，那么答案还要减一</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;ll a[<span class="number">2</span>][<span class="number">2</span>];&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">ppt</span> <span class="params">(matrix x, matrix y)</span> </span>&#123;</span><br><span class="line">	matrix ans;</span><br><span class="line">	<span class="built_in">memset</span> (ans.a, <span class="number">0</span>, <span class="keyword">sizeof</span> ans.a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k)</span><br><span class="line">				ans.a[i][j] = (ans.a[i][j] + x.a[i][k] * y.a[k][j] % p) % p;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	matrix x, ans;</span><br><span class="line">	x.a[<span class="number">0</span>][<span class="number">0</span>] = x.a[<span class="number">0</span>][<span class="number">1</span>] = x.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>, ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = x.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = <span class="built_in">ppt</span>(ans, x);</span><br><span class="line">		x = <span class="built_in">ppt</span>(x, x);</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!n || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	ll ans = <span class="built_in">Pow</span>(n - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(n % <span class="number">2</span>)) --ans;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200922</title>
    <url>/AlanTuringLi/2020/09/22/T20200922/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-集合均值-mos"><a href="#T1-集合均值-mos" class="headerlink" title="T1 集合均值(mos)"></a>T1 集合均值(mos)</h1><p>就是暴力+线性求逆元即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lowbit(X) (X &amp; (-X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> LL MaxN=<span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,M;</span><br><span class="line">LL Num[MaxN],Inv[MaxN];</span><br><span class="line">LL Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">    LL Res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(B) &#123;</span><br><span class="line">        <span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%Mod;</span><br><span class="line">        A=(A*A)%Mod;</span><br><span class="line">        B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Res%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">FOR</span>(i,A-B+<span class="number">1</span>,A) (a*=i)%=Mod;</span><br><span class="line">	<span class="built_in">FOR</span>(i,<span class="number">1</span>,B) (b*=i)%=Mod;</span><br><span class="line">	<span class="keyword">return</span> A*<span class="built_in">Fast</span>(b,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    LL Sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">1</span>,N) cin&gt;&gt;Num[i],Sum+=Num[i];</span><br><span class="line">    LL S=N*M;</span><br><span class="line">    Sum*=M;</span><br><span class="line">    LL Ans=Sum%Mod*<span class="built_in">Fast</span>(S,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">    LL Temp=<span class="number">0</span>;</span><br><span class="line">    Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    LL Res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,<span class="number">2</span>,S+<span class="number">1</span>) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod,(Res+=Inv[i])%Mod;</span><br><span class="line">    cout&lt;&lt;Ans*(((S-Res)%Mod+Mod)%Mod)%Mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-聚烷撑乙二醇-pag"><a href="#T2-聚烷撑乙二醇-pag" class="headerlink" title="T2 聚烷撑乙二醇(pag)"></a>T2 聚烷撑乙二醇(pag)</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑清楚“最优操作”到底是什么样的，这题就很简单 </p>
<p>假设只有两个发生器，那么如果放弃第一个选用第二个，第二个发生器产生的数的期望是</p>
<script type="math/tex; mode=display">
Y=\frac{L_2+R_2}{2}</script><p> 不难想到如果第一个发生器产生了 $X$，$X&lt;Y$ 时放弃 $X$ 更优，否则拿走 $x$ 更优。</p>
<p> 更一般的，假设当前在使用第 $i$ 个发生器，其产生了 $X$，设从第 $i$ 个发生器开始游戏得到的最优答案是 $f<em>{i+1}$ ，那么比较 $X$ 和 $f</em>{i+1}$ 的大小关系就可以确定是否拿走 $X$ 。那么 $f_i$ 的计算就是一个分段的一次函数的积分，来个加权平均数什么的算一下就好了。</p>
<p>时间复杂度$O(n)$</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> l[maxn], r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;pag.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;pag.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = read;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, l + i, r + i);</span><br><span class="line"></span><br><span class="line">	ld ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i; i --) &#123;</span><br><span class="line">		<span class="type">int</span> L = l[i], R = r[i];</span><br><span class="line">		<span class="keyword">if</span> (ans &lt; L)</span><br><span class="line">			ans = <span class="built_in">ld</span>(L + R) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; R)</span><br><span class="line">			ans = (ans * (ans - L) + (ans + R) / <span class="number">2</span> * (R - ans)) / (R - L);</span><br><span class="line">		<span class="comment">/* else */</span></span><br><span class="line">		<span class="comment">/* 	ans = ans; */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.5Lf\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-技术情报局-tio"><a href="#T3-技术情报局-tio" class="headerlink" title="T3 技术情报局(tio)"></a>T3 技术情报局(tio)</h1><p>对于$20$分的数据，暴力枚举即可</p>
<p>这个最大值太突兀了，不难想到枚举每个数，考虑其作为最大值的区间的贡献。</p>
<p> 建大根笛卡尔树，设 $i$ 在笛卡尔树上管辖的区间为 $[l,r]$，那么当区间 $[L,R]$ 满足 $L\in[l,i]\land R\in[i,R]$ 时 $i$ 恰好作为 $[L,R]$ 的最大值。在笛卡尔树上做些信息合并即可统计答案。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], mod;</span><br><span class="line"><span class="type">int</span> ls[maxn], rs[maxn];</span><br><span class="line"><span class="type">int</span> stk[maxn], top;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> GenHelper &#123;</span><br><span class="line">    <span class="type">unsigned</span> z1, z2, z3, z4, b;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">rand_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b = ((z1 &lt;&lt; <span class="number">6</span>) ^ z1) &gt;&gt; <span class="number">13</span>;</span><br><span class="line">        z1 = ((z1 &amp; <span class="number">4294967294U</span>) &lt;&lt; <span class="number">18</span>) ^ b;</span><br><span class="line">        b = ((z2 &lt;&lt; <span class="number">2</span>) ^ z2) &gt;&gt; <span class="number">27</span>;</span><br><span class="line">        z2 = ((z2 &amp; <span class="number">4294967288U</span>) &lt;&lt; <span class="number">2</span>) ^ b;</span><br><span class="line">        b = ((z3 &lt;&lt; <span class="number">13</span>) ^ z3) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">        z3 = ((z3 &amp; <span class="number">4294967280U</span>) &lt;&lt; <span class="number">7</span>) ^ b;</span><br><span class="line">        b = ((z4 &lt;&lt; <span class="number">3</span>) ^ z4) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        z4 = ((z4 &amp; <span class="number">4294967168U</span>) &lt;&lt; <span class="number">13</span>) ^ b;</span><br><span class="line">        <span class="keyword">return</span> (z1 ^ z2 ^ z3 ^ z4);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125; <span class="comment">// namespace GenHelper</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span> <span class="params">(<span class="type">int</span> n, <span class="type">unsigned</span> s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> GenHelper;</span><br><span class="line">    z1 = s;</span><br><span class="line">    z2 = <span class="built_in">unsigned</span>((~s) ^ <span class="number">0x233333333</span>U);</span><br><span class="line">    z3 = <span class="built_in">unsigned</span>(s ^ <span class="number">0x1234598766</span>U);</span><br><span class="line">    z4 = (~s) + <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand_</span>() &amp; <span class="number">32767</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand_</span>() &amp; <span class="number">32767</span>;</span><br><span class="line">        a[i] = (l + (x * <span class="number">32768</span> + y) % (r - l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    ll p, q, x;</span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="type">const</span> Data &amp;r) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            (p + x * r.p) % mod,</span><br><span class="line">            (r.q + r.x * q) % mod,</span><br><span class="line">            x * r.x % mod</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">Slove</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!i) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    Data L = <span class="built_in">Slove</span>(ls[i], l, i - <span class="number">1</span>);</span><br><span class="line">    Data R = <span class="built_in">Slove</span>(rs[i], i + <span class="number">1</span>, r);</span><br><span class="line">    Data D = &#123;a[i], a[i], a[i]&#125;;</span><br><span class="line">    ans = (ans + (L.q + <span class="number">1</span>) * (R.p + <span class="number">1</span>) % mod * a[i] % mod * a[i] % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> L + D + R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read(), s = __read(), l = __read(), r = __read();</span><br><span class="line">    mod = __read();</span><br><span class="line">    <span class="built_in">get</span>(n, <span class="built_in">unsigned</span>(s), l, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top <span class="keyword">and</span> a[stk[top]] &lt; a[i]) ls[i] = stk[top--];</span><br><span class="line">        <span class="keyword">if</span> (top) rs[stk[top]] = i;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Slove</span>(stk[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-肯德基-KFC"><a href="#T4-肯德基-KFC" class="headerlink" title="T4 肯德基(KFC)"></a>T4 肯德基(KFC)</h1><p>先吐槽一下，这道题是真的战术失误</p>
<p>我当时不知道是傻了还是怎么了，只想到了统计无平方因字数的个数的做法</p>
<p>竟然没想到怎么加权。。。</p>
<p>害，学艺不精啊。。。</p>
<p>关于无平方因字数的个数<a href="https://alansblog.ink/2020/07/28/从1开始的数论/">看这里</a></p>
<p>记$[1,n]$范围内无平方因字数的个数为$Count_n$，那么有：</p>
<script type="math/tex; mode=display">
Count_n=\sum_{i=1}^\sqrt n\mu(i)\left\lfloor\frac n{i^2}\right\rfloor</script><p>在此基础上，加上$i^2$的贡献即为答案啊</p>
<p>我是真的蠢了</p>
<p>所以得到：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^\sqrt n\mu(i)i^2S(\left\lfloor\frac n{i^2}\right\rfloor)</script><p>然后就是关于这个$std$的玄学优化了，表示没看得很明白</p>
<p>不加优化的话，那就只有$80$分的好成绩，对于我来说就够啦</p>
<h2 id="Code-80"><a href="#Code-80" class="headerlink" title="Code(80)"></a>Code(80)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i * i &lt;= n; ++i) </span><br><span class="line">            ans += g[i] * <span class="built_in">S</span>(n / i / i);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code-100"><a href="#Code-100" class="headerlink" title="Code(100)"></a>Code(100)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = g[i - <span class="number">1</span>] + mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> B = <span class="built_in">int</span>(<span class="built_in">powl</span>(n, <span class="number">1.0l</span> / <span class="number">3</span>));</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">int</span> (n / B / B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B <span class="keyword">and</span> n / i / i &gt; m; ++i) </span><br><span class="line">            ans += (g[i] - g[i - <span class="number">1</span>]) * <span class="built_in">S</span>(n / i / i);</span><br><span class="line">        <span class="keyword">for</span> (ll i = m; i; --i) </span><br><span class="line">            ans += <span class="built_in">S</span>(i) * (g[<span class="built_in">int</span>(<span class="built_in">sqrtl</span>(n / i))] - g[<span class="built_in">int</span>(<span class="built_in">sqrt</span>(n / (i + <span class="number">1</span>)))]);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我竟然来更新了</p>
<p>发现$\left\lfloor\frac n{i^2}\right\rfloor$这个东西可以直接分块</p>
<p>那么就可以直接写了</p>
<p>才不需要什么其他的三次方根之类的鬼畜玩意儿呢！！！</p>
<h2 id="Code-100-1"><a href="#Code-100-1" class="headerlink" title="Code(100+)"></a>Code(100+)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = g[i - <span class="number">1</span>] + mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;kfc.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l * l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = <span class="built_in">sqrt</span>(n / (n / l / l));</span><br><span class="line">            ans += (g[r] - g[l - <span class="number">1</span>]) * <span class="built_in">S</span>(n / l / l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center> <a href="./solution.pdf">附件下载 </center>

<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>期望Dp</tag>
        <tag>期望</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200924</title>
    <url>/AlanTuringLi/2020/09/25/T20200924/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-吃屎题"><a href="#T1-吃屎题" class="headerlink" title="T1(吃屎题)"></a>T1(吃屎题)</h1><p><del>这个题，当时交错文件了，真该吃屎</del></p>
<p>就是说，当前的字符作为开头是否是一个更优的选择</p>
<p>如果是，那么就可以清空字符</p>
<p>否则，找到最优的位置插进去</p>
<p>就是一裸的贪心</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, cnt;</span><br><span class="line"><span class="type">char</span> temp[maxn];</span><br><span class="line"><span class="type">char</span> ans[maxn], opt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">r</span><span class="params">(cnt)</span>, <span class="title">rp</span><span class="params">(cnt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= ans[cnt - <span class="number">1</span>]) <span class="keyword">return</span> rp;</span><br><span class="line">    ans[cnt] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans[mid] &lt; x) rp = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %s&quot;</span>, &amp;len, temp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">0</span>] &gt;= temp[i]) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">Find</span>(temp[i]);</span><br><span class="line">            ans[cnt = p] = temp[i];</span><br><span class="line">            ++cnt; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            ans[cnt] = temp[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) <span class="built_in">putchar</span>(ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-掉分提"><a href="#T2-掉分提" class="headerlink" title="T2(掉分提)"></a>T2(掉分提)</h1><p>首先考虑$1$的代价</p>
<ul>
<li>我们要删除$1$，无论$1$在哪里，他的最优决策一定是用$1$的代价删除</li>
<li>然后，忽略数列中的所有$1$，它就可以看作是一的$k$段的数列</li>
</ul>
<p>那么现在得到的就是$k$段不含$1$的数列，假设它为$a,b,c,d,e,f\cdots z$</p>
<p>然后我们假设现在通过最优策略进行删除操作，那么得到了这样一个东西：</p>
<ul>
<li>$x(p_1),y,z(p_2)$</li>
<li>$x$表示$y$的左边最小的数，得到他的代价为$p_1$</li>
<li>$z$表示$y$的右边最小的数，得到他的代价为$p_2$</li>
</ul>
<p>那么合并$x,y,z$的方案就有两种：</p>
<ul>
<li>先合并中间的$y$，总花费为：$cost=xyz+xz+\min(x,z)$</li>
<li>县合并两边，总花费为：$cost=xy+yz+min(x,y,z)$</li>
</ul>
<p>显然，$\min(x,y,z)\le\min(x,z)$，且$y(x+z)\le yxz$</p>
<p>所以可以证明，从每一段的两边开始取的答案一定最优</p>
<p>那么每一小段答案就可以记作</p>
<script type="math/tex; mode=display">
ans=\sum_{i=2}^nai*a_{i-1}+\min_{i=1}^na_i</script><p>最后加起来，再加上所有$1$的贡献，就可以了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a, b, minx, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;b.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;b.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        b = __read();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            a = b = <span class="number">0</span>;</span><br><span class="line">            ans += minx;</span><br><span class="line">            minx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a * b;</span><br><span class="line">        a = b;</span><br><span class="line">        <span class="keyword">if</span> (!minx || a &lt; minx) minx = a;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; ans + minx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-爆零题"><a href="#T3-爆零题" class="headerlink" title="T3(爆零题)"></a>T3(爆零题)</h1><p>就是说，可以把从$S\rightarrow T$的某条最短路上的边权改成$0$</p>
<p>然后问$X\rightarrow Y$的最短路径长度为多少</p>
<p>这道题是被欧歌爆砍$100$的</p>
<p>于是呢，我也是按照欧歌的改的</p>
<p>从$X\rightarrow Y$的路径长度，首先可以直接跑最短路</p>
<p>怎么处理$S\rightarrow T$的最短路边权为$0$呢？</p>
<p>看张图：</p>
<p><img src="https://i.loli.net/2020/09/25/zfekEoWrL6hGYHS.png" alt="q.png"></p>
<p>嗯，感觉就挺显然的了，就是看再$S\rightarrow T$的最短路径上的点到$X\rightarrow Y$的最短路径之和</p>
<p>就跑$3$次最短路即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid (l+r)/2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,x,y;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> e,next;</span><br><span class="line">	ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> e,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].e=e;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[s];</span><br><span class="line">	head[s]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll diss[N],dist[N],disy[N],disx[N];</span><br><span class="line">ll Minx[N],Miny[N],ans=INF;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> start,ll dis[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[start]=<span class="number">0</span>;q.<span class="built_in">push_front</span>(start);</span><br><span class="line">	vis[start]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop_front</span>();</span><br><span class="line">		vis[now]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> to=edge[i].e;</span><br><span class="line">			<span class="keyword">if</span>(dis[to]&gt;dis[now]+edge[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[to]=dis[now]+edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[to])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(q.<span class="built_in">empty</span>()||dis[q.<span class="built_in">front</span>()]&gt;dis[to]) q.<span class="built_in">push_front</span>(to);</span><br><span class="line">					<span class="keyword">else</span> q.<span class="built_in">push_back</span>(to);</span><br><span class="line">					vis[to]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> from,ll d1,ll d2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d1=<span class="built_in">min</span>(d1,disx[now]);</span><br><span class="line">	d2=<span class="built_in">min</span>(d2,disy[now]);</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,d1+d2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> to=edge[i].e;</span><br><span class="line">		<span class="keyword">if</span>(diss[now]==diss[to]+edge[i].w)</span><br><span class="line">			<span class="built_in">dfs</span>(to,now,d1,d2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v;ll w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="built_in">add</span>(u,v,w);</span><br><span class="line">		<span class="built_in">add</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(diss,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(diss));</span><br><span class="line">	<span class="built_in">memset</span>(disx,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(disx));</span><br><span class="line">	<span class="built_in">memset</span>(disy,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(disy));</span><br><span class="line">	<span class="built_in">SPFA</span>(s,diss);</span><br><span class="line">	<span class="built_in">SPFA</span>(x,disx);</span><br><span class="line">	<span class="built_in">SPFA</span>(y,disy);</span><br><span class="line">	<span class="built_in">dfs</span>(t,<span class="number">0</span>,INF,INF);</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,disx[y]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧歌牛逼！！！</p>
<h1 id="T4-退役题"><a href="#T4-退役题" class="headerlink" title="T4(退役题)"></a>T4(退役题)</h1><p>这，先贴一个$STD$，有题解的时候再回来看看吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ge getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Re read()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, ch;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = ge)) ;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = ge;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Base[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">240</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">Mod</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x % mod + mod) : (x &lt; mod ? x : (x &lt; (mod &lt;&lt; <span class="number">1</span>) ? x - mod : x % mod)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(T&amp;x, T y)</span> </span>&#123; x = <span class="built_in">Mod</span>(x + y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> pri[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> chk[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> Min[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> pw[<span class="number">310000</span>];</span><br><span class="line"><span class="type">int</span> fac[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> inv[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> ifac[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!chk[i]) pri[++tot] = i, Min[i] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i * pri[j] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">			chk[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">			Min[i * pri[j]] = pri[j];</span><br><span class="line">			<span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pw[<span class="number">0</span>] = fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = ifac[<span class="number">0</span>] = ifac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++) pw[i] = <span class="built_in">Mod</span>(pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">		fac[i] = <span class="built_in">Mod</span>(<span class="number">1LL</span> * fac[i - <span class="number">1</span>] * i);</span><br><span class="line">		inv[i] = <span class="built_in">Mod</span>(<span class="number">1LL</span> * (mod - mod / i) * inv[mod % i]);</span><br><span class="line">		ifac[i] = <span class="built_in">Mod</span>(<span class="number">1LL</span> * ifac[i - <span class="number">1</span>] * inv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!(v &amp; <span class="number">1</span>)) ++a[<span class="number">0</span>], v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">3</span> == <span class="number">0</span>) ++a[<span class="number">1</span>], v /= <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">5</span> == <span class="number">0</span>) ++a[<span class="number">2</span>], v /= <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">7</span> == <span class="number">0</span>) ++a[<span class="number">3</span>], v /= <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">11</span> == <span class="number">0</span>) ++a[<span class="number">4</span>], v /= <span class="number">11</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">13</span> == <span class="number">0</span>) ++a[<span class="number">5</span>], v /= <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">17</span> == <span class="number">0</span>) ++a[<span class="number">6</span>], v /= <span class="number">17</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">			a[i] = v % Base[i + <span class="number">1</span>] / Base[i];</span><br><span class="line">		a[<span class="number">6</span>] = v / Base[<span class="number">6</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Merge</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">			a[i] = <span class="built_in">max</span>(a[i], x.a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">			res += a[i] * Base[i];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Num[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> g[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> h[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> G[<span class="number">9</span>][<span class="number">6</span>][<span class="number">4</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> nu[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> mx[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> ct[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> Pw[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p, Node x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> v = x.<span class="built_in">val</span>();</span><br><span class="line">	<span class="keyword">if</span>(g[p][v]) <span class="keyword">return</span> f[p][v];</span><br><span class="line">	g[p][v] = <span class="number">1</span>; <span class="type">int</span>&amp;F = f[p][v];</span><br><span class="line">	<span class="keyword">if</span>(p == <span class="number">7</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a0 = <span class="number">0</span>; a0 &lt; <span class="number">9</span>; ++a0)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a1 = <span class="number">0</span>; a1 &lt; <span class="number">6</span>; ++a1)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a2 = <span class="number">0</span>; a2 &lt; <span class="number">4</span>; ++a2)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a3 = <span class="number">0</span>; a3 &lt; <span class="number">3</span>; ++a3)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a4 = <span class="number">0</span>; a4 &lt; <span class="number">3</span>; ++a4)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a5 = <span class="number">0</span>; a5 &lt; <span class="number">3</span>; ++a5)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a6 = <span class="number">0</span>; a6 &lt; <span class="number">3</span>; ++a6) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!G[a0][a1][a2][a3][a4][a5][a6]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> Prd = <span class="number">1</span>;</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">0</span>][<span class="built_in">max</span>(a0, x.a[<span class="number">0</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">1</span>][<span class="built_in">max</span>(a1, x.a[<span class="number">1</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">2</span>][<span class="built_in">max</span>(a2, x.a[<span class="number">2</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">3</span>][<span class="built_in">max</span>(a3, x.a[<span class="number">3</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">4</span>][<span class="built_in">max</span>(a4, x.a[<span class="number">4</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">5</span>][<span class="built_in">max</span>(a5, x.a[<span class="number">5</span>])]);</span><br><span class="line">			Prd = <span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * Pw[<span class="number">6</span>][<span class="built_in">max</span>(a6, x.a[<span class="number">6</span>])]);</span><br><span class="line">			F = <span class="built_in">Mod</span>(F + <span class="number">1LL</span> * G[a0][a1][a2][a3][a4][a5][a6] * Prd);</span><br><span class="line">		&#125; <span class="keyword">return</span> F;</span><br><span class="line">	&#125; F = <span class="built_in">solve</span>(p - <span class="number">1</span>, x); Node now, sta;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a0 = <span class="number">0</span>; a0 &lt;= mx[p][<span class="number">0</span>]; ++a0)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a1 = <span class="number">0</span>; a1 &lt;= mx[p][<span class="number">1</span>]; ++a1)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a2 = <span class="number">0</span>; a2 &lt;= mx[p][<span class="number">2</span>]; ++a2)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a3 = <span class="number">0</span>; a3 &lt;= mx[p][<span class="number">3</span>]; ++a3)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a4 = <span class="number">0</span>; a4 &lt;= mx[p][<span class="number">4</span>]; ++a4)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a5 = <span class="number">0</span>; a5 &lt;= mx[p][<span class="number">5</span>]; ++a5)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> a6 = <span class="number">0</span>; a6 &lt;= mx[p][<span class="number">6</span>]; ++a6) &#123;</span><br><span class="line">		sta.a[<span class="number">0</span>] = a0, sta.a[<span class="number">1</span>] = a1, sta.a[<span class="number">2</span>] = a2;</span><br><span class="line">		sta.a[<span class="number">3</span>] = a3, sta.a[<span class="number">4</span>] = a4, sta.a[<span class="number">5</span>] = a5;</span><br><span class="line">		sta.a[<span class="number">6</span>] = a6;</span><br><span class="line">		<span class="keyword">if</span>(!h[p][sta.<span class="built_in">val</span>()]) <span class="keyword">continue</span>;</span><br><span class="line">		now = x, now.<span class="built_in">Merge</span>(sta);</span><br><span class="line">		F = <span class="built_in">Mod</span>(F + <span class="number">1LL</span> * h[p][sta.<span class="built_in">val</span>()] * <span class="built_in">solve</span>(p - <span class="number">1</span>, now));</span><br><span class="line">	&#125; <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;d.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;d.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = Re; <span class="built_in">init</span>(<span class="number">300</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[Re];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) Num[i].<span class="built_in">init</span>(i);</span><br><span class="line">	Pw[<span class="number">0</span>][<span class="number">0</span>] = Pw[<span class="number">1</span>][<span class="number">0</span>] = Pw[<span class="number">2</span>][<span class="number">0</span>] = Pw[<span class="number">3</span>][<span class="number">0</span>] = Pw[<span class="number">4</span>][<span class="number">0</span>] = Pw[<span class="number">5</span>][<span class="number">0</span>] = Pw[<span class="number">6</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		Pw[<span class="number">0</span>][i] = <span class="built_in">Mod</span>(<span class="number">2LL</span> * Pw[<span class="number">0</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">1</span>][i] = <span class="built_in">Mod</span>(<span class="number">3LL</span> * Pw[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">2</span>][i] = <span class="built_in">Mod</span>(<span class="number">5LL</span> * Pw[<span class="number">2</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">3</span>][i] = <span class="built_in">Mod</span>(<span class="number">7LL</span> * Pw[<span class="number">3</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">4</span>][i] = <span class="built_in">Mod</span>(<span class="number">11LL</span> * Pw[<span class="number">4</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">5</span>][i] = <span class="built_in">Mod</span>(<span class="number">13LL</span> * Pw[<span class="number">5</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">6</span>][i] = <span class="built_in">Mod</span>(<span class="number">17LL</span> * Pw[<span class="number">6</span>][i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">		h[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">			<span class="type">int</span> p = pri[j + <span class="number">1</span>], prd = pri[i];</span><br><span class="line">			<span class="keyword">while</span>(prd * p &lt;= <span class="number">300</span>) ++mx[i][j], prd *= p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = pri[i]; j &lt;= <span class="number">300</span>; j += pri[i]) &#123;</span><br><span class="line">			<span class="type">int</span> Prd = pw[cnt[j]] - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!Prd) <span class="keyword">continue</span>;</span><br><span class="line">			vis[j] = <span class="number">1</span>; Node sta, tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">479</span>; ~s; s--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!h[i][s]) <span class="keyword">continue</span>;</span><br><span class="line">				sta.<span class="built_in">unlock</span>(s), sta.<span class="built_in">Merge</span>(Num[j]);</span><br><span class="line">				<span class="built_in">Add</span>(h[i][sta.<span class="built_in">val</span>()], <span class="built_in">int</span>(<span class="built_in">Mod</span>(<span class="number">1LL</span> * h[i][s] * Prd)));</span><br><span class="line">				sta = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; --h[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt; <span class="number">480</span>; s++)</span><br><span class="line">			h[i][s] = <span class="built_in">Mod</span>(<span class="number">1LL</span> * h[i][s] * pri[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	G[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">			<span class="type">int</span> Prd = pw[cnt[i]] - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!Prd) <span class="keyword">continue</span>;</span><br><span class="line">			Node sta; sta = Num[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a0 = <span class="number">8</span>; ~a0; --a0)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a1 = <span class="number">5</span>; ~a1; --a1)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a2 = <span class="number">3</span>; ~a2; --a2)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a3 = <span class="number">2</span>; ~a3; --a3)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a4 = <span class="number">2</span>; ~a4; --a4)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a5 = <span class="number">2</span>; ~a5; --a5)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a6 = <span class="number">2</span>; ~a6; --a6) &#123;</span><br><span class="line">				<span class="type">int</span> A0 = <span class="built_in">max</span>(a0, sta.a[<span class="number">0</span>]);</span><br><span class="line">				<span class="type">int</span> A1 = <span class="built_in">max</span>(a1, sta.a[<span class="number">1</span>]);</span><br><span class="line">				<span class="type">int</span> A2 = <span class="built_in">max</span>(a2, sta.a[<span class="number">2</span>]);</span><br><span class="line">				<span class="type">int</span> A3 = <span class="built_in">max</span>(a3, sta.a[<span class="number">3</span>]);</span><br><span class="line">				<span class="type">int</span> A4 = <span class="built_in">max</span>(a4, sta.a[<span class="number">4</span>]);</span><br><span class="line">				<span class="type">int</span> A5 = <span class="built_in">max</span>(a5, sta.a[<span class="number">5</span>]);</span><br><span class="line">				<span class="type">int</span> A6 = <span class="built_in">max</span>(a6, sta.a[<span class="number">6</span>]);</span><br><span class="line">				<span class="built_in">Add</span>(G[A0][A1][A2][A3][A4][A5][A6], <span class="built_in">int</span>(<span class="built_in">Mod</span>(<span class="number">1LL</span> * Prd * G[a0][a1][a2][a3][a4][a5][a6])));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(tot, Num[<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码不长，也就$200$行，溜了溜了</p>
<p>鸽着的啊~</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>鸽~</tag>
        <tag>最短路</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200929</title>
    <url>/AlanTuringLi/2020/09/29/T20200929/</url>
    <content><![CDATA[<h1 id="T1维护序列"><a href="#T1维护序列" class="headerlink" title="T1维护序列"></a>T1<a href="https://www.luogu.com.cn/problem/P2023">维护序列</a></h1><p>线段树二的板子题，没什么好说的吧。。。</p>
<blockquote>
<p>失算了，区间乘法可以乘$0$，我直接忽略了</p>
<p>对拍的时候，压根就没有生成$0$的数据，拍了好多组都没问题，结果。。。</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (x &lt;&lt; 1| 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p;</span><br><span class="line"><span class="type">int</span> tagt[maxn &lt;&lt; <span class="number">2</span>], tagp[maxn &lt;&lt; <span class="number">2</span>], ans[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x] = (ans[ls] + ans[rs]) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tagt[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans[x] = __read() % p;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Build</span>(l, mid, ls);</span><br><span class="line">    <span class="built_in">Build</span>(mid + <span class="number">1</span>, r, rs);</span><br><span class="line">    <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> valt, <span class="type">int</span> valp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x] = <span class="number">1ll</span> * ans[x] * valt % p;</span><br><span class="line">    ans[x] = (ans[x] + <span class="number">1ll</span> * valp * (r - l + <span class="number">1</span>) % p) % p;</span><br><span class="line">    tagp[x] = (<span class="number">1ll</span> * tagp[x] * valt % p + valp) % p;</span><br><span class="line">    tagt[x] = <span class="number">1ll</span> * tagt[x] * valt % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls, l, mid, tagt[x], tagp[x]);</span><br><span class="line">    <span class="built_in">f</span>(rs, mid + <span class="number">1</span>, r, tagt[x], tagp[x]);</span><br><span class="line">    tagt[x] = <span class="number">1</span>, tagp[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> valt, <span class="type">int</span> valp, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) &#123;</span><br><span class="line">        <span class="built_in">f</span>(x, l, r, valt, valp);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(x, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl &lt;= mid) <span class="built_in">update</span>(l, mid, tl, tr, valt, valp, ls);</span><br><span class="line">    <span class="keyword">if</span> (tr &gt; mid) <span class="built_in">update</span>(mid + <span class="number">1</span>, r, tl, tr, valt, valp, rs);</span><br><span class="line">    <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) <span class="keyword">return</span> ans[x] % p;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(x, l, r);</span><br><span class="line">    <span class="function">ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (tl &lt;= mid) res = <span class="built_in">Query</span>(l, mid, tl, tr, ls);</span><br><span class="line">    <span class="keyword">if</span> (tr &gt; mid) res = (res + <span class="built_in">Query</span>(mid + <span class="number">1</span>, r, tl, tr, rs)) % p;</span><br><span class="line">    <span class="keyword">return</span> res % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), p = __read();</span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> m = __read();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(<span class="number">1</span>, n, l, r) % p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = __read();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, n, l, r, <span class="number">1</span>, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x = __read();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, n, l, r, x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2公路修建"><a href="#T2公路修建" class="headerlink" title="T2公路修建"></a>T2<a href="https://www.luogu.com.cn/problem/P2323">公路修建</a></h1><p>最小生成树，其实我觉得应该排两次序才能保证答案的正确性</p>
<p>但就是过了，就不用管了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, id;</span><br><span class="line">    <span class="type">int</span> val[<span class="number">2</span>];</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;T) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[<span class="number">0</span>] ^ T.val[<span class="number">0</span>]) <span class="keyword">return</span> val[<span class="number">0</span>] &lt; T.val[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> val[<span class="number">1</span>] &lt; T.val[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OPT</span> &#123;</span><br><span class="line">    <span class="type">int</span> id, c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> OPT &amp;t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id &lt; t.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Ans[maxn], Tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">get_f</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> Tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].val[<span class="number">0</span>] &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get_f</span>(edge[i].u), fy = <span class="built_in">get_f</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        Tmp[++cnt] = &#123;edge[i].id, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].val[<span class="number">1</span>] &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get_f</span>(edge[i].u), fy = <span class="built_in">get_f</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        Tmp[++cnt] = &#123;edge[i].id, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf (&quot;%d\n&quot;, cnt);</span></span><br><span class="line">    <span class="keyword">return</span> cnt == (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), k = __read(), m = __read();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">30000</span>)</span>, ans</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        edge[i].u = __read(), edge[i].v = __read();</span><br><span class="line">        edge[i].val[<span class="number">0</span>] = __read(), edge[i].val[<span class="number">1</span>] = __read();</span><br><span class="line">        edge[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span> (edge + <span class="number">1</span>, edge + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(mid)) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(Ans, Tmp, <span class="built_in">sizeof</span> (Ans));</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">sort</span> (Ans + <span class="number">1</span>, Ans + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>, Ans[i].id, Ans[i].c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3三色二叉树"><a href="#T3三色二叉树" class="headerlink" title="T3三色二叉树"></a>T3<a href="https://www.luogu.com.cn/problem/P2585">三色二叉树</a></h1><p>看一眼就可以开始乱写的$Dp$</p>
<p>无脑乱搞即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> mx[maxn][<span class="number">3</span>], mn[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++id, size = s[p] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mx[p][<span class="number">0</span>] = mn[p][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        son[i] = <span class="built_in">dfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        mx[p][<span class="number">0</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">1</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">        mx[p][<span class="number">1</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>]);</span><br><span class="line">        mx[p][<span class="number">2</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mn[p][<span class="number">0</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">1</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">        mn[p][<span class="number">1</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>]);</span><br><span class="line">        mn[p][<span class="number">2</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</span><br><span class="line">        mx[p][<span class="number">0</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">1</span>] + mx[son[<span class="number">1</span>]][<span class="number">2</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>] + mx[son[<span class="number">1</span>]][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        mx[p][<span class="number">1</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">0</span>] + mx[son[<span class="number">1</span>]][<span class="number">2</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>] + mx[son[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">        mx[p][<span class="number">2</span>] = <span class="built_in">max</span>(mx[son[<span class="number">0</span>]][<span class="number">1</span>] + mx[son[<span class="number">1</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">0</span>] + mx[son[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mn[p][<span class="number">0</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">1</span>] + mn[son[<span class="number">1</span>]][<span class="number">2</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>] + mn[son[<span class="number">1</span>]][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        mn[p][<span class="number">1</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">0</span>] + mn[son[<span class="number">1</span>]][<span class="number">2</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>] + mn[son[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">        mn[p][<span class="number">2</span>] = <span class="built_in">min</span>(mn[son[<span class="number">0</span>]][<span class="number">1</span>] + mn[son[<span class="number">1</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">0</span>] + mn[son[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">max</span>(mx[<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(mx[<span class="number">1</span>][<span class="number">1</span>], mx[<span class="number">1</span>][<span class="number">2</span>])), <span class="built_in">min</span>(mn[<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">min</span>(mn[<span class="number">1</span>][<span class="number">1</span>], mn[<span class="number">1</span>][<span class="number">2</span>])));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4采花"><a href="#T4采花" class="headerlink" title="T4采花"></a>T4<a href="https://www.luogu.com.cn/problem/P4113">采花</a></h1><p>这个稍微难想一点点</p>
<p>画图吧</p>
<p><img src="https://s1.ax1x.com/2020/09/29/0e30kn.png" alt=""></p>
<p>那么就可以只维护左端点，然后感觉一下就完了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c, m, <span class="built_in">p</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> pre[maxn][<span class="number">2</span>], lst[maxn];</span><br><span class="line"><span class="type">int</span> sum[maxn], clo[maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        sum[x] += val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += sum[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), c = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        clo[i] = __read();</span><br><span class="line">        pre[i][<span class="number">0</span>] = lst[clo[i]];</span><br><span class="line">        pre[i][<span class="number">1</span>] = pre[pre[i][<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">        lst[clo[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        que[i].l = __read(), que[i].r = __read();</span><br><span class="line">        que[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span> (que + <span class="number">1</span>, que + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= que[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[p][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[p][<span class="number">1</span>]) <span class="built_in">update</span>(pre[p][<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">update</span>(pre[p][<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[que[i].id] = <span class="built_in">query</span>(que[i].r) - <span class="built_in">query</span>(que[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>二分</tag>
        <tag>数据结构</tag>
        <tag>生成树</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201109</title>
    <url>/AlanTuringLi/2020/11/09/T20201109/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-树上的数"><a href="#T1-树上的数" class="headerlink" title="T1(树上的数)"></a>T1(树上的数)</h1><p>直观感觉是 $\text{DFS}$ 序 + 线段树，时间复杂度 $O(m\log n)$，然后常数大的一批，$\text{T}$ 成 $60$ 分。</p>
<p>其实吧，可以直接每次暴力遍历整棵树，给一个永久标记即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (x &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, cur, tot;</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn], nxt[maxn];</span><br><span class="line"><span class="type">bool</span> have[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (have[u]) <span class="keyword">return</span>;</span><br><span class="line">	--tot, have[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i])</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), <span class="built_in">pf</span>(<span class="number">1</span>);</span><br><span class="line">	tot = n;</span><br><span class="line">	<span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		pf = ((<span class="number">1ll</span> * pf * a + b) ^ <span class="number">19760817</span>) % (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">addedge</span>(pf, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> q = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(q);</span><br><span class="line">		ans ^= tot;</span><br><span class="line">		q = (((<span class="number">1ll</span> * q * x + y) ^ <span class="number">19760817</span>) ^ (i + <span class="number">1</span> &lt;&lt; <span class="number">1</span>)) % (n - <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2-时代的眼泪"><a href="#T2-时代的眼泪" class="headerlink" title="T2(时代的眼泪)"></a>T2(时代的眼泪)</h1><p>首先交换求和顺序，然后就可以发现诸多有用的性质。</p>
<h2 id="算法一-25分"><a href="#算法一-25分" class="headerlink" title="算法一 (25分)"></a>算法一 (25分)</h2><p>就是每次暴力查询，单次查询的时间复杂度为 $O(n\log n)$。</p>
<p>就是可以用树状数组维护，这一条链有多少个点的权值严格大于当前点，然后就可以加入贡献了。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root, t[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    t[x] += val;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    res += t[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add</span> (val[u], <span class="number">1</span>);</span><br><span class="line">  ans += dep - <span class="built_in">query</span>(val[u]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (edge[i] == v) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(edge[i], u, dep + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">add</span> (val[u], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    root = <span class="built_in">read</span>(), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="算法二-20分"><a href="#算法二-20分" class="headerlink" title="算法二 (20分)"></a>算法二 (20分)</h2><p>整张图是一个 $1\sim n$ 的链，所以每个点的贡献是一定的，就可以 $O(n\log n)$ 预处理出所有点贡献，做两次前缀和就可以了。</p>
<p>结合算法一，就可以获得 $45$ 分的好成绩。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root, ans;</span><br><span class="line">ll l[maxn], r[maxn];</span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    t[x] += val;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    res += t[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span> (l, <span class="number">0</span>, <span class="keyword">sizeof</span> l);</span><br><span class="line">  <span class="built_in">memset</span> (r, <span class="number">0</span>, <span class="keyword">sizeof</span> r);</span><br><span class="line">  <span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    l[i] = l[i - <span class="number">1</span>] + <span class="built_in">query</span>(val[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(val[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i; --i) &#123;</span><br><span class="line">    r[i] = r[i + <span class="number">1</span>] + <span class="built_in">query</span>(val[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(val[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    root = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, l[root] + r[root]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="算法三-20分"><a href="#算法三-20分" class="headerlink" title="算法三 (20分)"></a>算法三 (20分)</h2><p>就是一个以 $1$ 为中心的一个菊花图，这个手摸一下就可以发现，我们可以 $O(n)$，预处理出 $1$ 作为根时的答案，然后在考虑根变成其他的时候的答案变化量，这个变化量的处理单词时间复杂度是 $O(\log n)$。</p>
<p>结合算法一、算法二就可以取得 $65$ 分的好成绩。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root, ans, <span class="built_in">jub</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    t[x] += val;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    res += t[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (val[<span class="number">1</span>] &gt; val[i]) ++jub;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">add</span>(val[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    root = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (val[root] &lt; val[<span class="number">1</span>]) --jub;</span><br><span class="line">    <span class="keyword">if</span> (root &gt; <span class="number">1</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, jub + <span class="built_in">query</span>(val[root] - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, jub);</span><br><span class="line">    <span class="keyword">if</span> (val[root] &lt; val[<span class="number">1</span>]) ++jub;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="About-80"><a href="#About-80" class="headerlink" title="About 80"></a>About 80</h2><p>就是 $Q=1$ 时，可以用算法一，这样一来就可以拿到 $80$ 分的好成绩</p>
<p>我考场就是 $Q=1$ 判错了就只有 $65$。。。</p>
<p>所以个人认为这道题十分的良心，给足了部分分，整整 $80$。</p>
<h2 id="About-100"><a href="#About-100" class="headerlink" title="About 100"></a>About 100</h2><p>这其实是一个换根 $dp$，看上去也很像一个换根 $dp$，可惜当时就是没有推出来。</p>
<p>就是考虑，从一个根到另一个根，它少了些什么，它又该多一些什么。</p>
<p><img src="https://s1.ax1x.com/2020/11/10/BL8FUI.png" alt=""></p>
<center>&dArr;</center>

<p><img src="https://s1.ax1x.com/2020/11/10/BL8iVA.png" alt=""></p>
<p>可以发现，少的那一部分是现在的根对原来的根的贡献，而多的那一部分则是原来的根作为子树对现在的根的贡献。</p>
<p>首先，声明几个数组</p>
<ul>
<li>$f_i$ 表示在以 $i$ 为根的子树中，有多少个点的点权严格小于当前节点</li>
<li>$g_i$ 表示在以 $i$ 为根的子树中，有多少个点的点权严格小于当前节点的父亲</li>
<li>$k_i$ 表示在所有的点里面，有多少个点的点权严格小于当前节点</li>
</ul>
<p>所有可以有如下转移：</p>
<script type="math/tex; mode=display">
ans_v = ans_u - g_v + k_v - f_v;</script><p>然后 $f、g$ 的求法是十分的巧妙，它可以类似查分的形式出现，所以这道题就结束了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m, q, cur, fa[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn], g[maxn], k[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line">ll ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x &lt;= m) &#123;</span><br><span class="line">		t[x] += val;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		res += t[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pre = <span class="built_in">query</span>(a[u] - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">add</span>(a[u], <span class="number">1</span>);</span><br><span class="line">	f[u] = -pre, fa[u] = father;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == father) <span class="keyword">continue</span>;</span><br><span class="line">		g[edge[i]] = -pre;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">		pre = <span class="built_in">query</span>(a[u] - <span class="number">1</span>);</span><br><span class="line">		g[edge[i]] += pre;</span><br><span class="line">	&#125;</span><br><span class="line">	f[u] += pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u], v; i; i = nxt[i]) &#123;</span><br><span class="line">		v = edge[i];</span><br><span class="line">		<span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		ans[v] = ans[u] - g[v] + k[v] - f[v];</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tears.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tears.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		a[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span> (b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">	m = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>, a[i]) - b;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> u, v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		u =  <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		k[i] = <span class="built_in">query</span>(a[i] - <span class="number">1</span>), ans[<span class="number">1</span>] += f[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (q--) <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="built_in">read</span>()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T3-传统艺能"><a href="#T3-传统艺能" class="headerlink" title="T3(传统艺能)"></a>T3(传统艺能)</h1><p>考场暴力 $25$，还行吧</p>
<p>就是考虑这么一个矩阵 $A_{i,j}$ 表示以 $i$ 开头以 $j$ 结尾的方案数，但是这个 $j$ 其实是不存在的。</p>
<p>所以当两个矩阵相乘的时候，刚好就表示了这个方案的转移，所以可以用线段树来维护，每一个节点就是一个矩阵，就这样结束了。</p>
<p>至于为什么它能保证本质不同呢？</p>
<p>这个与矩阵乘法的性质有关，就不赘述了。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fp(i,l,r) for(register int (i)=(l);i&lt;=(r);++(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,l,r) for(register int (i)=(l);i&gt;=(r);--(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fe(i,u) for(register int (i)=front[(u)];(i);(i)=e[(i)].next)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a) memset((a),0,sizeof (a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&#x27;:&#x27;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wr</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">wr</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>+x%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll MAXN=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tmod</span><span class="params">(ll &amp;x)</span></span>&#123;x%=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rmod</span><span class="params">(ll &amp;x)</span></span>&#123;x+=x&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span>&#123;</span><br><span class="line">	ll a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">inline</span> Mat <span class="keyword">operator</span> *(<span class="type">const</span> Mat &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">		Mat c;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> V(x) a[i][(x)]*b.a[(x)][j]</span></span><br><span class="line">		c.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="built_in">fp</span>(i,<span class="number">1</span>,<span class="number">3</span>)c.a[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fp</span>(i,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">		<span class="built_in">fp</span>(j,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">		<span class="built_in">tmod</span>(c.a[i][j]=<span class="built_in">V</span>(<span class="number">0</span>)+<span class="built_in">V</span>(<span class="number">1</span>)+<span class="built_in">V</span>(<span class="number">2</span>)+<span class="built_in">V</span>(<span class="number">3</span>));</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;val[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson o&lt;&lt;1|1</span></span><br><span class="line"><span class="function">Mat <span class="title">ask</span><span class="params">(ll o,ll l,ll r,ll ql,ll qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql==l&amp;&amp;qr==r)<span class="keyword">return</span> val[o];</span><br><span class="line">	ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">ask</span>(lson,l,mid,ql,qr);</span><br><span class="line">	<span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">ask</span>(rson,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask</span>(lson,l,mid,ql,mid)*<span class="built_in">ask</span>(rson,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mdy</span><span class="params">(ll o,ll l,ll r,ll p,ll v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">mem</span>(val[o].a);</span><br><span class="line">		<span class="built_in">fp</span>(i,<span class="number">0</span>,<span class="number">3</span>)val[o].a[i][i]=val[o].a[v][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=mid)<span class="built_in">mdy</span>(lson,l,mid,p,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">mdy</span>(rson,mid+<span class="number">1</span>,r,p,v);</span><br><span class="line">	val[o]=val[lson]*val[rson];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[MAXN],ss[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll o,ll l,ll r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		ll v=s[l]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fp</span>(i,<span class="number">0</span>,<span class="number">3</span>)val[o].a[i][i]=val[o].a[v][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(lson,l,mid);<span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">	val[o]=val[lson]*val[rson];</span><br><span class="line">&#125;</span><br><span class="line">ll n,Q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;string.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;string.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();Q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">		ll op=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			ll p=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">			<span class="built_in">mdy</span>(<span class="number">1</span>,<span class="number">1</span>,n,p,ss[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ll l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();Mat t=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">			ll res=<span class="number">0</span>;<span class="built_in">fp</span>(i,<span class="number">1</span>,<span class="number">3</span>)<span class="built_in">tmod</span>(res+=t.a[i][<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">wr</span>(res);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Dp优化</tag>
        <tag>树型Dp</tag>
        <tag>数据结构</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201111</title>
    <url>/AlanTuringLi/2020/11/11/T20201111/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>考虑容斥，就是从一个数集选三个数，然后不断减去不合法的方案的贡献即可。</p>
<p>然后容斥系数的话，就是二进制下与那个数相差了的 $1$ 个数的奇偶性，也就是 $(-1)^k$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">256</span>;</span><br><span class="line"><span class="type">int</span> tmp, cnt[maxn];</span><br><span class="line"><span class="type">int</span> sum[maxn][maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;select.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;select.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxm; ++i) cnt[i] = cnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		tmp = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxm; ++j) </span><br><span class="line">			sum[i][j] = sum[i - <span class="number">1</span>][j] + ((tmp &amp; j) == tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l, r, x;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxm; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i &amp; x) ^ i) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> cf = cnt[x] - cnt[i];</span><br><span class="line">			<span class="keyword">if</span> (cf &amp; <span class="number">1</span>) res -= <span class="built_in">calc</span>(sum[r][i] - sum[l - <span class="number">1</span>][i]);</span><br><span class="line">			<span class="keyword">else</span> res += <span class="built_in">calc</span>(sum[r][i] - sum[l - <span class="number">1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>考场降智了。。。</p>
<p>先说说考场傻逼做法。</p>
<p>就是“很显然”可以得到这样一个方程：</p>
<script type="math/tex; mode=display">
\frac{n-al}{a+1}=\frac{m-bl}{b+1}</script><p>然后就可以一同化简猛如虎：</p>
<script type="math/tex; mode=display">
\begin{aligned}
nb+n\cancel{-abl}-al&=am+m\cancel{-abl}-bl\\
n + nb - al &= m + ma - bl\\
nb + bl -ma-al&=m-n\\
b(n+l)-a(m+l)&=m-n
\end{aligned}</script><p>所以这个 $a,b$ 就是一行/一列放几块。</p>
<p>然后就是不定方程，先要化成正整数，然后慢慢靠近合法的值域，细节很多。</p>
<p>最后因为没有判 $l&lt;n \text{ and } l&lt;m$，于是只拿到了 $96$ 分的好成绩。。。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> gcd = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;place.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;place.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	ll l = <span class="built_in">read</span>(), n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), x, y;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; n) <span class="built_in">swap</span> (n, m);</span><br><span class="line">	ll gcd = <span class="built_in">exgcd</span>(l + n, l + m, x, y);</span><br><span class="line">	<span class="keyword">if</span> ((m - n) % gcd || n &lt; l || m &lt; l) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">	y = -y;</span><br><span class="line">	ll a = (l + n) / gcd, b = (l + m) / gcd;</span><br><span class="line">	x *= (m - n) / gcd, y *= (m - n) / gcd;</span><br><span class="line">	ll times = <span class="built_in">min</span>((m / l - x) / b, (n / l - y) / a);</span><br><span class="line">	x += times * b, y += times * a;</span><br><span class="line">	<span class="keyword">while</span> ((x + b) * l &lt;= m &amp;&amp; (y + a) * l &lt;= n) </span><br><span class="line">		x += b, y += a;</span><br><span class="line">	<span class="keyword">while</span> (x * l &gt; m || y * l &gt; n) &#123;</span><br><span class="line">		x -= b, y -= a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%.5f\n&quot;</span>, <span class="built_in">double</span>(n - y * l) / (y + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div> 
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>首先要看懂题，然后按照题意贪心的模拟就可以了。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[maxn], p[maxn], k[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">char</span> o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x ^= y;</span><br><span class="line">	y ^= x;</span><br><span class="line">	x ^= y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;sort.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;sort.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) p[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) k[i] = i;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(n)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> rnk = p[i % m] % (n - i);</span><br><span class="line">			rnk += l;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (k[rnk] == t) &#123;</span><br><span class="line">				a[t] = l;</span><br><span class="line">				<span class="built_in">swap</span> (k[rnk], k[l]);</span><br><span class="line">				++l;</span><br><span class="line">				<span class="keyword">while</span> (a[t]) ++t;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				a[k[rnk]] = r;</span><br><span class="line">				<span class="built_in">swap</span> (k[rnk], k[l]);</span><br><span class="line">				<span class="built_in">swap</span> (k[l], k[r]);</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>看题解吧。。。</p>
<h2 id="Code-40"><a href="#Code-40" class="headerlink" title="Code(40)"></a>Code(40)</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>,f = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">1</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> ch[N][N], S[N], t[N];</span><br><span class="line"><span class="type">int</span> n, Q, s[N], nxt[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span> *a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="built_in">strlen</span>(a + <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; t[j + <span class="number">1</span>] != a[i]) j = nxt[j];</span><br><span class="line">		<span class="keyword">if</span>(t[j + <span class="number">1</span>] == a[i]) j++;</span><br><span class="line">		<span class="keyword">if</span>(j == top) &#123;</span><br><span class="line">			j = nxt[j];</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;statistics.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;statistics.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>(), Q = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;Q);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,S + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">		top = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) t[++top] = S[i];</span><br><span class="line">		nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = <span class="number">0</span>; t[top + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(j &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = nxt[j];</span><br><span class="line">			<span class="keyword">if</span>(t[j + <span class="number">1</span>] == t[i]) j++;</span><br><span class="line">			nxt[i] = j;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) s[i] = <span class="built_in">kmp</span>(ch[i]);</span><br><span class="line">		<span class="built_in">nth_element</span>(s + <span class="number">1</span>, s + k, s + n + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        STD
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LG = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> ed[N + <span class="number">5</span>],len[N + <span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> s[N + <span class="number">5</span>],t[N + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ans[Q + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">namespace</span> SEG</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rs (ls | 1)</span></span><br><span class="line">    <span class="type">int</span> seg[(N &lt;&lt; <span class="number">3</span>) + <span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> p,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        seg[p] += k;</span><br><span class="line">        <span class="keyword">if</span>(tl == tr)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        x &lt;= mid ? <span class="built_in">insert</span>(x,k,ls,tl,mid) : <span class="built_in">insert</span>(x,k,rs,mid + <span class="number">1</span>,tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tl == tr)</span><br><span class="line">            <span class="keyword">return</span> tl;</span><br><span class="line">        <span class="type">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = seg[ls];</span><br><span class="line">        <span class="keyword">return</span> k &lt;= sum ? <span class="built_in">query</span>(k,ls,tl,mid) : <span class="built_in">query</span>(k - sum,rs,mid + <span class="number">1</span>,tr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SAM</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ch[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> fa,len;</span><br><span class="line">    &#125; sam[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> las = <span class="number">1</span>,tot = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c[N + <span class="number">5</span>],a[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> sz[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>],son[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; edp[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sam[las].ch[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = las,q = sam[cur].ch[x];</span><br><span class="line">            <span class="keyword">if</span>(sam[cur].len + <span class="number">1</span> == sam[q].len)</span><br><span class="line">                las = q,++sz[las],edp[las].<span class="built_in">push_back</span>(pos);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nxt = ++tot;</span><br><span class="line">                sam[nxt] = sam[q],sam[nxt].len = sam[cur].len + <span class="number">1</span>,sam[q].fa = nxt;</span><br><span class="line">                <span class="keyword">for</span>(;cur &amp;&amp; sam[cur].ch[x] == q;cur = sam[cur].fa)</span><br><span class="line">                    sam[cur].ch[x] = nxt;</span><br><span class="line">                las = nxt,++sz[las],edp[las].<span class="built_in">push_back</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = las,p = ++tot;</span><br><span class="line">        sam[p].len = sam[cur].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;cur &amp;&amp; !sam[cur].ch[x];cur = sam[cur].fa)</span><br><span class="line">            sam[cur].ch[x] = p;</span><br><span class="line">        <span class="keyword">if</span>(!cur)</span><br><span class="line">            sam[p].fa = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q = sam[cur].ch[x];</span><br><span class="line">            <span class="keyword">if</span>(sam[cur].len + <span class="number">1</span> == sam[q].len)</span><br><span class="line">                sam[p].fa = q;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nxt = ++tot;</span><br><span class="line">                sam[nxt] = sam[q],sam[nxt].len = sam[cur].len + <span class="number">1</span>,sam[p].fa = sam[q].fa = nxt;</span><br><span class="line">                <span class="keyword">for</span>(;cur &amp;&amp; sam[cur].ch[x] == q;cur = sam[cur].fa)</span><br><span class="line">                    sam[cur].ch[x] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        las = p,++sz[las],edp[las].<span class="built_in">push_back</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> to[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>],pre[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>],first[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        to[++tot] = v,pre[tot] = first[u],first[u] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> f[LG + <span class="number">5</span>][(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;++i)</span><br><span class="line">            ++c[sam[i].len],i &gt; <span class="number">1</span> &amp;&amp; (<span class="built_in">add</span>(f[<span class="number">0</span>][i] = sam[i].fa,i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= LG;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j = <span class="number">2</span>;j &lt;= tot;++j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][j]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= N;++i)  </span><br><span class="line">            c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = tot;i &gt; <span class="number">1</span>;--i)</span><br><span class="line">            a[c[sam[i].len]--] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = tot;i &gt; <span class="number">1</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            sz[sam[a[i]].fa] += sz[a[i]];</span><br><span class="line">            <span class="keyword">if</span>(!son[sam[a[i]].fa] || sz[son[sam[a[i]].fa]] &lt; sz[a[i]])</span><br><span class="line">                son[sam[a[i]].fa] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sam[p].len &lt; d)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = LG;~i;--i)</span><br><span class="line">            <span class="keyword">if</span>(f[i][p] &amp;&amp; sam[f[i][p]].len &gt;= d)</span><br><span class="line">                p = f[i][p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; qry[(N &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> cnt[N + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = first[p];i;i = pre[i])</span><br><span class="line">            <span class="keyword">if</span>(to[i] ^ son[p])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(to[i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">register</span> vector&lt;<span class="type">int</span>&gt;::iterator it = edp[to[i]].<span class="built_in">begin</span>();it != edp[to[i]].<span class="built_in">end</span>();++it)</span><br><span class="line">                    SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,N),--cnt[*it],SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,N);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(son[p])</span><br><span class="line">            <span class="built_in">dfs</span>(son[p]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> vector&lt;<span class="type">int</span>&gt;::iterator it = edp[p].<span class="built_in">begin</span>();it != edp[p].<span class="built_in">end</span>();++it)</span><br><span class="line">            SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,N),++cnt[*it],SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,N);</span><br><span class="line">        <span class="keyword">if</span>(son[p])</span><br><span class="line">        &#123;</span><br><span class="line">            edp[p].<span class="built_in">swap</span>(edp[son[p]]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> vector&lt;<span class="type">int</span>&gt;::iterator it = edp[son[p]].<span class="built_in">begin</span>();it != edp[son[p]].<span class="built_in">end</span>();++it)</span><br><span class="line">                edp[p].<span class="built_in">push_back</span>(*it);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(edp[son[p]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = first[p];i;i = pre[i])</span><br><span class="line">            <span class="keyword">if</span>(to[i] ^ son[p])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">register</span> vector&lt;<span class="type">int</span>&gt;::iterator it = edp[to[i]].<span class="built_in">begin</span>();it != edp[to[i]].<span class="built_in">end</span>();++it)</span><br><span class="line">                    edp[p].<span class="built_in">push_back</span>(*it),</span><br><span class="line">                    SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,N),++cnt[*it],SEG::<span class="built_in">insert</span>(cnt[*it],<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;::iterator it = qry[p].<span class="built_in">begin</span>();it != qry[p].<span class="built_in">end</span>();++it)</span><br><span class="line">            ans[it-&gt;second] = SEG::<span class="built_in">query</span>(it-&gt;first,<span class="number">1</span>,<span class="number">0</span>,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;q,s + <span class="number">1</span>),m = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t),SAM::las = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">char</span> *c = t;*c;SAM::<span class="built_in">insert</span>(*c++ - <span class="string">&#x27;a&#x27;</span>,i));</span><br><span class="line">    &#125;</span><br><span class="line">    SAM::<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>,x,p = <span class="number">1</span>,l = <span class="number">0</span>;i &lt;= m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(SAM::sam[p].ch[x])</span><br><span class="line">            p = SAM::sam[p].ch[x],++l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; !SAM::sam[p].ch[x];p = SAM::sam[p].fa);</span><br><span class="line">            !p ? (p = <span class="number">1</span>,l = <span class="number">0</span>) : (l = SAM::sam[p].len + <span class="number">1</span>,p = SAM::sam[p].ch[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        ed[i] = p,len[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k),</span><br><span class="line">        len[r] &gt;= r - l + <span class="number">1</span> &amp;&amp; (SAM::qry[SAM::<span class="built_in">get</span>(ed[r],r - l + <span class="number">1</span>)].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(k,i)),<span class="number">1</span>);</span><br><span class="line">    SEG::<span class="built_in">insert</span>(<span class="number">0</span>,n,<span class="number">1</span>,<span class="number">0</span>,N),SAM::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>数论</tag>
        <tag>考试</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201112</title>
    <url>/AlanTuringLi/2020/11/12/T20201112/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>就是考虑中位数这个东西该怎么处理。</p>
<p>那么就可以指定某一个数作为中位数，看它是否能够贡献答案，然后就可以先按权值排一次序，然后把时间插入到主席树里面，然后就可以查询到最优的时间，然后这道题就做完了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MX = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q, cnt, ans[maxn], root[maxn];</span><br><span class="line"><span class="type">int</span> ls[maxn &lt;&lt; <span class="number">5</span>], rs[maxn &lt;&lt; <span class="number">5</span>], sz[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">ll sm[maxn &lt;&lt; <span class="number">5</span>], T;</span><br><span class="line">pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pre = x;</span><br><span class="line">	x = ++cnt;</span><br><span class="line">	sz[x] = sz[pre] + <span class="number">1</span>;</span><br><span class="line">	sm[x] = sm[pre] + p;</span><br><span class="line">	ls[x] = ls[pre], rs[x] = rs[pre];</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (p &lt;= mid) <span class="built_in">insert</span>(ls[x], l, mid, p);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(rs[x], mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">1ll</span> * l * k;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lsz = sz[ls[tr]] - sz[ls[tl]];</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= lsz) <span class="keyword">return</span> <span class="built_in">query</span>(ls[tl], ls[tr], l, mid, k);</span><br><span class="line">	<span class="keyword">return</span> sm[ls[tr]] - sm[ls[tl]] + <span class="built_in">query</span>(rs[tl], rs[tr], mid + <span class="number">1</span>, r, k - lsz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;treasure.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;treasure.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">read</span>(), T = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i].first = <span class="built_in">read</span>(), a[i].second = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(root[i] = root[i - <span class="number">1</span>], <span class="number">0</span>, MX, a[i].second);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (n - <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">		ans[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (p = <span class="built_in">min</span>(p, n - i); p &gt; i; --p) &#123;</span><br><span class="line">			ll t = <span class="built_in">query</span>(root[<span class="number">0</span>], root[p - <span class="number">1</span>], <span class="number">0</span>, MX, i) + <span class="built_in">query</span>(root[p], root[n], <span class="number">0</span>, MX, i) + a[p].second;				</span><br><span class="line">			<span class="keyword">if</span> (t &lt;= T) &#123;</span><br><span class="line">				ans[i] = a[p].first;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans[<span class="built_in">read</span>() / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>就是说，对于一定深度，一定权值的所有点，显然是先走 $0$ 边，再走 $1$ 边更优。</p>
<p>那么先把所有的前导零处理了，然后就是按照上面的贪心来就可以了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, cur[<span class="number">2</span>], dis[maxn];</span><br><span class="line"><span class="type">int</span> head[<span class="number">2</span>][maxn], edge[<span class="number">2</span>][maxn], next[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="type">int</span> q[maxn], tmp[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	next[w][++cur[w]] = head[w][u];</span><br><span class="line">	head[w][u] = cur[w];</span><br><span class="line">	edge[w][cur[w]] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">char</span> o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;path.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;path.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> u, v, w, tot;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	vis[<span class="number">1</span>] = q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		u = q[l++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[<span class="number">0</span>][u]; i; i = next[<span class="number">0</span>][i])</span><br><span class="line">			<span class="keyword">if</span> (!vis[edge[<span class="number">0</span>][i]]) &#123;</span><br><span class="line">				vis[edge[<span class="number">0</span>][i]] = <span class="number">1</span>;</span><br><span class="line">				q[++r] = edge[<span class="number">0</span>][i];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r &amp;&amp; dis[q[i]] == dis[q[l]]; ++i)</span><br><span class="line">			tmp[++tot] = q[i];</span><br><span class="line">		l += tot;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">				u = tmp[j];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = head[k][u]; i; i = next[k][i]) </span><br><span class="line">				<span class="keyword">if</span> (!vis[edge[k][i]]) &#123;</span><br><span class="line">						vis[edge[k][i]] = <span class="number">1</span>;</span><br><span class="line">						dis[edge[k][i]] = (<span class="number">2ll</span> * dis[u] + k) % mod;</span><br><span class="line">						q[++r] = edge[k][i];</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>T20201113</title>
    <url>/AlanTuringLi/2020/11/13/T20201113/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>显然，两边的差距要越大最后的答案才能最优。</p>
<p>这个就不用证明了。</p>
<p>然后就是二分答案就可以了，然后我的二分是挂了的，所以最后要对答案进行一个微调，然后就可以过了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll ans, n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * p * (p - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">C</span>(p) &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == p) <span class="keyword">return</span> <span class="built_in">C</span>(p) == k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * <span class="built_in">C</span>(p) + <span class="number">1ll</span> * p * (n - p) &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;game.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;game.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span> || <span class="built_in">C</span>(n) &lt; k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (k &lt; n) ans = <span class="built_in">C</span>(n - <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function">ll <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(n)</span>, <span class="title">pr</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">pl</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">C</span>(mid) &lt;= k) pr = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	l = <span class="number">1</span>, r = pr;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) pr = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mid &lt;= (<span class="number">1</span> + n) / <span class="number">2</span>) l = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	l = <span class="number">2</span>, r = pr;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) pl = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">check</span>(pr + <span class="number">1</span>)) pr++;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">check</span>(pl - <span class="number">1</span>)) pl--;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">max</span>(<span class="built_in">C</span>(pl) + <span class="built_in">C</span>(n - pl), <span class="built_in">C</span>(pr) + <span class="built_in">C</span>(n - pr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>特别妙的一题。</p>
<p>依次考虑每个字符串的所属，假设当前考虑到第 <code>i</code> 个字符串，那么前 <code>i - 1</code> 个字符已经被分为了两个字序列，显然 <code>a[i - 1]</code> 是某个子序列的末尾，或者说每次考虑的最后一个字符串必然为一个子序列的末尾，假设另一个序列末尾为 <code>a[j]</code> ，若 <code>a[i]</code> 跟在 <code>a[i - 1]</code> 后面，那么 <code>a[j]</code> 依旧是另一个子序列的末尾，若 <code>a[i]</code> 跟在 <code>a[i-1]</code> 后面，那么 <code>a[i - 1]</code> 变成另一个序列的末尾，故不需要考虑另一个序列具体是哪一个字符串， 只需要知道另一个序列末尾的状态即可。</p>
<p>以 <code>f[i][j][k]</code> 表示前 $i$ 个字符串分好后，不以 <code>a[i]</code> 为结尾的字序列后 $j$ 位状态位 $k$ 时 $S$ 的最小值，那么根据 <code>a[i]</code> 的所属有转移：</p>
<ol>
<li><p>若 <code>a[i]</code> 跟在 <code>a[i - 1]</code> 后面，那么另一个序列后 $j$ 位的状态都不会改变，此时对 $S$ 值的影响位 <code>a[i - 1]</code> 接上 <code>a[i]</code> 所增长的串长，也即 $f[i][j][k]+=len-deal(a_{i-1},a_i)$，其中 $len$ 为每个字符串的串长，$deal(x,y)$ 表示求出 $x$  的后缀与 $y$ 的前缀的最长公共部分。</p>
</li>
<li><p>若 <code>a[i]</code> 跟在另一个序列后面，那么此时的所谓的另一个序列变成以 <code>a[i - 1]</code> 结尾，那么其末尾 $j$ 位状态即为 <code>a[i - 1]</code> 后 $j$ 位的状态，记为 $suf(a_{i-1},j)$，而此时对 $S$ 值的影响是将 <code>a[i]</code> 姐在了另一个字序列上，枚举另一个字序列末尾与 <code>a[i]</code> 的公共部分的长度 $k$ 有转移：</p>
<script type="math/tex; mode=display">
f[i][j][suf(a_{i-1},j)]=\min_{k}(f[i-1[k][pre(a_i,k)]]+len-k)</script></li>
</ol>
<p>其中 $pre(a_i,j)$ 表示 <code>a[i]</code> 的前 $j$ 位状态。</p>
<p>此时转移和复杂度为 $O(n\cdot len\cdot 2^{len})$，但注意到，记 $temp=len-deal(a_{i-1},a_i)$，则第二种转移等价于：</p>
<script type="math/tex; mode=display">
f[i][j][suf(a_{i-1},j)]=\min_k(f[i-1][k][pre(a_i,k)]+len-k-temp)+temp</script><p>如此每次从 $f[i-1]$ 转移到 $f[i]$ 都会加上 $temp$ 这一定值，若在转移中不考虑该定制，而是累加该值在转移结束后直接加到答案中，那么就不需要进行第一种转移，此时时间复杂度为 $O(n\cdot len)$。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, len, val[maxn], f[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S &gt;&gt; (len - i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">suf</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S &amp; ((<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">deal</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len; i; --i) </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">suf</span>(S, i) == <span class="built_in">pre</span>(T, i)) <span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;puzzle.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;puzzle.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		len = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; len; ++j)</span><br><span class="line">			val[i] = (val[i] &lt;&lt; <span class="number">1</span>) + (s[j] ^ <span class="number">48</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> l = len - <span class="built_in">deal</span>(val[i - <span class="number">1</span>], val[i]);</span><br><span class="line">		res += l;</span><br><span class="line">		<span class="type">int</span> mn = inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j) mn = <span class="built_in">min</span>(mn, f[j][<span class="built_in">pre</span>(val[i], j)] + len - j - l);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j) f[j][<span class="built_in">suf</span>(val[i - <span class="number">1</span>], j)] = <span class="built_in">min</span>(f[j][<span class="built_in">suf</span>(val[i - <span class="number">1</span>], j)], mn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>][<span class="number">0</span>] + res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>就是最后的序列显然是递增的，所以可以二分答案。</p>
<p>现在问题就可以转化为：满足区间中位数不超过 $x$ 的区间数量，就可以二分 $x$。</p>
<p>定义 $p$ 数组，满足 <code>p[i] = p[i - 1] + [a[i] &gt; x]</code>，即前 $i$ 个数中有多少个数超过了 $x$。</p>
<p>那么如果一个序列满足条件，就可以转化为满足这个条件的式子：<code>r - l &gt; ((p[r] - p[l]) &lt;&lt; 1)</code>。</p>
<p>注意，这里是严格大于。</p>
<p>这个式子的意思就是：这个区间中，大于 $x$ 的树不会到达一半。</p>
<p>然后在稍微转化一下就是：<code>(r - (p[r] &lt;&lt; 1)) &gt; (l - (p[l] &lt;&lt; 1))</code>。</p>
<p>然后就可以树状数组，把这些东西插进树状数组，然后查血有多少个合法的左端点，就可以了。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, f, <span class="built_in">l</span>(inf), r;</span><br><span class="line">ll a[maxn], p[maxn];</span><br><span class="line">ll t[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>()) </span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x &lt;= n * <span class="number">4</span>) &#123;</span><br><span class="line">		t[x] += v;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		res += t[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		p[i] = p[i - <span class="number">1</span>] + <span class="number">2</span> * (a[i] &gt; x);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">update</span>(i - p[i] + <span class="number">2</span> * n, <span class="number">1</span>);</span><br><span class="line">		res += <span class="built_in">query</span>(i - p[i] - <span class="number">1</span> + <span class="number">2</span> * n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res &gt;= n * (n + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;median.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;median.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		a[i] = <span class="built_in">read</span>();</span><br><span class="line">		l = <span class="built_in">min</span>(l, a[i]);</span><br><span class="line">		r = <span class="built_in">max</span>(r, a[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid, ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>T20201116</title>
    <url>/AlanTuringLi/2020/11/16/T20201116/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>要或起来的值与异或起来的值相等，那么可以发现异或和一定是或的子集。</p>
<p>所以可以固定或起来的值，然后去异或背包一下就可以了。。。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> A[maxn], B[maxn];</span><br><span class="line"><span class="type">int</span> tmp[maxm];</span><br><span class="line">ll f[maxn][maxm], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;orandxor.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;orandxor.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; maxm; ++x) &#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">tot</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = x; p; p = (p - <span class="number">1</span>) &amp; x) tmp[++cnt] = p;</span><br><span class="line">		tmp[++cnt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">if</span> ((A[i] | x) == x) B[++tot] = A[i];</span><br><span class="line"></span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) </span><br><span class="line">				f[i][tmp[j]] = f[i - <span class="number">1</span>][tmp[j]] + f[i - <span class="number">1</span>][tmp[j] ^ B[i]];</span><br><span class="line"></span><br><span class="line">		ans += f[tot][x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>就是说，要尽可能多的满足 <code>f[i - 2] + f[i - 1] = f[i]</code>，这样可以得到一个序列。</p>
<p>那么只要随便在向这个序列中丢一个数（使得序列仍然有序），那么必定会使的至少一个等式不成立，即至少有一组满足条件的解。</p>
<p>然后这个序列可以类似斐波那契数列的方法去构造，然后这个序列最终的长度就是 $45$。</p>
<p>所以可以用线段树把区间里的前 $45$ 大的数求出来，在贪心的找就可以了。。。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, res[maxn];</span><br><span class="line"><span class="type">int</span> mx[maxn &lt;&lt; <span class="number">2</span>][lim];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) </span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *l, <span class="type">int</span> *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> tmpa[lim], tmpb[lim];</span><br><span class="line">	<span class="built_in">memcpy</span> (tmpa, l, <span class="keyword">sizeof</span> tmpa);</span><br><span class="line">	<span class="built_in">memcpy</span> (tmpb, r, <span class="keyword">sizeof</span> tmpb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i + j &lt; lim) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((tmpa[i] == <span class="number">-1</span>) &amp;&amp; (tmpb[j] == <span class="number">-1</span>)) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmpa[i] &gt; tmpb[j]) l[i + j] = tmpa[i], i++;</span><br><span class="line">		<span class="keyword">else</span> l[i + j] = tmpb[j], j++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt; lim; ++i)</span><br><span class="line">			mx[x][i] = <span class="number">-1</span>;</span><br><span class="line">		mx[x][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span> (l, mid, x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span> (mid + <span class="number">1</span>, r, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span> (mx[x], mx[x &lt;&lt; <span class="number">1</span>], <span class="keyword">sizeof</span> mx[x]);</span><br><span class="line">	<span class="built_in">merge</span> (mx[x], mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		mx[x][<span class="number">0</span>] = val;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">update</span> (l, mid, pos, val, x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">update</span> (mid + <span class="number">1</span>, r, pos, val, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span> (mx[x], mx[x &lt;&lt; <span class="number">1</span>], <span class="keyword">sizeof</span> mx[x]);</span><br><span class="line">	<span class="built_in">merge</span> (mx[x], mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) &#123;</span><br><span class="line">		<span class="built_in">merge</span>(res, mx[x]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tl &lt;= mid) <span class="built_in">getans</span> (l, mid, tl, tr, x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (tr &gt; mid) <span class="built_in">getans</span> (mid + <span class="number">1</span>, r, tl, tr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;triangle.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;triangle.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>(), opt, l, r;</span><br><span class="line">	<span class="built_in">build</span> (<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		opt = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, n, l, r);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">				res[i] = <span class="number">-1</span>;</span><br><span class="line">			<span class="built_in">getans</span>(<span class="number">1</span>, n, l, r);</span><br><span class="line">			<span class="function">ll <span class="title">result</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; lim; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (res[i] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (res[i] &lt; res[i + <span class="number">1</span>] + res[i + <span class="number">2</span>]) &#123;</span><br><span class="line">					result = (ll)res[i] + res[i + <span class="number">1</span>] + res[i + <span class="number">2</span>];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="80"><a href="#80" class="headerlink" title="80?"></a>80?</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cur, tot, val[maxn], dep[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[d] ^= val[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u, d + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(dep[<span class="number">0</span>])</span>, <span class="title">sta</span><span class="params">((~i) &amp; lim)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = sta; j; j = (j - <span class="number">1</span>) &amp; sta)</span><br><span class="line">			ans ^= dep[j];</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="100"><a href="#100" class="headerlink" title="100?"></a>100?</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cur, tot, val[maxn], dep[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[d] ^= val[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u, d + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= lim; ++j)</span><br><span class="line">			<span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">				dep[j] ^= dep[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, dep[i ^ lim]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>T20201117</title>
    <url>/AlanTuringLi/2020/11/17/T20201117/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Subtask-1-amp-2"><a href="#Subtask-1-amp-2" class="headerlink" title="Subtask 1 &amp; 2"></a>Subtask 1 &amp; 2</h2><p>$O(nk)$ 的暴力，对于 $f_m(n)$ 有：</p>
<script type="math/tex; mode=display">
f_m(n)=
\begin{cases}
f_m(n-1)&m\not\mid n\\
f_m(n-1)+f(\frac mn) &m\mid n
\end{cases}</script><p>然后就暂时没有下文了</p>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>还是暴力。。。</p>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>考虑分治，就是模拟归并排序的运算流程。</p>
<p>归并的思想，就是不断的把子区间变得有序，然后再来合并这些有序的子区间。</p>
<p>但是，利用归并的思想，还要考虑如何使用区间翻转操作合并两个区间。</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ7TBR.png" alt=""></p>
<p>然后又是两个子段的合并，所以合并也是一个  $O(\log n)$ 的时间复杂度。</p>
<p>那么总时间复杂度就应该是 $O(n\log ^2n)$ 的时间复杂度。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>感觉这其实也是算一种构造的，就是构造了一种排序的方式，似乎有些抽象。</p>
<p>考虑对于每一次的合并操作，最坏最坏的情况就是蓝色的操作刚好取到中点，然后合并黑色和绿色的区间递归下去的时候又是刚好取到中点，所以，这样的一个区间的花费就是 $len\log len$，所以最后的总花费就应该是：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=0}len_i\log len_i</script><p>然后把那个$32000$ 带进去算，得到的答案竟然只有 $3821617$，真的是远远小于 $4\times10^6$，所以这个算法就是对的了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line">vector &lt; pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">	ans.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l, r));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (r - l + <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">		<span class="built_in">swap</span>(a[l + i], a[r - i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l0, <span class="type">int</span> r0, <span class="type">int</span> l1, <span class="type">int</span> r1)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l0 &gt; r0 || l1 &gt; r1) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">min</span> (r0 - l0, r1 - l1), pt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pt &lt;= l) </span><br><span class="line">		<span class="keyword">if</span> (a[r0 - pt] &gt; a[l1 + pt]) pt++; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">update</span>(r0 - pt + <span class="number">1</span>, r0);</span><br><span class="line">    <span class="built_in">update</span>(l1 , l1 + pt - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(r0 - pt + <span class="number">1</span>, l1 + pt - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge</span>(l0, r0 - pt, r0 - pt + <span class="number">1</span>, r0);</span><br><span class="line">    <span class="built_in">merge</span>(l1, l1 + pt - <span class="number">1</span>, l1 + pt, r1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid); </span><br><span class="line">	<span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(l, mid, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;rev.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;rev.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans[i].first, ans[i].second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>广义后缀自动机模板题，不说了。。。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>分治</tag>
        <tag>考试</tag>
        <tag>多项式</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201118</title>
    <url>/AlanTuringLi/2020/11/18/T20201118/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p><a href="https://imgchr.com/i/DupWSH"><img src="https://s3.ax1x.com/2020/11/19/DupWSH.png" alt="DupWSH.png" border="0" /></a></p>
<p>就是因为数据随机，还有充足的限制条件。</p>
<p>所以爆搜 + 可行性剪枝就可以过了。</p>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p><a href="https://imgchr.com/i/Dup2fe"><img src="https://s3.ax1x.com/2020/11/19/Dup2fe.png" alt="Dup2fe.png" border="0" /></a></p>
<p>首先，我们可以有约定如下：</p>
<ul>
<li><p>默认 $1$ 作为根节点。</p>
</li>
<li><p>$f_x$ 表示从 $x$ 走到其父亲节点的期望步数。</p>
</li>
<li><p>$g_x$ 表示从 $x$ 的父亲走到 $x$ 的期望步数。</p>
</li>
<li>$d_x$ 表示 $x$ 的度数。</li>
</ul>
<p>那么就可以很轻松的得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_x&=\frac1d\left(1+\sum_{son_x}\left(f_{son_x}+1+f_x\right)\right)\\
&=\frac1d\left(d+(d-1)f_x+\sum_{son_x}f_{son_x}\right)\\
&=\frac1d\left(d+\sum_{son_x}f_{son_x}\right)+\frac{d-1}df_x
\end{aligned}
\Leftrightarrow\begin{aligned}
\frac1df_x&=\frac1d\left(d+\sum_{son_x}f_{son_x}\right)\\
f_x&=d+\sum_{son_x}f_{son_x}
\end{aligned}</script><p>那么 $f_x$ 就可以表示为子树内的所有点的度数之和，同理可得 $g_x$ 就该是子树外的所有点的度数之和。</p>
<p>所以问题似乎变成了一个有点类似树的期望直径<del>(乱叫的)</del>的这么一个东西。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">		o = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans, cur, size[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[maxn], g[maxn];</span><br><span class="line"><span class="type">int</span> up[maxn], dn[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chmax</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; x) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u], v; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((v = edge[i]) == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span> (v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">chmax</span> (ans, <span class="built_in">max</span>(up[u] + g[v] + dn[v], dn[u] + f[v] + up[v]));</span><br><span class="line">		<span class="built_in">chmax</span> (up[u], up[v] + f[v]);</span><br><span class="line">		<span class="built_in">chmax</span> (dn[u], dn[v] + g[v]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f[u] = (size[u] &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">	g[u] = ((n - size[u]) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = __read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">		u = __read(), v = __read();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d.00000&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p><a href="https://imgchr.com/i/DupgYD"><img src="https://s3.ax1x.com/2020/11/19/DupgYD.png" alt="DupgYD.png" border="0" /></a></p>
<p>对于一个有向图，它缩点之后一定是一个 $\text{DAG}$。</p>
<p>有如下约定：</p>
<ul>
<li>$h_i$ 表示 $i$ 个点的竞赛图的个数，$h_i=2^{\binom i2}$</li>
<li>$f_i$ 表示 $i$ 个点的强连通竞赛图的个数，考虑用总方案减去不合法的方案数，枚举缩点后 $\text{DAG}$ 尾部的强连通分量的大小，有：</li>
<li><script type="math/tex; mode=display">
f_i=h_i-\sum_{j=1}^{i-1}\binom ijf_ih_{i-j}</script></li>
<li>$g_i$ 表示有 $i$ 个点时的答案。</li>
</ul>
<p>那么考虑第 $i$ 个询问，就考虑在尾部加入一个强连通分量，然后考虑 $1$ 是否在末尾的强连通分量内：</p>
<script type="math/tex; mode=display">
g_i=\sum_{j=1}^if_j\left(\dbinom {i-1}{j-1}h_{i-j}d_j+\dbinom{i-1}{j}g_{i-j}\right)</script><p>那么这个就是表示的如果 $i$ 在最后这个联通块中，那么就有 $d_j$ 的贡献，如果不在最后一个联通块中，那么它一定在另外 $i-j$ 个点中，然后预处理一下就是 $O(n^2)$。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = <span class="number">1ll</span> * ans * x % mod;</span><br><span class="line">		x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> f[maxn], g[maxn], h[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">			c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f[<span class="number">0</span>] = h[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		h[i] = <span class="built_in">Pow</span>(<span class="number">2</span>, i * (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		f[i] = h[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">			f[i] = ((f[i] - <span class="number">1ll</span> * c[i][j] * f[j] % mod * h[i - j] % mod) % mod + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">			g[i] = (g[i] + <span class="number">1ll</span> * f[j] * (<span class="number">1ll</span> * c[i - <span class="number">1</span>][j - <span class="number">1</span>] * h[i - j] % mod * d[j] % mod + <span class="number">1ll</span> * c[i - <span class="number">1</span>][j] * g[i - j] % mod)) % mod;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="number">1ll</span> * g[i] * <span class="built_in">Pow</span>(h[i], mod - <span class="number">2</span>) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>期望</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201119</title>
    <url>/AlanTuringLi/2020/11/19/T20201119/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>一来就是一个换根 $dp$，然后很难调，细节容易挂。。。</p>
<p>还是先考虑以 $1$ 为根的答案，然后需要考虑它的子树该如何遍历能使最后的答案更优。</p>
<p>假设两颗子树 $a,b$，他们子树内的答案、大小、权值之和分别表示为 $f,siz,sum$，$a$ 在 $b$ 前更优当且仅当 $sum_b\times siz_a&lt;sum_a\times siz_b$ 成立时成立。</p>
<p>所以，这一个 $\text{dfs}$ 需要对子节点排一次序才能计算答案，即：</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>, f[u] = sum[u] = a[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">		tmp[u].<span class="built_in">push_back</span>(edge[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span> (tmp[u].<span class="built_in">begin</span>(), tmp[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		f[u] += f[tmp[u][i]] + siz[u] * sum[tmp[u][i]];</span><br><span class="line">		siz[u] += siz[tmp[u][i]], sum[u] += sum[tmp[u][i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>那么换根的时候，原来父亲节点的信息也需要相应的发生变化：</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">chroot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span> (tmp[u].<span class="built_in">begin</span>(), tmp[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">	siz[u] = <span class="number">1</span>, g[u] = sum[u] = a[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		g[u] += f[tmp[u][i]] + siz[u] * sum[tmp[u][i]];</span><br><span class="line">		siz[u] += siz[tmp[u][i]], sum[u] += sum[tmp[u][i]];</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">min</span>(ans, g[u]);</span><br><span class="line"></span><br><span class="line">	<span class="function">ll <span class="title">tempa</span><span class="params">(a[u])</span>, <span class="title">temps</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fa == tmp[u][i]) &#123;</span><br><span class="line">			tempa += sum[tmp[u][i]];</span><br><span class="line">			temps += siz[tmp[u][i]];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		f[u] = g[u] - f[tmp[u][i]] - temps * sum[tmp[u][i]];</span><br><span class="line">		tempa += sum[tmp[u][i]];</span><br><span class="line">		temps += siz[tmp[u][i]];</span><br><span class="line">		f[u] -= siz[tmp[u][i]] * (SUM - tempa);</span><br><span class="line">		siz[u] = n - siz[tmp[u][i]];</span><br><span class="line">		sum[u] = SUM - sum[tmp[u][i]];</span><br><span class="line">		tmp[tmp[u][i]].<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="built_in">chroot</span>(tmp[u][i], u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>所以这个点就可以直接当做根来算了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, cur, cnt, a[maxn];</span><br><span class="line">ll SUM, <span class="built_in">ans</span>(<span class="number">0x7fffffffffffffff</span>);</span><br><span class="line">ll siz[maxn], sum[maxn], f[maxn], g[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> siz[a] * sum[b] &lt; siz[b] * sum[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>, f[u] = sum[u] = a[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">		tmp[u].<span class="built_in">push_back</span>(edge[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span> (tmp[u].<span class="built_in">begin</span>(), tmp[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		f[u] += f[tmp[u][i]] + siz[u] * sum[tmp[u][i]];</span><br><span class="line">		siz[u] += siz[tmp[u][i]], sum[u] += sum[tmp[u][i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chroot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span> (tmp[u].<span class="built_in">begin</span>(), tmp[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">	siz[u] = <span class="number">1</span>, g[u] = sum[u] = a[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		g[u] += f[tmp[u][i]] + siz[u] * sum[tmp[u][i]];</span><br><span class="line">		siz[u] += siz[tmp[u][i]], sum[u] += sum[tmp[u][i]];</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">min</span>(ans, g[u]);</span><br><span class="line"></span><br><span class="line">	<span class="function">ll <span class="title">tempa</span><span class="params">(a[u])</span>, <span class="title">temps</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fa == tmp[u][i]) &#123;</span><br><span class="line">			tempa += sum[tmp[u][i]];</span><br><span class="line">			temps += siz[tmp[u][i]];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		f[u] = g[u] - f[tmp[u][i]] - temps * sum[tmp[u][i]];</span><br><span class="line">		tempa += sum[tmp[u][i]];</span><br><span class="line">		temps += siz[tmp[u][i]];</span><br><span class="line">		f[u] -= siz[tmp[u][i]] * (SUM - tempa);</span><br><span class="line">		siz[u] = n - siz[tmp[u][i]];</span><br><span class="line">		sum[u] = SUM - sum[tmp[u][i]];</span><br><span class="line">		tmp[tmp[u][i]].<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="built_in">chroot</span>(tmp[u][i], u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o  &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;signin.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;signin.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span> (u, v), <span class="built_in">addedge</span> (v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		SUM += (a[i] = <span class="built_in">read</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">chroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>就是问这一条边若要保证不改变其最小生成树的大小所需要满足的条件。</p>
<p>那么很显然，可以先跑一次最小生成树：</p>
<ul>
<li>那么对于不在生成树上的边，可以查询 $u\rightarrow v$ 路径上的树边最大的权值。</li>
<li>对于在生成树上的边，可以查询 $u\rightarrow v$ 路径上非树边的最小权值。</li>
</ul>
<p>证明的话，就是可以把查询到的那条边拿走，然后把这条边换上去，并不影响生成树的连通性以及大小。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (x &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> u, v, w, p;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;t) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Lines[maxm];</span><br><span class="line"><span class="type">bool</span> vis[maxm];</span><br><span class="line"><span class="type">int</span> n, m, cnt, cur, ans[maxm];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], cost[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> son[maxn], size[maxn], top[maxn], dep[maxn], f[maxn], pkg[maxn];</span><br><span class="line"><span class="type">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], mn[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>], id[maxn], len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mmin</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mmax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mswap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a ^= b ^= a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (ls) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u] = fa, size[u] = <span class="number">1</span>, dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span> (edge[i], u);</span><br><span class="line">		size[u] += size[edge[i]];</span><br><span class="line">		<span class="keyword">if</span> (size[edge[i]] &gt; size[son[u]]) son[u] = edge[i], pkg[u] = cost[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> tp, <span class="type">int</span> lenth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top[u] = tp, id[u] = ++cnt, len[cnt] = lenth;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) <span class="built_in">dfs</span>(son[u], tp, pkg[u]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == f[u] || edge[i] == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], edge[i], cost[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mx[x] = <span class="built_in">mmax</span>(mx[ls], mx[rs]);</span><br><span class="line">	mn[x] = <span class="built_in">mmin</span>(mn[ls], mn[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">realpd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mn[x] = <span class="built_in">mmin</span>(mn[x], val);</span><br><span class="line">	<span class="keyword">if</span> (tag[x] == <span class="number">-1</span>) tag[x] = val;</span><br><span class="line">	<span class="keyword">else</span> tag[x] = <span class="built_in">mmin</span>(tag[x], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; (maxn &lt;&lt; <span class="number">2</span>) || tag[x] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">realpd</span> (ls, tag[x]);</span><br><span class="line">	<span class="built_in">realpd</span> (rs, tag[x]);</span><br><span class="line">	tag[x] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tag[x] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		mx[x] = len[l];</span><br><span class="line">		mn[x] = inf;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span> (l, mid, ls);</span><br><span class="line">	<span class="built_in">build</span> (mid + <span class="number">1</span>, r, rs);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> val, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) &#123;</span><br><span class="line">		<span class="built_in">realpd</span>(x, val);</span><br><span class="line">		<span class="keyword">return</span> mx[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, <span class="built_in">ans</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (tl &lt;= mid) ans = <span class="built_in">mmax</span>(ans, <span class="built_in">query</span> (l, mid, tl, tr, val, ls));</span><br><span class="line">	<span class="keyword">if</span> (tr &gt; mid) ans = <span class="built_in">mmax</span>(ans, <span class="built_in">query</span> (mid + <span class="number">1</span>, r, tl, tr, val, rs));</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querymn</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) <span class="keyword">return</span> mn[x];</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, <span class="built_in">ans</span>(inf);</span><br><span class="line">	<span class="keyword">if</span> (tl &lt;= mid) ans = <span class="built_in">mmin</span>(ans, <span class="built_in">querymn</span> (l, mid, tl, tr, ls));</span><br><span class="line">	<span class="keyword">if</span> (tr &gt; mid) ans = <span class="built_in">mmin</span>(ans, <span class="built_in">querymn</span> (mid + <span class="number">1</span>, r, tl, tr, rs));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="built_in">mswap</span>(u, v);</span><br><span class="line">		ans = <span class="built_in">mmax</span>(ans, <span class="built_in">query</span> (<span class="number">1</span>, n, id[top[u]], id[u], val));</span><br><span class="line">		u = f[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) <span class="built_in">mswap</span> (u, v);</span><br><span class="line">	<span class="keyword">if</span> (u != v) ans = <span class="built_in">mmax</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, n, id[u] + <span class="number">1</span>, id[v], val));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">querymn</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(inf)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="built_in">mswap</span>(u, v);</span><br><span class="line">		ans = <span class="built_in">mmin</span>(ans, <span class="built_in">querymn</span> (<span class="number">1</span>, n, id[top[u]], id[u]));</span><br><span class="line">		u = f[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) <span class="built_in">mswap</span> (u, v);</span><br><span class="line">	<span class="keyword">if</span> (u != v) ans = <span class="built_in">mmin</span>(ans, <span class="built_in">querymn</span> (<span class="number">1</span>, n, id[u] + <span class="number">1</span>, id[v]));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">	cost[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MST</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(Lines + <span class="number">1</span>, Lines + m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x = Lines[i].u, y = Lines[i].v;</span><br><span class="line">		<span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">		vis[i] = <span class="number">1</span>;</span><br><span class="line">		f[fx] = fy;</span><br><span class="line">		<span class="built_in">addedge</span> (x, y, Lines[i].w);</span><br><span class="line">		<span class="built_in">addedge</span> (y, x, Lines[i].w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">build</span> (<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;easy.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;easy.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		Lines[i].u = <span class="built_in">read</span>();</span><br><span class="line">	   	Lines[i].v = <span class="built_in">read</span>();</span><br><span class="line">		Lines[i].w = <span class="built_in">read</span>();</span><br><span class="line">		Lines[i].p = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MST</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		ans[Lines[i].p] = <span class="built_in">query</span>(Lines[i].u, Lines[i].v, Lines[i].w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		ans[Lines[i].p] = <span class="built_in">querymn</span> (Lines[i].u, Lines[i].v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, (ans[i] == <span class="number">-1</span> || ans[i] == inf) ? <span class="number">1000000000</span> : ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>还没有看题， 鸽了~</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>组合数学</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201120</title>
    <url>/AlanTuringLi/2020/11/20/T20201120/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>显然是从右向左贪心的处理，就是说要让右边的尽可能不选，来达到这个全局最小的目的。</p>
<p>那么就可以把所有的 <code>A</code> 看成 <code>-1</code>，而把 <code>B</code> 看成是 <code>1</code>， 那么就可以把后缀和小于等于 <code>0</code> 的部分忽略掉了，因为这个时候的主导因素是前面的元素了。然后如果某个时候这个后缀和大于 <code>k</code> 了，就是说这个点一定得选了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="type">int</span> tw[maxn] = &#123;<span class="number">1</span>&#125;, n, k, cnt, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;elect.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;elect.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tw[i] = (tw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i; --i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			<span class="keyword">if</span> (cnt &gt; k) &#123;</span><br><span class="line">				ans = (ans + tw[i]) % mod;</span><br><span class="line">				--cnt;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt = <span class="built_in">max</span>(<span class="number">0</span>, cnt - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>容易发现，这个 $k$ 太小了，完全可以暴力跳。</p>
<h2 id="k-le10"><a href="#k-le10" class="headerlink" title="$k\le10$"></a>$k\le10$</h2><p>这一部分就是送分的了，那么这个可以做一些什么呢？</p>
<p>考虑维护这样一个数组：<code>sum[u][len]</code> 表示 <code>u</code> 的子树中距离 <code>u</code> 小于等于 <code>len</code> 的所有点的点权之和。 所以对于一次查询，可以用非常简单的容斥往上跳 $k$ 次，然后减去上来的子树的贡献。</p>
<p><strong>时间复杂度</strong> $O(n+qk)$，<strong>空间复杂度</strong> $O(nk)$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>], cur;</span><br><span class="line">ll sum[maxn][<span class="number">11</span>], val[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u][<span class="number">1</span>] = p, sum[u][<span class="number">0</span>] = val[u];</span><br><span class="line">	sum[p][<span class="number">1</span>] += val[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span> &amp;&amp; f[u][i - <span class="number">1</span>]; ++i) &#123;</span><br><span class="line">		f[u][i] = f[f[u][i - <span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">		sum[f[u][i]][i] += val[u];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (edge[i] == p) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nw = f[p][<span class="number">1</span>], up = <span class="number">1</span>;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(sum[p][k])</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (nw &amp;&amp; up &lt;= k) &#123;</span><br><span class="line">		res += sum[nw][k - up];</span><br><span class="line">		<span class="keyword">if</span> (k &gt; up) res -= sum[p][k - up - <span class="number">1</span>];</span><br><span class="line">		++up, nw = f[nw][<span class="number">1</span>], p = f[p][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), q, u, v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j) </span><br><span class="line">			sum[i][j] += sum[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	q = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(u, v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>上述算法，问题就是空间开不下，那么如果说可以用 $O(n)$ 的空间来做这件事情，这道题就可以过了。</p>
<p>那么就可以考虑长链剖分，用这一条链来辅助整棵树的操作。</p>
<p><img src="https://s3.ax1x.com/2020/11/20/DlFTQf.png" alt=""></p>
<p>那么就可以用 <code>f[id[v]]</code> 表示当前以 <code>u</code> 为子树时，所有深度严格低于该点的所有点的点权和的相反数。</p>
<p>所以当我们想要得到以 <code>u</code> 为子树，所有距离 <code>u</code> 小于等于 <code>k</code> 的点权和，就可以有这样的表示：<code>ans = sum[u] + f[id[u] + k]</code>。</p>
<p> 这可以说是利用这长链剖分的性质：每一条链的编号的映射都是连续的。</p>
<p>所以就可以把所有的询问离线，把每一个操作变成 $k$ 个，然后在把这 $k$ 次操作按照这个容斥系数加起来就是索要求的的答案。</p>
<p><strong>时间复杂度</strong> $O(n+qk)$，<strong>空间复杂度</strong> $O(n)$</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line">ll f[maxn], val[maxn], ans[maxn], sum[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>], cur, cnt;</span><br><span class="line"><span class="type">int</span> id[maxn], mx[maxn], pr[maxn], son[maxn], dep[maxn];</span><br><span class="line"><span class="type">int</span> hd[maxn], ed[maxn], nx[maxn], fc[maxn], dis[maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cur] = head[u];</span><br><span class="line">	head[u] = cur;</span><br><span class="line">	edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr[u] = f, mx[u] = dep[u] = depth;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u], v; i &amp;&amp; (v = edge[i]); i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u, depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mx[v] &gt; mx[u]) &#123;</span><br><span class="line">			mx[u] = mx[v];</span><br><span class="line">			son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> top)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == top)</span><br><span class="line">		id[u] = cnt + <span class="number">1</span>, cnt += mx[u] - dep[u] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> id[u] = id[pr[u]] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (son[u]) <span class="built_in">dfs</span>(son[u], top);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u], v; i &amp;&amp; (v = edge[i]); i = nxt[i])</span><br><span class="line">		<span class="keyword">if</span> (v != pr[u] &amp;&amp; v != son[u])</span><br><span class="line">			<span class="built_in">dfs</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addopt</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> f, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nx[++top] = hd[u], fc[top] = f;</span><br><span class="line">	dis[top] = k, ed[top] = v, hd[u] = top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(son[u]);</span><br><span class="line">		sum[u] = sum[son[u]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u], v; i &amp;&amp; (v = edge[i]); i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == son[u] || v == pr[u]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">solve</span> (v);</span><br><span class="line">		<span class="type">int</span> len = mx[v] - dep[v];</span><br><span class="line">		sum[u] += sum[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j)</span><br><span class="line">			f[id[u] + j + <span class="number">1</span>] += f[id[v] + j];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f[id[u]] = -sum[u];</span><br><span class="line">	sum[u] += val[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = hd[u]; i; i = nx[i])</span><br><span class="line">		ans[ed[i]] += fc[i] * (sum[u] + f[id[u] + <span class="built_in">min</span>(dis[i], mx[u] - dep[u])]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), u, v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span> (u, v);</span><br><span class="line">		<span class="built_in">addedge</span> (v, u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> q = <span class="built_in">read</span>(), pre;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addopt</span> (u, i, <span class="number">1</span>, v);</span><br><span class="line">		<span class="keyword">while</span> (pr[u] &amp;&amp; v) &#123;</span><br><span class="line">			pre = u, u = pr[u], --v;</span><br><span class="line">			<span class="built_in">addopt</span>(u, i, <span class="number">1</span>, v);</span><br><span class="line">			<span class="keyword">if</span> (v &gt; <span class="number">0</span>) <span class="built_in">addopt</span>(pre, i, <span class="number">-1</span>, v - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">solve</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) </span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>首先注意到一个结论:给定一堆射线，一个起点，一个终点，则存在以起终点为两端点的曲线不与任何<br>射线相交，当且仅当对于任意两条射线，存在以起终点为两端点的曲线不与这两条射线相交。</p>
<p>证明有较大难度。考虑不连通时，起点所在的连通块一定是一个多边形(平面可以视作由4条射线围成的 有限区域)，然后考虑证明一定可以选出多边形上相邻两条边对应的射线分割起点和终点。这个问题亦即 对于多边形内任意一点和多边形外任意一点都可以选出多边形上相邻两条边对应的射线分割这两个点。</p>
<p>下面考虑归纳证明。</p>
<p>当多边形点数 <code>= 3</code> 时，可以枚举所有情况证明(实际上本质不同的情况只有 <code>2</code> 种)。</p>
<p>当多边形点数 <code>= n (n &gt; 3)</code> 时，若多边形为凸多边形，可以任选连续的三条边，引出两条辅助线，考虑这样得到的 <code>n - 1</code> 边形，一定满足条件；那么现在相当于少了一对边，多了两对边，分类讨论这三条边的方向，共 <code>8</code> 种情况(实际上本质不同的情况只有 <code>4</code> 种)，即可证明。</p>
<p>若多边形为凹多边形，选出那个 <code>&gt; 180</code> 度的角，显然这个角的两条边的方向是确定的(如下图所示)，作 出辅助线，同理这样得到的 <code>n - 1</code> 边形，一定满足条件;现在相当于删去两对边加入三对边，分类讨论 三条边的方向和起点所在的位置，即可证明。</p>
<p>现在回到原问题，我们将起点记作 <code>S</code>，终点记作 <code>T</code>。不妨假设 <code>S</code> 的纵坐标 <code>T</code> 的纵坐标，否则对所有点的纵坐标取反即可。将所有点分成三类: </p>
<ol>
<li>纵坐标 <code>&gt; T</code> 的。</li>
<li>纵坐标在 <code>S, T</code> 之间的。</li>
<li>纵坐标 <code>&lt; S</code> 的。</li>
</ol>
<p>对于交点为第一类的，无解等价于有向下的射线和向左或右的射线相交;对于交点为第二类的，无解等价于有向下的射线(端点可能是第一类的)和向左的射线相交，或向上的射线(端点可能是第三类的)和向右 的射线相交; 对于交点为第三类的，无解等价于有向上的射线和向左或右的射线相交。</p>
<p>对于第一类的端点，我们从上到下做一遍 <code>dp</code>， <code>dp[i][l][r]</code> 表示考虑纵坐标 <code>&gt;= i</code> 的点，向下的射线横坐标的最小值为 <code>l</code>，最大值为 <code>r</code> 的方案数。第三类同理。</p>
<p>对于第二类端点，我们先枚举端点为第一类的向下的射线的横坐标的最小值 <code>d</code>，和端点为第三类的向上 的射线的横坐标的最大值 <code>u</code>，这样，所有横坐标 <code>&gt; d</code> 的第二类端点不能向左，所有横坐标 <code>&lt; u</code> 的第二类端点不能向右。然后从左到右 <code>dp</code>，<code>dp[i][x][y]</code> 表示考虑横坐标 <code>&lt;= i</code> 的点，向下的射线的端点的纵坐标的最大值为 <code>x</code>，向右的射线的端点的纵坐标的最大值为 <code>y</code> 的方案数。时间复杂度 $O(n^5)$。</p>
<h2 id="Code-std"><a href="#Code-std" class="headerlink" title="Code(%std)"></a>Code(%std)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> s64;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>,D=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> x[N],y[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LISAN</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n)b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b,b+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n)a[i]=<span class="built_in">lower_bound</span>(b,b+n+<span class="number">1</span>,a[i])-b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;s64&gt; <span class="title">work</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x[],<span class="type">int</span> y[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> s64 dp[N][N][N];</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> dy[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>)dy[y[i]]=x[i];</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[n+<span class="number">2</span>][n+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">per</span>(i,n+<span class="number">1</span>,y[n+<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=dy[i];</span><br><span class="line">		<span class="built_in">rep</span>(l,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">rep</span>(r,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s64 f=dp[i+<span class="number">1</span>][l][r];</span><br><span class="line">			<span class="keyword">if</span>(!f)<span class="keyword">continue</span>;</span><br><span class="line">			(dp[i][l][r]+=f*(<span class="number">1</span>+(j&lt;l)+(j&gt;r)))%=D;</span><br><span class="line">			(dp[i][<span class="built_in">min</span>(l,j)][<span class="built_in">max</span>(r,j)]+=f)%=D;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;s64&gt;<span class="built_in">ans</span>(n+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">rep</span>(l,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">rep</span>(r,<span class="number">0</span>,n+<span class="number">1</span>)(ans[l]+=dp[y[n+<span class="number">1</span>]+<span class="number">1</span>][l][r])%=D;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kcz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;y[<span class="number">0</span>]&gt;&gt;y[n+<span class="number">1</span>]; </span><br><span class="line">	x[n+<span class="number">1</span>]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n)cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	LISAN::<span class="built_in">work</span>(x,n+<span class="number">1</span>);</span><br><span class="line">	LISAN::<span class="built_in">work</span>(y,n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(y[<span class="number">0</span>]&gt;y[n+<span class="number">1</span>])<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>)y[i]=n+<span class="number">1</span>-y[i];</span><br><span class="line">	</span><br><span class="line">	vector&lt;s64&gt;ans1=<span class="built_in">work</span>(n,x,y),ans2;</span><br><span class="line">	<span class="built_in">rep</span>(tmp,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(x[<span class="number">0</span>],x[n+<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(y[<span class="number">0</span>],y[n+<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>)&#123;x[i]=n+<span class="number">1</span>-x[i];y[i]=n+<span class="number">1</span>-y[i];&#125;</span><br><span class="line">		<span class="keyword">if</span>(!tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			ans2=<span class="built_in">work</span>(n,x,y);</span><br><span class="line">			<span class="built_in">reverse</span>(ans2.<span class="built_in">begin</span>(),ans2.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> dy[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>)dy[x[i]]=y[i];</span><br><span class="line">	<span class="comment">//rep(i,0,n+1)cerr&lt;&lt;dy[i]&lt;&lt;endl;</span></span><br><span class="line">	s64 ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(d,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">rep</span>(u,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">static</span> s64 dp[N][N][N];</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j=dy[i];</span><br><span class="line">			<span class="keyword">if</span>(j&lt;y[<span class="number">0</span>]||j&gt;y[n+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(dp[i],dp[i<span class="number">-1</span>],<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">rep</span>(l,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">rep</span>(r,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				s64 f=dp[i<span class="number">-1</span>][l][r];</span><br><span class="line">				<span class="keyword">if</span>(!f)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;r)(dp[i][l][r]+=f)%=D;<span class="comment">//up</span></span><br><span class="line">				(dp[i][<span class="built_in">max</span>(l,j)][r]+=f)%=D;<span class="comment">//down</span></span><br><span class="line">				<span class="keyword">if</span>(i&lt;=d&amp;&amp;j&gt;l)(dp[i][l][r]+=f)%=D;<span class="comment">//left</span></span><br><span class="line">				<span class="keyword">if</span>(i&gt;=u)(dp[i][l][<span class="built_in">max</span>(r,j)]+=f)%=D;<span class="comment">//right</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s64 sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(l,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">rep</span>(r,<span class="number">0</span>,n+<span class="number">1</span>)sum+=dp[n][l][r];</span><br><span class="line">		sum%=D;</span><br><span class="line">		(ans+=ans1[d]*ans2[u]%D*sum)%=D;</span><br><span class="line">	<span class="comment">//	if(ans1[d]&amp;&amp;ans2[u])</span></span><br><span class="line">	<span class="comment">//		cerr&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;ans1[d]&lt;&lt;&quot; &quot;&lt;&lt;ans2[u]&lt;&lt;&quot; &quot;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	s64 p4=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n)(p4*=<span class="number">4</span>)%=D;</span><br><span class="line">	cout&lt;&lt;((p4-ans)%D+D)%D&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;path.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="built_in">Kcz</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>T20201125</title>
    <url>/AlanTuringLi/2020/11/25/T20201125/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>这个和 <a href="https://www.luogu.com.cn/problem/P4151">这道题</a> 很像，其实本质就是一道题，所以可以就按照这道题的方法去写，完全没有问题。</p>
<p>但是进一步考虑，能发现还有一些性质：</p>
<ul>
<li>实际的路径长度和 $m+n-1$ 的奇偶性相同</li>
</ul>
<p>所以，可以考虑线性基，然后取二进制下第 $30$ 位来控制奇偶性。</p>
<p>然后就可以线性基乱搞了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = maxn; ~i; --i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(x &gt;&gt; i)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!p[i]) &#123;</span><br><span class="line">			p[i] = x;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		x ^= p[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = maxn; ~i; --i)</span><br><span class="line">		<span class="keyword">if</span> (~x &amp; (<span class="number">1</span> &lt;&lt; i)) x ^= p[i];</span><br><span class="line">	<span class="keyword">return</span> x &amp; ((<span class="number">1</span> &lt;&lt; maxn) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;sign.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span> (<span class="string">&quot;sign.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i) &#123;</span><br><span class="line">		temp = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">insert</span> (temp | (<span class="number">1</span> &lt;&lt; maxn));</span><br><span class="line">	&#125;</span><br><span class="line">	temp = ((n + m) &amp; <span class="number">1</span>) &lt;&lt; maxn;</span><br><span class="line">   cout &lt;&lt; <span class="built_in">query</span> (temp);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>就是可以按编号分块，然后预处理出所有点到每个块的最小值，然后块内的信息可以暴力跳。</p>
<p>然后就是可能有点<strong>小</strong>卡常。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">605</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cur, cnt, id[maxn], dis[maxn][size];</span><br><span class="line"><span class="type">int</span> dep[maxn], len[maxn], f[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cost[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>())</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">    cost[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span> (u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[u][i]] &gt;= dep[v]) u = f[u][i];</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (f[u][i] ^ f[v][i])</span><br><span class="line">            u = f[u][i], v = f[v][i];</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = dep[p] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = p, dis[u][id[u]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">18</span>; ++i)</span><br><span class="line">         f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i] == p) <span class="keyword">continue</span>;</span><br><span class="line">        len[edge[i]] = len[u] + cost[i];</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edge[i]][j] == inf) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u][j] = <span class="built_in">min</span>(dis[edge[i]][j] + cost[i], dis[u][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = len[u] - len[f[u][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[f[u][<span class="number">0</span>]][i] == inf) <span class="keyword">continue</span>;</span><br><span class="line">            dis[u][i] = <span class="built_in">min</span>(dis[u][i], dis[f[u][<span class="number">0</span>]][i] + tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i] == f[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">realdis</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> len[u] + len[v] - len[<span class="built_in">get_lca</span>(u, v)] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">pow</span>(n, <span class="number">0.4444</span>) + <span class="number">1</span>;</span><br><span class="line">    cnt = (n - <span class="number">1</span>) / m + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span> (dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = (i - <span class="number">1</span>) / m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i) &#123;</span><br><span class="line">        u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(u, v, w), <span class="built_in">addedge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> l, r, x, ans;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), ans = inf;</span><br><span class="line">        <span class="keyword">if</span> (id[l] == id[r]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">realdis</span>(x, i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = id[l] + <span class="number">1</span>; i &lt; id[r]; ++i) ans = <span class="built_in">min</span>(ans, dis[x][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; id[i] == id[l]; ++i) ans = <span class="built_in">min</span>(ans, <span class="built_in">realdis</span>(x, i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; id[i] == id[r]; --i) ans = <span class="built_in">min</span>(ans, <span class="built_in">realdis</span>(x, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="STD"><a href="#STD" class="headerlink" title="STD"></a>STD</h2><p>考虑分治，按线段树的方式把询问区间拆成 $O(\log⁡n)$ 段，插到线段树上</p>
<ul>
<li><p>对线段树上每个节点把对应区间内所有节点和插到节点上的所有询问点拿出来建虚树处理答案</p>
</li>
<li><p>虚树总节点数 $O((n+m)\log⁡n)$</p>
</li>
<li><p>实现精细一点可以做到 $O((n+m) \log⁡n)$ 的时间复杂度</p>
</li>
<li><p>当然 $O((n+m)\log^2⁡n)$也能过</p>
</li>
</ul>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1&lt;&lt;29</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> n,bel[<span class="number">17</span>][N],Root[<span class="number">17</span>][N];</span><br><span class="line"><span class="type">int</span> head[N],next[N&lt;&lt;<span class="number">1</span>],end[N&lt;&lt;<span class="number">1</span>],len[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> q=<span class="number">1</span>;</span><br><span class="line">	end[q]=b;</span><br><span class="line">	next[q]=head[a];</span><br><span class="line">	head[a]=q;</span><br><span class="line">	len[q++]=l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l)</span></span>&#123;</span><br><span class="line">	<span class="built_in">addedge</span>(a,b,l);</span><br><span class="line">	<span class="built_in">addedge</span>(b,a,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) S[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) S[x].r</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,re;</span><br><span class="line">&#125;S[<span class="number">15000010</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span>&amp;q,<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">int</span> ins,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!q)&#123;</span><br><span class="line">		q=++cnt;</span><br><span class="line">		S[q].re=d;</span><br><span class="line">	&#125;</span><br><span class="line">	S[q].re=<span class="built_in">min</span>(S[q].re,d);</span><br><span class="line">	<span class="keyword">if</span>(tl==tr)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ins&lt;=mid)</span><br><span class="line">		<span class="built_in">Insert</span>(S[q].l,tl,mid,ins,d);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">Insert</span>(S[q].r,mid+<span class="number">1</span>,tr,ins,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> q,<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">int</span> dl,<span class="type">int</span> dr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!q)</span><br><span class="line">		<span class="keyword">return</span> INF;</span><br><span class="line">	<span class="keyword">if</span>(dl&lt;=tl&amp;&amp;tr&lt;=dr)</span><br><span class="line">		<span class="keyword">return</span> S[q].re;</span><br><span class="line">	<span class="type">int</span> mid=(tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(dr&lt;=mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Query</span>(S[q].l,tl,mid,dl,dr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(dl&gt;mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Query</span>(S[q].r,mid+<span class="number">1</span>,tr,dl,dr);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Query</span>(S[q].l,tl,mid,dl,mid),<span class="built_in">Query</span>(S[q].r,mid+<span class="number">1</span>,tr,mid+<span class="number">1</span>,dr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N],fr,ta;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">	<span class="type">int</span> re[N],t[N],tclock,init;</span><br><span class="line">	<span class="built_in">Array</span>():<span class="built_in">tclock</span>(<span class="number">0</span>),<span class="built_in">init</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span>&amp;x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[x]!=tclock)</span><br><span class="line">			t[x]=tclock,re[x]=init;</span><br><span class="line">		<span class="keyword">return</span> re[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">		t[x]=tclock;</span><br><span class="line">		re[x]=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;pa;</span><br><span class="line"><span class="type">int</span> seq[N],id;</span><br><span class="line"><span class="type">int</span> size[N],dis[<span class="number">17</span>][N];</span><br><span class="line"><span class="type">bool</span> ban[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	fr=ta=<span class="number">0</span>;</span><br><span class="line">	q[ta++]=x;</span><br><span class="line">	id=<span class="number">0</span>,seq[++id]=x;</span><br><span class="line">	++pa.tclock;</span><br><span class="line">	<span class="keyword">while</span>(fr^ta)&#123;</span><br><span class="line">		i=q[fr++];</span><br><span class="line">		<span class="keyword">for</span>(j=head[i];j;j=next[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(pa[i]!=end[j]&amp;&amp;!ban[end[j]])&#123;</span><br><span class="line">				pa.<span class="built_in">modify</span>(end[j],i);</span><br><span class="line">				q[ta++]=seq[++id]=end[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Maxsize,real_Root;</span><br><span class="line">	<span class="keyword">for</span>(i=id;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">		size[seq[i]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=head[seq[i]];j;j=next[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(end[j]!=pa[seq[i]]&amp;&amp;!ban[end[j]])</span><br><span class="line">				size[seq[i]]+=size[end[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(size[x]==<span class="number">1</span>)&#123;</span><br><span class="line">		bel[dep][x]=x;</span><br><span class="line">		<span class="built_in">Insert</span>(Root[dep][x],<span class="number">1</span>,n,x,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=id;++i)&#123;</span><br><span class="line">		Maxsize=size[x]-size[seq[i]];</span><br><span class="line">		<span class="keyword">for</span>(j=head[seq[i]];j;j=next[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(end[j]!=pa[seq[i]]&amp;&amp;!ban[end[j]])</span><br><span class="line">				Maxsize=<span class="built_in">max</span>(Maxsize,size[end[j]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(Maxsize&lt;=size[x]/<span class="number">2</span>)</span><br><span class="line">			real_Root=seq[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fr=ta=<span class="number">0</span>;</span><br><span class="line">	q[ta++]=real_Root;</span><br><span class="line">	++pa.tclock;</span><br><span class="line">	dis[dep][real_Root]=<span class="number">0</span>;</span><br><span class="line">	bel[dep][real_Root]=real_Root;</span><br><span class="line">	<span class="built_in">Insert</span>(Root[dep][real_Root],<span class="number">1</span>,n,real_Root,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(fr^ta)&#123;</span><br><span class="line">		i=q[fr++];</span><br><span class="line">		<span class="keyword">for</span>(j=head[i];j;j=next[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(end[j]!=pa[i]&amp;&amp;!ban[end[j]])&#123;</span><br><span class="line">				pa.<span class="built_in">modify</span>(end[j],i);</span><br><span class="line">				dis[dep][end[j]]=dis[dep][i]+len[j];</span><br><span class="line">				bel[dep][end[j]]=real_Root;</span><br><span class="line">				<span class="built_in">Insert</span>(Root[dep][real_Root],<span class="number">1</span>,n,end[j],dis[dep][end[j]]);</span><br><span class="line">				q[ta++]=end[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ban[real_Root]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(j=head[real_Root];j;j=next[j])</span><br><span class="line">		<span class="keyword">if</span>(!ban[end[j]])</span><br><span class="line">			<span class="built_in">solve</span>(end[j],dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c),<span class="built_in">make</span>(a,b,c);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="type">int</span> l,r,x,re;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">		re=INF;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">17</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bel[i][x])</span><br><span class="line">				re=<span class="built_in">min</span>(re,dis[i][x]+<span class="built_in">Query</span>(Root[i][bel[i][x]],<span class="number">1</span>,n,l,r));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,re);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>分块</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>T20221120</title>
    <url>/AlanTuringLi/2022/11/20/T20221120/</url>
    <content><![CDATA[<h1 id="A-Awa开小车"><a href="#A-Awa开小车" class="headerlink" title="A   Awa开小车"></a>A   <a href="https://ac.nowcoder.com/acm/contest/44887/A">Awa开小车</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Awa正在玩一款名叫明日方舟的游戏。 </p>
<p>这款游戏在一个高度为n，宽度为m的网格上进行，玩家可以部署干员在格子上来击败敌人。</p>
<p>在这个问题中，我们定义第x行，第y列的格子的坐标为(x,y)，也就是说，从左上角到左下角依次为(1,1),(2,1),…,(n-1,1),(n,1)，从左上角到右上角依次为(1,1),(1,2),…,(1,m-1),(1,m)，右下角的格子坐标为(n,m) </p>
<p>在最新的一次活动中，场地上会有一个名叫“小车发射器”的装置，Awa在这里召唤小车！同时，Awa可以在其他格子上部署<strong>导向板</strong>：当小车开到一个<strong>未触发</strong>的导向板上时，小车就会按照导向板指向的方向前进，而当小车<strong>开出地图</strong>了，小车就会自爆！（在这个问题中，小车的油非常充足，只要没有自爆就会沿着当前行驶方向一直移动，同时，我们不考虑小车发射器的碰撞体积，也就是说<strong>小车发射器发射完小车就会消失，不会影响小车的后续运动</strong>） </p>
<p>当然，因为Awa的干员练度达到了力大砖飞的境界，他并不需要通过小车的帮助来击败敌人，因此，他非常随意的在地图上摆满了导向板，然后开动小车。同时，他非常好奇<strong>小车一共能转向多少次</strong>，因为小车开的太慢了，Awa懒得去数，因此他把这个问题扔给了你。 </p>
<p>90度和180度转弯都算作“一次转向”，每个导向板只会在第一次走到的时候被触发，初始位置的导向板会被触发。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行四个正整数 $n,m,x,y$，表示矩形区域大小为 $n$ 行 $m$ 列，以及小车发射器的位置 $(x,y)$<br>（对应位置上的方向就是小车的初始方向）之后 $n$ 行每行 $m$ 个字符 $U,D,L,R$ 之一，表示该格子的导向板类型，或者小车的初始方向。</p>
<p>$U$：向上；     $D$：向下；      $L$：向左；      $R$：向右</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>一个非负整数，表示小车的转向次数</p>
<blockquote>
<p>模拟就好了，没什么难度</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, x, y, ans;</span><br><span class="line"><span class="type">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> my[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">std::string board[<span class="number">105</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">std::map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id[<span class="string">&#x27;U&#x27;</span>] = <span class="number">1</span>, id[<span class="string">&#x27;D&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    id[<span class="string">&#x27;L&#x27;</span>] = <span class="number">3</span>, id[<span class="string">&#x27;R&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        std::cin &gt;&gt; board[i];</span><br><span class="line"></span><br><span class="line">    x--, y--;</span><br><span class="line">    <span class="type">int</span> nx = x + mx[id[board[x][y]]];</span><br><span class="line">    <span class="type">int</span> ny = y + my[id[board[x][y]]];</span><br><span class="line">    <span class="keyword">while</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m) &#123;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis[nx][ny]) board[nx][ny] = board[x][y];</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] ^ board[nx][ny]) ++ans;</span><br><span class="line">        x = nx, y = ny;</span><br><span class="line">        nx = x + mx[id[board[x][y]]];</span><br><span class="line">        ny = y + my[id[board[x][y]]];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>

    </div>
</div>
</blockquote>
<h1 id="B-JokerXuan的明星梦"><a href="#B-JokerXuan的明星梦" class="headerlink" title="B   JokerXuan的明星梦_"></a>B   <a href="https://ac.nowcoder.com/acm/contest/44887/B">JokerXuan的明星梦_</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>过于冗杂，略</p>
</blockquote>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个正整数 $T(1 \le T \le 3 \times 10^5)$ ，表示从薛之谦开始发博客到自己忘记密码过去了多少天。</p>
<p>接下来 $T$ 行，每行有一个字符串 $S(hh:mm)$ 表示发博客的时间或 “<strong>null</strong>“ 表示当天没有发博客，如果发了博客，当天的幸运数字为 $X(0 \le X \le 2^{30})$ 。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>一共 $T$ 行。</p>
<p>每行一个正整数代表当天的幸运数字 $A$ 。</p>
<blockquote>
<p>本质上是需要知道最终的幸运数字二进制下的状态。</p>
<p><strong>想法一</strong>：用一个二位数组，表示第 $k$ 位最初为 $0/1$ 经过所有操作后的状态，可以更新 <strong>null</strong>，期望时间复杂度 $O(kn)$。</p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::bitset &lt;31&gt; num;</span><br><span class="line">std::bitset &lt;31&gt; update[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, x, tim;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> opt[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) </span><br><span class="line">    <span class="keyword">if</span> (num[i]) num[i] = update[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">else</span> num[i] = update[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) update[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>  (<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>) <span class="built_in">upt</span>();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sscanf</span> (opt, <span class="string">&quot;%d&quot;</span>, &amp;tim);</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) num = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tim &lt; <span class="number">12</span>)</span><br><span class="line">                num &amp;= x, update[<span class="number">0</span>] &amp;= x, update[<span class="number">1</span>] &amp;= x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">12</span> &lt;= tim &amp;&amp; tim &lt; <span class="number">18</span>) </span><br><span class="line">                num |= x, update[<span class="number">0</span>] |= x, update[<span class="number">1</span>] |= x;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                num ^= x, update[<span class="number">0</span>] ^= x, update[<span class="number">1</span>] ^= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; num.<span class="built_in">to_ullong</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//bitset作为十进制数输出</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>
<blockquote>
<p>进一步考虑优化 $upt$ 函数，能否优化掉这个 $log$ ?</p>
<p>考虑什么样的变化可以对答案产生贡献 ？</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        answer
    </div>
    <div class='spoiler-content'>
        <blockquote>
<p>$1\rightarrow1\quad 0\rightarrow1$</p>
</blockquote>

    </div>
</div>
<p>即答案可以看作操作数 与 或 按位取反再与 $0/1$ 开头的前缀，和上面有点相似。</p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::bitset &lt;31&gt; num[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> n, x, tim;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opt[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    num[<span class="number">1</span>] = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>  (<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>) </span><br><span class="line">            num[<span class="number">2</span>] = (num[<span class="number">2</span>] &amp; num[<span class="number">1</span>]) | (~num[<span class="number">2</span>] &amp; num[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sscanf</span> (opt, <span class="string">&quot;%d&quot;</span>, &amp;tim);</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) num[<span class="number">2</span>] = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tim &lt; <span class="number">12</span>)</span><br><span class="line">                num[<span class="number">2</span>] &amp;= x, num[<span class="number">0</span>] &amp;= x, num[<span class="number">1</span>] &amp;= x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">12</span> &lt;= tim &amp;&amp; tim &lt; <span class="number">18</span>) </span><br><span class="line">                num[<span class="number">2</span>] |= x, num[<span class="number">0</span>] |= x, num[<span class="number">1</span>] |= x;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                num[<span class="number">2</span>] ^= x, num[<span class="number">0</span>] ^= x, num[<span class="number">1</span>] ^= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; num[<span class="number">2</span>].<span class="built_in">to_ullong</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="E-急急国王修公路"><a href="#E-急急国王修公路" class="headerlink" title="E 急急国王修公路"></a>E <a href="https://ac.nowcoder.com/acm/contest/44887/e">急急国王修公路</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>急急国王的国家里有 $N$ 座城池，标号为 $1 \sim N$，以及 $M$ 条双向道路，第 $i$ 条道路 $(1\le i \le M)$ 连接了城池$u_i$ 和 $v_i$。 </p>
<p> 最初，国内的城池被分为一些州，每个州内部的城池互相可达，而任意两个州之间互不可达，即一个州的任意城池与另一个州的任意城池互不可达。</p>
<p> 急急国王希望修建一些新道路，使得国民可以从任意一座城池出发，去到所有其他城池（即任意两座城池都是互相可达的）。</p>
<p> 由于人力物力的限制，<strong>每座城池最多只能再新建一条道路</strong>。且为了安全考虑，每个州新修建的道路数量不能过多，否则当一个州被敌国攻陷时，其他州也将面临较大的危机。</p>
<p> 现在他想知道，每个州新修建的道路数量最低不超过多少时，可以使得各州互通。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>第 $1$ 行：两个整数 $N,M\quad 1 \le N \le 2 \times10^5, 1 \le M \le min\left(6\times10^5,\frac{N\times (N-1)}{2}\right)$。</p>
<p>第 $2\sim M$ 行：共有 $M $行，每行 $2$ 个整数 $u$、$v$，表示一条连接 $u$、$v$ 的双向道路。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>一个整数，表示可以使各州互通时，每个州新修建的道路数量上限的最小值。若无论如何都不能使各州互通，则输出 $-1$。</p>
<blockquote>
<p>贪心：尽可能平均</p>
<p>特殊情况：叶子节点</p>
<p>考虑到叶子节点的特殊性，它只能连一条边，那就先不考虑它🐕</p>
<p>先将度数大于一的点连成一条链，此时答案已经为二</p>
<p>再考虑将叶子节点连到链上，注意两端的处理</p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, u, v, cnt, siz, num;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[maxn];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++siz;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> son : edge[x])</span><br><span class="line">        <span class="keyword">if</span> (!vis[son]) <span class="built_in">getc</span>(son);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span> (<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span> (v);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span> (u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            siz = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">getc</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (siz == <span class="number">1</span>) ++num;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">push_back</span> (siz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cnt - <span class="number">1</span>) * <span class="number">2</span> &gt; n) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">ans</span>(<span class="number">2</span>);</span><br><span class="line">        s[<span class="number">0</span>]++, s[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) s[<span class="number">0</span>]--, num--;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) s[<span class="number">1</span>]--, num--;</span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;res : s)</span><br><span class="line">                <span class="keyword">if</span> (res &gt; <span class="number">2</span> &amp;&amp; num) --res, --num;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="I-优雅太优雅了"><a href="#I-优雅太优雅了" class="headerlink" title="I 优雅太优雅了"></a>I <a href="https://ac.nowcoder.com/acm/contest/44887/I">优雅太优雅了</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>在维护世界和平的道路上，阿尼亚负重前行。为成为皇帝的学徒，优雅的亨利·亨德森老师对她展开了考试。 </p>
<p>  亨利·亨德森认为对于一个有 $n$ 个正整数的数组 $A$</p>
<p> 当且仅当对于任意一个下标区间 $[l,r] \left(1\leq l&lt;r\leq n-1\right)$  都满足$min(A[l],A[l+1],….A[r-1],A[r]) \geq gcd(A[l],A[l+1],….A[r-1],A[r+1])$</p>
<p> 这个数组才是优雅的数组。</p>
<p> 现在亨德森给可爱的阿尼亚一个长度为 $n$ 的数组 $A$，要求阿尼亚立刻回答出这个数组是否优雅。但可爱的阿尼亚太笨了，于是她向聪明的你求助，你需要帮助阿尼亚做出正确的回答。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个整数 $n(2 \le n \le 2×10^5)$。</p>
<p>第二行输入nnn个整数 $A<a href="1 \le A[i] \le 10^9">i</a>$。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出仅一行，若是优雅的数组则输出 $\text{“Elegant”}$，反之则输出 $\text{“Rude”}$。(不包含引号）</p>
<blockquote>
<p>考虑：若 $\min{b, c}\ge\gcd{b,d}$ 成立，则 $\min{a, b, c}\ge\gcd{a,b,d}$ 一定成立</p>
<p>所以只需验证 $\min{b, c}\ge\gcd{b,d}$ 是否成立</p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span> (y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span> (<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">min</span>(a[i - <span class="number">1</span>], a[i]) &lt; <span class="built_in">gcd</span>(a[i - <span class="number">1</span>], a[i + <span class="number">1</span>])) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) std::cout &lt;&lt; <span class="string">&quot;Rude\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;Elegant\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>Telephone Line S</title>
    <url>/AlanTuringLi/2020/09/15/Telephone-Line-S/</url>
    <content><![CDATA[<h1 id="Telephone-Line-S"><a href="#Telephone-Line-S" class="headerlink" title="Telephone Line S"></a><a href="https://ac.nowcoder.com/acm/problem/24950">Telephone Line S</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>首先你有一张图，问你从$1$到$n$的路径中第$k+1$条最大的边最小有多大</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题很显然是可以二分答案的</p>
<p>但是我们考虑换一种做法：分层图</p>
<p>那么就是跨层的时候让其代价为$0$，那么一共就有$k+1$层图</p>
<p>在跑一个类似最短路的东西就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, k, cur;</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn], __prev[maxn], cost[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _addedge(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    __prev[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">    cost[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __addedge(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    _addedge(u, v, w), _addedge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    deque &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop_front</span>();</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i; i = __prev[i]) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> v = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &lt;= <span class="built_in">max</span>(dis[now], cost[i])) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = <span class="built_in">max</span>(dis[now], cost[i]);</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">empty</span>() || dis[v] &lt;= dis[Q.<span class="built_in">front</span>()]) Q.<span class="built_in">push_front</span>(v);</span><br><span class="line">            <span class="keyword">else</span> Q.<span class="built_in">push_back</span>(v);</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[n * (k + <span class="number">1</span>)] == inf) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, dis[n * (k + <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), p = __read(), k = __read();</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="type">int</span> u = __read(), v = __read(), a = __read();</span><br><span class="line">        __addedge(u, v, a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            __addedge(i * n + u, i * n + v, a);</span><br><span class="line">            _addedge((i - <span class="number">1</span>) * n + u, i * n + v, <span class="number">0</span>);</span><br><span class="line">            _addedge((i - <span class="number">1</span>) * n + v, i * n + u, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SPFA</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/AlanTuringLi/2020/09/15/Tree/</url>
    <content><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a><a href="https://ac.nowcoder.com/acm/problem/112609">Tree</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><ul>
<li>首先，我们有$Q$次操作</li>
</ul>
<blockquote>
<ul>
<li>操作$1$：在节点$R$下面再加一个权值为$W$的点</li>
<li>操作$2$：询问从点$X$开始往上走，（每次遇到权值大于当前选过的最后一个点的点必定会选），问最多能选多少点</li>
</ul>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以很容易的发现，我们选中的点一定是一个单调不下降序列</p>
<p>那么就是说，我们可以稍微改动一下操作一，让每一条链都一定是单调不上升的（从根出发的链）</p>
<p>然后，我们每次加入的点必定不会是已经存在的某个点的祖先，所以我们改变他的位置对原来的树是没有影响的</p>
<p>若有节点成为了这个被我们认为操作的节点的儿子，它的值依赖于我们人为操作的那个点，所以这个答案也不会因为我们的操作出现问题</p>
<p>那么我们就可以在加入节点的时候，找到第一个权值大于该节点的点做为这个点的父节点</p>
<p>顺便跟新一下前缀和</p>
<p>这个用倍增实现就好了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后查询的话，能跳就跳，每次向上跳了更新一下限制即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);<span class="comment">//向上跳了2的i次方层，那就有2的i次方个点</span></span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">0x6f6f6f6f6f6f6f6f</span>;</span><br><span class="line"></span><br><span class="line">ll father[maxn][<span class="number">20</span>], wight[maxn], <span class="built_in">cnt</span>(<span class="number">1</span>);</span><br><span class="line">ll sum[maxn][<span class="number">20</span>], lastans, limit;</span><br><span class="line">ll Q, Opt, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (sum, <span class="number">0x6f</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    wight[<span class="number">0</span>] = inf;</span><br><span class="line">    Q = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        Opt = <span class="built_in">Read</span>(), X = <span class="built_in">Read</span>() ^ lastans, Y = <span class="built_in">Read</span>() ^ lastans;</span><br><span class="line">        <span class="keyword">if</span> (Opt == <span class="number">1</span>) <span class="built_in">AddPoint</span>(X, Y);</span><br><span class="line">        <span class="keyword">else</span> limit = Y, <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, lastans = <span class="built_in">Query</span>(X));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>[USACO19DEC]Greedy Pie Eaters P</title>
    <url>/AlanTuringLi/2020/09/24/USACO19DEC-Greedy-Pie-Eaters-P/</url>
    <content><![CDATA[<h1 id="USACO19DEC-Greedy-Pie-Eaters-P"><a href="#USACO19DEC-Greedy-Pie-Eaters-P" class="headerlink" title="[USACO19DEC]Greedy Pie Eaters P"></a><a href="https://www.luogu.com.cn/problem/P5851">[USACO19DEC]Greedy Pie Eaters P</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$个派可以吃</p>
<p>有$m$头牛来吃</p>
<p>第$m$头牛的重量为$w_i$，这头牛要吃的区间为$[l_i,r_i]$</p>
<p>然后你是要保证每头牛都有的吃</p>
<p>那么你可以安排这些牛吃派的顺序</p>
<p>最后会得到这样一个序列$c_1,c_2\cdots c_n$</p>
<p>求：</p>
<script type="math/tex; mode=display">
ans = max(\sum_{i=1}^nw_{c_i})</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去像个贪心啥的</p>
<p>但是贪心不能保证每头牛都有得吃，所以我们考虑$Dp$</p>
<p>参考<a href="http://www.usaco.org/current/data/sol_pieaters_platinum_dec19.html">官方题解</a></p>
<p><img src="https://s1.ax1x.com/2020/09/24/0pYJ2R.png" alt=""></p>
<p>可以，就是这个意思</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="type">int</span> g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> w = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = l; p &lt;= r; ++p)</span><br><span class="line">            f[p][l][r] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; ++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = p; l &gt;= <span class="number">1</span>; --l)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = p; r &lt;= n; ++r)</span><br><span class="line">                f[p][l - <span class="number">1</span>][r] = <span class="built_in">max</span>(f[p][l - <span class="number">1</span>][r], f[p][l][r]),</span><br><span class="line">                f[p][l][r + <span class="number">1</span>] = <span class="built_in">max</span>(f[p][l][r + <span class="number">1</span>], f[p][l][r]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">1</span>; r &lt;= n; ++r)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = r; l; --l)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; ++k)</span><br><span class="line">                g[l][r] = <span class="built_in">max</span>(g[l][r], g[l][k - <span class="number">1</span>] + g[k + <span class="number">1</span>][r] + f[k][l][r]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, g[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>区间Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA11475</title>
    <url>/AlanTuringLi/2020/09/04/UVA11475/</url>
    <content><![CDATA[<h1 id="UVA11475-Extend-to-Palindrome"><a href="#UVA11475-Extend-to-Palindrome" class="headerlink" title="UVA11475[Extend to Palindrome]"></a><a href="https://www.luogu.com.cn/problem/UVA11475">UVA11475[Extend to Palindrome]</a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串$S$，让你找一个长度最小的回文串$P$使得$S$是$P$的前缀</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们能够构造出的最简单的回文串$P\prime=S+reverse(S)$</p>
<p>显然$P\prime$要尽量的小，那么$S$与$reverse(S)$就要尽可能地重叠</p>
<p>观察发现，尽可能重叠，其实是求得$S$末尾的最大的回文串</p>
<p>所以就有很多大佬用什么$\text{manacher、SA}$然而我都不会</p>
<p>那么我们重新想一想回文的定义，简单地说就是<del>正着读，倒着读是一样的</del></p>
<p>那么我们可以把$S$反转一下得到$S\prime$，做一次$\text{KMP}$看在$S$左后一个字符的最大匹配</p>
<p>那么这个值就是$S$后缀的最长回文串，那么需要补上的字符串不就可以直接输出了？</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="type">int</span> len, last, kmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span> (kmp, <span class="number">0</span>, <span class="keyword">sizeof</span> kmp);</span><br><span class="line">    <span class="built_in">memset</span> (b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="built_in">memcpy</span>(b + <span class="number">1</span>, a + <span class="number">1</span>, len);</span><br><span class="line">    <span class="built_in">reverse</span>(b + <span class="number">1</span>, b + len + <span class="number">1</span>);</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (last &amp;&amp; b[last + <span class="number">1</span>] != b[i]) last = kmp[last];</span><br><span class="line">        <span class="keyword">if</span> (b[last + <span class="number">1</span>] == b[i]) ++last;</span><br><span class="line">        kmp[i] = last;</span><br><span class="line">    &#125;</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (last &amp;&amp; a[i] != b[last + <span class="number">1</span>]) last = kmp[last];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[last + <span class="number">1</span>]) ++last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%s%s\n&quot;</span>, a + <span class="number">1</span>, b + last + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>))<span class="built_in">ac</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>ToMyself</title>
    <url>/AlanTuringLi/2020/07/23/ToMyself/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d1800325a337b9704271aa3b9020defd54667d4e2a82d8b40c069ad29a581b77">5a41be0f4c6cd2d64bf090e37c9b5e424d5357e499f5c4706c3f96f582d73f9375f1f301821494b900ad31bad1316dbb9d955334f8b49bf1484d3264e5af7dccc41aff40634df7ccfa7a249e14dad4a1eb230351e284c407f8ade62c6162412f28e61f194db320fa85e694dbf2b7cb7569cf84e7937f34a27ee60b0c0b9b40deec08e01c037ff5127cc8f7aaebf8126b7b6cb9c2d9db4237a6f9b1bac5fe65ad5f8fc5aad131ea5d1d95db73e7476a14e82be04a1ed7516f1767cd2caf4982da8b5aa463a5dcee44c9a3d48ce387c255b54ba5c7edc3456656daa193390acc3bf3569570124a54495e1b07fe54bde2a15e885f87d8928907e08c240b6811ef0b7fad308b531b8be16f85cc06c88531eafb144951fedda374d488bacfeb633e059839b9543fcd5ad44ab047d9cad0ba5ac72572c0f29db5a5075483b8b141fdd4fefbe77c61c366bc9ab03cb849d413988052bb0afb2731e0d603acfcef17b00317c7e7b6e29fa0c09d63bd5ca5209ecc68e467ed5572d383b4574f087088ae7b3b3a5f24115739207c3d360ba1db023ecb47004e409191014c9cd767834a872d671e6863e4c70108f4a99c02aea8ae84c2eb860894385fa6cd6a154d0c6adda6ef418746dc4d33e0adc294dbf1cf341ce0747aeddd01a5cfc99440042f360beb682283ef2149f1b2b66da19a92b3c395bb8a8ca067ab37b23827e248000e87c4308ec1933e16aca340a583bae7637c9571fcb4f147f50ba3b4d85bf4c332622b2066965d45a511d7783698b7b97ae5a024c71368e02160b16870bfc192f3712ba86afe40a206494b06dce07a60795e3e9255e5fb4c9f9803fb3b504262f2729c6a7f675ef6511e007f07d2a3f8a0892ee3dcbbdd587b76cb4b80d55957405527599bda340e43dc5533e51a335e6148d64afa16cd2d52a1946793f02006a9fe158e01e8e6cfe4303b33c0144177558e579d07d945b3b888f8298e4c5f35cc0cb98bf864b533b5df0ffa9d9153db8ae2f5a40d02f70b2612da256676450d53486bfba62e3e67870e685ec50e77fd912318e507f1969fcf26fa117e5eee8bb843dafccb7c9f3f5801b4ad06635dd1e71efe3e3a20de8320460773e748182ab6e14a15d3ccec294c2a78d4608fb5abaa020e01d430adc8575e86d1f2463161db6ee6b9cd53334db7014e52fdc0665dbd7d5373eaffeaa6b91b03bdbdc57eb05f74bc9974608f6f844c8c15a4937625ae7c4bca44169ec400f43ed4b64c3cd051b8f65c7d6af49f53ce4cca613e6047de8b70dd1c6fba8aca2e85957f57e01701ead5f25ecd9843ef23112604caa60a178e90ffd29a9d13d45dfdd0e5d4806898dfa676446130eccfb065a525b6483334ecef877df15ebdc305e4b4671841e2f1f26c9c06f31c72bf279caa5ba4bea4ed2566b2364ff2bd9e1f348b8658b61cc714025469ad4b2d37a7b8ee72325177de3625157565e0d91321204a4ac435e04c3dd89fc359f64515ec149b27ea3713c01620e4c66b9eee5fafd86369b5e689b0fe6a9dcbbb1d59bd55d4526a7a137f3b14158315eb1be7ba696f948e7cde22120c618c6baf4c0ebd5e186c3a5635a9483521497b457c438fa5789a68b696224367d3b4d3303db9315567a4e1f60e3e552b41b3ccb33142b41ddf0f608e1b7abd5090f31c439d0704a81007f97227835aba63c400b67eaf6c184df1ef7b79e9cad55f32ad1433ce76f07b04c281eb42ab9778382aa84e574d2eb54ad4a2830105c2f2c9a318a19b27bc001b65adbe184cfc68985c365f6491782a6ba8349aaf1c15bec640f10f5dd1aaf12ea48a77c5644c289494bc1baf2cb75b0fa3c2c15dea5c42c9842d4e8d7bb68a218f7fa17cac80905cb95c82a65d26f8ccc4831c2988da12889573dde232589f01b7e8c0bc9f264bb4219225ad5a76f2892d6b6eee1e898c68f3a21b10b208a5a53f126c6c913ec163e675acf90f65d9d3ad183e807d6c1e50e5578666bcf019c5ef2c0ea0c9473926b69b27f5f3713a10f2a0a46e6ab8a22ab40ceb05821290291ccc80619b84f4857d90c7ea2bdb72aca81bc1df5ba16d43bdb421d29a31bc7f9378cdb902469b0d00bc28fb8355a6848e858ef2851c3ec3382edb20b467410f44375aeb91e3aaa91d18799d61f71bc9184682969e585e0826eb1de6052a5e303dc166d2778f5498b9fcfb499fc559d343f479a136298c67700019373e9fb8c15030c48c57963d50df1c77b4c966efa9a10d196b5227abb3f5189f1aa8f09db48e390d368b4e6d2d0ad904fbe7ed824689c013e0b3c50b6060c79d9a7a66b9e92a8b2e60d7105d21d87baaa3b418def46dbc72be2c4ebb60d4ec802216939e86519ab00f096d3ce32d5bc59e54071ab394564f6e92b0360145af0357cb7cf472724fa5a3c405928b08377872d4667e177cf796b9f9a3b9b11fd1223eb00feab152b1261bf33423bc9cbcff63e9372d2fa19f01453b482e5af19b3071e75d7bb87028da6f5db21058daaa288ddf2a180ee4dfc6e20c0e4af318653c2ec06e638a7259c205ad37d166678f687ebaa4141b5279ae14eff391e3002e02c3db8e936879ad55c4e2f8d9918337ab4358651af098576ed206f0e57b2de00fc03bc20f293754fa32110b65017eda81c365b686b7714b94a83aa2d8c718153f603b5797cb1d191273d11d3a4a00990c7b3c0364600363d0252ecbcb402bfe83d0e4e8666b6b8297d1b49d77769e47b033e52722cdb2190fdafa4d900d2826d8ceab2c70ab6cbdec41e42e95800bc83112f0149b161af0ba8d731cb2ae778bc9945196c5aeb629efc48eaa9d32ad8b055bebda2eac6aff57ab9c62eadefc2e7d75279585cf98ccfaa92ab2c8418062ac52a569ba5b9a1cb12b4dd69fe0892b269222e158ec8a0ec7c37dc3f61e0faa0953bca01b9e11e567db44f603320524635bce5884c0f4435046981e54cfc95804939589a73b732ac2b9161d439951f4efe11fa2fcd8ee124d14dc753225f84aa322c297f4836dfc15cc35b68e8c68812673e7b9d6f7612e6140ef6caff76faa648682df62f8557173112ec22e1327d2438132a7133e2a0e3b87d83b3551824424ff674c2fd1f77e2a9a6077ca5894e1952e5bc1e025216c8d977e0c4b392801d197d1a26d08744cb4ad43ac2240575b5c61146685121aea127f117508ca2a0ba567045f0223acd4c50b854d1f032574d8c23a6f08100dd52c8e845965db31428290fcf3be0a85b50d4582e96b200679cae0dc1cbdd9fcee29641f56da99790e002595052377feaef3f574b42532184f8a0b9831153c4fd39317f1db8e282b7c7003c34ed5aa755c713b0ec014d0c409841b1c036797a3bcd2e84a39b5ce77b1fb3c65486c1532a2afd423590b3c49bfc10f7db323c4996da99a80c10ae125e75079fe8779d8331812afb95867ac97835364bb5d6fb7173a574c5a64e5df7289f8913733b5d00c3b05b08db1012d06cfd5050c53599eb222a0c1d34b19864158f90cb8961eaf54119d892b500b2b48a1d5f4fc73087932ffd814657353095c3e44a22177693536163962f19038dec8d2363767ea7e420273a17f3ad97e32c7bf33d0be673e0a23f3618385f8be2cbaa56bbbff52e9f6ac7a90da6ec2cae46ae72fa8bda9cdb26b4f7965dcb41605f9a1d1093fa0d6e6439a99d7a26dc99814cef0a16231974482ae20b9be27862959368b81e6121df568a6b7f89cf4aecda83e180d85b5dd4573f4d32797f844b6f4b88223e0b28a438fa7132ecd1dafc01dc966f6d26f48a8a78d596ee9c5ff2cfeecfbe32f9d4fc02fd8d3c5c97edbc1e258a73eb101a9a128b4ebff7933708073e2c63ed96cbfc0b993fc1a48cbed00ca89f2c99f32dd0ae3f12c4b717002b07e67cb870a79c8611e131b79afababc3f990b1da7315b5b50591fe42881e08ffb3f47a6b06e005ffe6b9e5fcc524d52c491a45fdec449cb4d6f1b8253179933aae0d01cb0c24dc7b3512d3bd6f90acd94e81274a97a271937d49c760830d49e1b8eb0f3da1b4c2e1648871776de77ea52738fb228f12e34f110504ffebee43ece4b4dc3dd66655a69c4830f2628b438fe646aeaac52e829de50c28440102d7131937a66ef0fc2d642db46c424592510bf0b28dd8773bb504bfaa50f5ed26719710c915f17008b892a43f1acdd16807e3ef0cf27769ffd6f34a566612b78a18d4a3f4199778efe22704565c60fd634e849e0c279e1e348d44340ef494a7dd5dc45eb782decb1f004791239f00dc82d01d688f3bd160a390e7246862add9e1f8c9a9062ba26e9c94c8522dd954af7197be101472026f198b2da4459a8a79fd333f95b78ee854b84dc4bd2ce3afd7f7a516f041e3cb2152e57c0d21cd9eca0d705e191217a2a772bfc0755fbb47eaf1d7e82380abfa1d8408a6f55d800b6a311804c42a979bbfaae5069b30524fd84671a0665a64b5415dbce01a022b567c1d950f0be41f21a2fe563d8fbcd28cdeac88802c3d914c0f842d31e89ef84fc0210a3b6a7fa411789b7e3e0075f5240201dcbbb8f29b4018f0f453d49dbba49acef3cae89bb4996391e297717c27cd024d408414fa338558fbfab33021357b4e67ab5d235d6fb0092a4f63d12ff9e3f7cbbc22a306f7d6a068cc5d763dcfe91c677f6e61ee509262a0031aa265f5236d131379d8912f95d01059027fa749a98927cea710ebaa68db0dc84b709cb526e247cacfc90c1588250e7b289b84fabaffa5d2ae281c596f91196cbeb3d278d67a409f84fae95b27a527f3db191da13c29935b303c795b17c968a35dfdd99e66b8aafcded96d70de0b14ee769231af624873c4dbd8e70d881d2513509b22d23040603a0b045e61ddaf3f0dcb22827e1765b2f82f2ba0195669625d18a07f242dabac956b8dfad06e57e167e5aaf1fd6cccf51a5c0aa5997bd5e8d288be2a47e4379a53151d9c9f8cd0bc87d024c3a0735e8be678492c1fa4264a9b2cfbb078d8aec96f734b90cd638bdae3b15564d5ec2448d2412a58e0e22b2f2937516da36e2d33b45a37eb5acf6e1a370c8c5eb07a4ee45942b9d28ab07602b5a465a141d86e78af3f3b844f7599aad68c75945152faf86a49c6721ae9bcf60b14b746ce23c37883ca47269fee2a7f5885430e28cd8551745549b95225713cc9183e0fba2c074854040ae5961c7cf2d2d5c007e483a2a984659517f850227c17cfb9b7f52d69b82bba736baa618045b9659b72266bd28296020d278aa97873dea2abc335cc45c95402c490ae6de4ade0053d8be252e31923fc9c15c41219926335f355360102e655a048ad7423fc8001738b6051d067fb378d641c8cc6e1ae607a424218619a564cd82587b26f1f38107d0bfc8510f7fe68f624964818faca474c2f28ecae00c91d1214c4954c1827bf6540f1b9173fd2a519afc3699f9f08d882f34f3d202a5ef5acf855affb598f45f54f6a4cb479f593c8d1a263481c2fac97de6931b36d3feefcde69547ce5ab41db5eab1f330ef0d2938481b763a214c81391d3a64342998bb9be64653e2c1f0a372878adf9999680f5342b801b44d4b186469be0104e7ca23803a0c1afabcda2f61f9488efd88125a5da8f3fa33bc7fd875c440050490105a3d23de61a4160d50622a8383ce006c0c90adeb64a15701d28ce24ab215230329fe8c59ea89f349b3c386b9ee945fb52cbcd631b11ac6144e28ddbbfcce5990de4d918923c54b0243b0423b829452179b3305522dfd2b3f3601f896adc1d50d1b62ec2540468c58437f1e2eafc4c1303f69488c0e5c1768fa7e9c85a6bce8f5fe58684e999de0a4e15218706ca1bc1617be4d476abe697fc8edb97cffddd62c1a0b0b0b7faae763299e19734ed9b439eb19110951e471db408f0a24cfa7391770c3d318599a0f517e8a4e6247cf4cd8d1ed8d492d9c0cb59c1682596cdce22c4d7eb1de6d404fad459d90b0d7ed296eea5c8a85b6bf7b05164566f9bbc71f96815f7027fddd41a251e5a4abe013b4b98603c6d59174cef69451bddba9fb10715cad309b17b667d99ffad9da4594d6ca42a068b8c5a6a9b03c6b554b0f8dcf05a386ebf8a814aa4d29b70fa48a2dde41a34f8d74dedc6014ca1d130fd2920308704912af309ef88072a6103f3d050f1661b8dc1fb8f530d577f9fe9a5d6deb4d79740e5bf2daf437aeef83ab75ded960199cb5fa61694b944537cb27ed83bf9f7207729f12dc14869f4af089b8fde9d2c72d299992534db9df1e29359a10fa476572ecd2b00eff7b536d6a05e3c3c1fd6e72bcd634bfc7a22f32c61b9c21320f18e3748974625af5c1f833be9856f880d1d683025c278fba31e29cf6661b6c518cee0cf67d6caeb39f590dede5b39a850ee89ff2c36c3452852a6046d01eddfc8d4c2b32b622b07735a03c20920272cb862aa0f8e5e26bf8ffc36a10fa2c6c082f5eb9d0aebf85c382fe4dc3d1b8967a8967e8d2545bfda036008ef595fcf679fcd29d5366feec9f20cb2ead776ca113def018be869659f32bc7bcc1d1607855ea33678f2348895cb20df1ff9c725aa5c714fccc89dd16abb5bc3305c1ff64fdd126b9c115eaa8a830e463b14914e19e2b0e433005314ef6c7148db2e88951eee8d444f25e8aa8efb417fe9b40b4f0280d02e500d76ef2feccfd16c9c5bf872612d6041108be20e13b58aa91e8b2ded6a6ca89c44ec551111472c314e949222368a8b9ecc814f6fc4789467f75fcdc528d0c8eeb60647a88edbb2fd503814e0cbf60a9269935f18eb01c317d07e6ca708b761e8e8215a7686230d8ffea64b6883cde80e0f2d896ade783ea906b05e73bafa5d3adf90f2884e76681ab0c9387ecad2219f2824fdc6384bfed2a711dcfef2c86fd1f6a3228d07ba363e17cc3665af7c4b9bc7893a83efb0ee4bafd734ed63a48dc47ebb5be439e277757a2c8f783f27f2b5b8296ea198db8375d6518c9c4d6eeaf110f0233d203debef53e15efb8a491958e018680c0b5f725ffb71d38d0da3dcd762becac86d08b45c1855e1e3bab2d5516548f492ee168e2a59a7ca2a9fc04097c4343c08258607d26b0e6d2c502021b134e3ba92407b6c040bc3abfb07327419879a416151817c4e53b84bb560b72c06d69a1505b44ae80c60828b7c39971fb82601979d600b971beb6c6a3e48184085fb95bf8c72e1c90abac921d06e618675df2ffd45faeeeddac3ae2672a0a18c9423abf31031d3f21f312713f65ee2c0d1d59817f0ebb7b967a54e3a98f06f107b0a92fd3e2771ce59d3e5df4e05ac8858f21a416890e38b89e412127925cb04b3d3e71ec8be4e6c5926a07624ce388fc23cc0e9fed597c336402899fc452ca61daa3fe775d44a06ed88e433ca28195c4a51fa09c544edd687dfaf60a77531c6097d4fd857805f67abf1c4834c808ad9bb0db11a352d4f1cc83da40c940917f1e2ae45f3e880df28b279d3688e69068c13058a44e4b9e06ebcd3daf8868a7222f8f9830c93a318a3c71257b9794341e5407d1f865c85ef056d167af2a96bd02b26de434bf7e79c62d46a64c4a5740a7c81ae29057317d6f07d3ec0178d5e4d77a4c5d5cfb7d17c0e722d5ddecc93163a2fb2bf34234309de08f7f8a4585a5788d8a0edafcf58c0c676b12210b0f479f604f49f4d842949f1d93654c4788e9b7f52cebddca31d1b3effab16fcb5b2a4714c4d7a544738944f155347cd6c26ac1f3fc98707b8bf465de2d7b1b5e79ffd7338f0d09ec986e7d2fe0ef8a8196c2ded99931f9cbd000d8a535f30de87933d792db0ef595955ddbbf376931b9d28d43e0d67f2c4097a67e0fd6ef3a21185c0297d98206e089814b198bc8fb2fd066eb220768de1c594ae92351acb667a545f54a9f71e96a5fc83979dc4196963ab82239dd702a3935c7d76f75728dda12bae7415238d36cad62a02b58ac167666d330bb76f7e1ae63060b0c45275313dcb18e183cdd5666d705613864ca21bd4ba324c963bf4e6040b154f0ce86939fc24442b23443b546079f13a1f286d9b22299c41b3e334af13cf8b4a4b7f2ffe0b219f46ba4ba3f1932f04eeb09c0a32bd1c355bcdaa5ec60af5ae5b877682201d8969556e5a17ddc8eaafc5aafb1718d23b242c4c720be191705338123d85e3dd4a3d47d9d7b28d6fad2cccab2d80a2ad9b7b8987fe4f161d470372e38d87becec643395d9b5b95d75e078e2a67404d30cab5e53e93a8088897ab197f5f5b419f2c7f09f5d8e02afc4d9c55c4d2bb9328f79be60fc2a201c993d4040004b65b5fb82e434a5ba18db4ea823f257872d7ec50dcb6c32a4c36463a0cbe01d3be3e3e97f6caf949b6311040771b12105bfc96dece427e315816def70fac59fd0e3ba52d84558cd9f9c9d565b3a06a2f889a43823bcd26633a9a17edef4ad223622fd09731da161150ae172735d751f5408cbcf69fadfe322771a040882c03233b518ef5c28f56619990d7c8f4c97dec350c4347e7e972aa3424a843a0bc52e805417ab7287def97ef40fb2b791b18c49aed23c588f29916d5fa3b1637ac92836ef9fb9669d14136ff154d933584ace0eb0b9644afb4db09abce1c92300eecad20e9d88317905051190bd5ebc0c5b956de61b2b67cc9aeb182440eaa36dc56afb90e38905912bcf6b932dea4c996001ac57de5375e391be1cf515552e9694595c8e3b5926834412ff72587c4155d88ed24bbce69aba789c3700b2666fd3033a619eb5c70be2b79295c43d1ff2bf68425685095092571428cf4c959bf17b7c8300f6129aab3112459a402d671db50e79cb4c4570eea3985aee95ebd90bca4f5fbc84946a44bfe2891469c8f03dc2c87ee6612c0a3b34cda3afb9cf07e49dc532e6d9502c9b972206071b9d8705fc28645f8b991010fc79b035bb39e0c5e9327f87f83b3206ffc35432674037631676b1ec2b49998a00259167e934b5f3c2093b1a6d8b88c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/AlanTuringLi/lib/hbe.js"></script><link href="/AlanTuringLi/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11536 Smallest Sub-Array</title>
    <url>/AlanTuringLi/2020/09/17/UVa11536-Smallest-Sub-Array/</url>
    <content><![CDATA[<h1 id="UVa11536-Smallest-Sub-Array"><a href="#UVa11536-Smallest-Sub-Array" class="headerlink" title="UVa11536 Smallest Sub-Array"></a><a href="https://www.luogu.com.cn/problem/UVA11536">UVa11536 Smallest Sub-Array</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为$n$的序列, 然你找一个最小的区间, 是的这个区间内包含了$[1,k]$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>易证的我们可以贪心的去找这个区间</p>
<p>贪心方案就是尽可能的让没用的数字不在这个区间内</p>
<ul>
<li><p>大于$k$的数可以直接不考虑它作为左右端点</p>
</li>
<li><p>如果当前左端点为$l$, 且$[l+1,r]$范围内存在$a[l]$, 那么$a[l]$也不用考虑作为任何端点</p>
</li>
</ul>
<p>那么我们可以从$1\sim n$扫描一遍,这样枚举右端点, 在贪心得将左端点向右移,如果区间符合条件, 那么更新答案即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) </span><br><span class="line">        q = (q &lt;&lt; <span class="number">1</span>) + (q &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> q * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[maxn] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> test = <span class="number">1</span>; test &lt;= T; ++test) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);<span class="comment">//每次都要清空桶</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(maxn)</span>, <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = __read(), m = __read(), k = __read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; ++i) </span><br><span class="line">        	q[i] = (q[i - <span class="number">1</span>] + q[i - <span class="number">2</span>] + q[i - <span class="number">3</span>]) % m + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q[l] &gt; k &amp;&amp; l &lt;= n) ++l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; k) <span class="keyword">continue</span>;<span class="comment">//无用状态直接不用考虑</span></span><br><span class="line">            <span class="keyword">if</span> (!t[q[i]])++cnt;</span><br><span class="line">            t[q[i]]++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; i &amp;&amp; (t[q[l]] &gt; <span class="number">1</span> || q[l] &gt; k)) </span><br><span class="line">            	t[q[l]]--, ++l;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k) ans = <span class="built_in">min</span>(ans, i - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Case %d: &quot;</span>, test);</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; maxn) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;sequence nai&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>JSOI平衡点</title>
    <url>/AlanTuringLi/2020/07/24/%5BJSOI%5D%E5%B9%B3%E8%A1%A1%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JSOI2004-平衡点-吊打XXX"><a href="#JSOI2004-平衡点-吊打XXX" class="headerlink" title="[JSOI2004]平衡点 / 吊打XXX"></a><a href="https://www.luogu.com.cn/problem/P1337">[JSOI2004]平衡点 / 吊打XXX</a></h1><p>被吊打了啊 !</p>
<p><del>这道题, 看上去真的挺难的 .</del></p>
<p>简言之, 就是求平衡状态时, 中心点的位置 .</p>
<p>做出受力分析图, 我们可以看得出来, 这个点的位置, 其实与绳子是无关的, 每根绳的拉力, 也一定是等于重物的</p>
<p>所以, 我们可以先随机一个点, 求出这$n$根线对着个点的作用力的合力. 因为力的方向不好表示, 所以我们可以正交分解, 将力分解到$x$轴和$y$轴上去.</p>
<p>这个点必定会沿合力方向移动一定的距离, 直到合力为零. </p>
<p>但是, 我们在不用其他数学工具的情况下, 我们可以随机一个较大步长, 然后不断地缩小这个步长, 就可以越来越接近这个目标点了. </p>
<p>当某一次的移动前后的变化小于精度范围时, 那么我们就找到答案了.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> X, Y;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Xf</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">Yf</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> X, Y, G;</span><br><span class="line">&#125;Points[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">0</span>)</span>, Temp</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp = <span class="built_in">sqrt</span>((X - Points[i].X) * (X - Points[i].X) + (Y - Points[i].Y) * (Y - Points[i].Y));</span><br><span class="line">        <span class="keyword">if</span> (!Temp) <span class="keyword">continue</span>;</span><br><span class="line">        x += Points[i].G / Temp * (Points[i].X - X);</span><br><span class="line">        y += Points[i].G / Temp * (Points[i].Y - Y);</span><br><span class="line">    &#125;</span><br><span class="line">    Temp = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    Y += M / Temp * y;</span><br><span class="line">    X += M / Temp * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;Points[i].X, &amp;Points[i].Y, &amp;Points[i].G);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> M = <span class="number">10000</span>, tx, ty;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = X, ty = Y;</span><br><span class="line">        <span class="built_in">Solve</span>(M);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tx - X) &lt; <span class="number">0.00001</span> &amp;&amp; <span class="built_in">abs</span>(ty - Y) &lt; <span class="number">0.00001</span>) <span class="keyword">break</span>;</span><br><span class="line">        M *= <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.3lf %.3lf\n&quot;</span>, X, Y);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Working Out</title>
    <url>/AlanTuringLi/2020/09/15/Working-Out/</url>
    <content><![CDATA[<h1 id="Working-Out"><a href="#Working-Out" class="headerlink" title="Working Out"></a><a href="https://ac.nowcoder.com/acm/problem/110489">Working Out</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个矩阵，每个点都有一个点权，让你求从矩阵中某一点到矩阵四个顶点的权值之和减去自己的四倍的值最大(就是这个点没有贡献)</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们画两张图，看看他们的路径，就会发现其实只有两种情况<br><strong>一</strong>:<br><img src="https://uploadfiles.nowcoder.com/files/20200908/675676897_1599549981026_wQibfx.md.png" alt=""><br><strong>二</strong>：<br><img src="https://uploadfiles.nowcoder.com/files/20200908/675676897_1599550140637_wQFl90.png" alt=""></p>
<p>就是说其实只有两种转移的方式</p>
<p>那么我们用4个数组分别记录到四个顶点的最大距离<br>然后再枚举每个点作为交点时的答案，不断更新</p>
<script type="math/tex; mode=display">
ans=\max_{1<i<n,1<j<m}(dp[1][i - 1][j] + dp[3][i + 1][j] + dp[2][i][j + 1] + dp[4][i][j - 1],dp[1][i][j - 1] + dp[3][i][j + 1] + dp[2][i - 1][j] + dp[4][i + 1][j])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5</span>][maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, ans, a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, f </span>= <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">Read</span>(), m = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) a[i][j] = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">            dp[<span class="number">1</span>][i][j] = <span class="built_in">max_</span>(dp[<span class="number">1</span>][i - <span class="number">1</span>][j], dp[<span class="number">1</span>][i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; --j) </span><br><span class="line">            dp[<span class="number">2</span>][i][j] = <span class="built_in">max_</span>(dp[<span class="number">2</span>][i - <span class="number">1</span>][j], dp[<span class="number">2</span>][i][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; --j) </span><br><span class="line">            dp[<span class="number">3</span>][i][j] = <span class="built_in">max_</span>(dp[<span class="number">3</span>][i + <span class="number">1</span>][j], dp[<span class="number">3</span>][i][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">            dp[<span class="number">4</span>][i][j] = <span class="built_in">max_</span>(dp[<span class="number">4</span>][i + <span class="number">1</span>][j], dp[<span class="number">4</span>][i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; m; ++j)</span><br><span class="line">            ans = <span class="built_in">max_</span> (ans, dp[<span class="number">1</span>][i - <span class="number">1</span>][j] + dp[<span class="number">3</span>][i + <span class="number">1</span>][j] + dp[<span class="number">2</span>][i][j + <span class="number">1</span>] + dp[<span class="number">4</span>][i][j - <span class="number">1</span>]), </span><br><span class="line">            ans = <span class="built_in">max_</span> (ans, dp[<span class="number">1</span>][i][j - <span class="number">1</span>] + dp[<span class="number">3</span>][i][j + <span class="number">1</span>] + dp[<span class="number">2</span>][i - <span class="number">1</span>][j] + dp[<span class="number">4</span>][i + <span class="number">1</span>][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>fc MOS BJT</title>
    <url>/AlanTuringLi/2023/11/04/fc-MOS-BJT/</url>
    <content><![CDATA[<p>由于公式渲染的问题，这里放入 $PDF$ 预览文件<br>

	<div class="row">
    <embed src="fc-MOS-BJT.pdf" width="100%" height="550" type="application/pdf">
	</div>


</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>模拟电子电路</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp</title>
    <url>/AlanTuringLi/2020/06/24/kmp/</url>
    <content><![CDATA[<h1 id="模板KMP"><a href="#模板KMP" class="headerlink" title="模板KMP"></a><a href="https://www.luogu.com.cn/problem/P3375"><strong>模板KMP</strong></a></h1><p>$KMP$简单的来是用一个串在另一个串中匹配</p>
<p>那么对于这样一个模板我们可以怎么处理呢?</p>
<p>假象现在我们在进行暴力匹配，此时情况如下:</p>
<script type="math/tex; mode=display">
s1="abcabc...."\\
s2="abcabb"....</script><p>可以看见现在的$s2$的最后一个$b$对齐的是$s1$的$c$</p>
<p>简单地说现在的$b$就是一个失配点</p>
<p>也就是说现在我们需要重新匹配</p>
<p>如果再从头开始的匹配的话显然有些浪费时间了</p>
<p>于是我们似乎可以就寻找上一个失配点的位置即$……b$的位置</p>
<p>于是我们找到了$ab$，也就是$s2$的开头的两个字符，然后继续这样匹配下去就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> A[Maxn], B[Maxn];</span><br><span class="line"><span class="type">int</span> Last, LOA, LOB, KMP[Maxn];<span class="comment">//这个KMP数组就是记录上一个失配点的位置</span></span><br><span class="line"><span class="comment">//后面的代码就非常的浅显易懂了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, A + <span class="number">1</span>, B + <span class="number">1</span>);</span><br><span class="line">    LOA = <span class="built_in">strlen</span>(A + <span class="number">1</span>), LOB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= LOB; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Last &amp;&amp; B[i] != B[Last + <span class="number">1</span>]) Last = KMP[Last];</span><br><span class="line">        <span class="keyword">if</span> (B[Last + <span class="number">1</span>] == B[i]) ++Last;</span><br><span class="line">        KMP[i] = Last;</span><br><span class="line">    &#125;</span><br><span class="line">    Last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOA; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Last &amp;&amp; A[i] != B[Last + <span class="number">1</span>]) Last = KMP[Last];</span><br><span class="line">        <span class="keyword">if</span> (B[Last + <span class="number">1</span>] == A[i]) ++Last;</span><br><span class="line">        <span class="keyword">if</span> (Last == LOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - LOB + <span class="number">1</span>);</span><br><span class="line">            Last = KMP[Last];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOB; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, KMP[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>$&#92;LaTeX$[置顶]</title>
    <url>/AlanTuringLi/2223/10/22/latex/</url>
    <content><![CDATA[<h1 id="声调-变音符号"><a href="#声调-变音符号" class="headerlink" title="声调/变音符号"></a>声调/变音符号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;a&#125; <span class="keyword">\ddot</span>&#123;a&#125; <span class="keyword">\acute</span>&#123;a&#125; <span class="keyword">\grave</span>&#123;a&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\dot{a}\quad \ddot{a}\quad \acute{a}\quad \grave{a}$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\check</span>&#123;a&#125; <span class="keyword">\breve</span>&#123;a&#125; <span class="keyword">\tilde</span>&#123;a&#125; <span class="keyword">\bar</span>&#123;a&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure>
<p>$\check{a}\quad \breve{a}\quad \tilde{a}\quad \bar{a}\quad$ </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\widehat</span>&#123;a&#125; <span class="keyword">\vec</span>&#123;a&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\hat{a}\quad \widehat{a}\quad \vec{a}$</p>
<h1 id="类字母符号即常数"><a href="#类字母符号即常数" class="headerlink" title="类字母符号即常数"></a>类字母符号即常数</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\infty</span> <span class="keyword">\aleph</span> <span class="keyword">\complement</span> <span class="keyword">\backepsilon</span> <span class="keyword">\eth</span> <span class="keyword">\Finv</span> <span class="keyword">\hbar</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\infty\quad \aleph\quad \complement\quad \backepsilon\quad \eth\quad \Finv\quad \hbar$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Im</span> <span class="keyword">\imath</span> <span class="keyword">\jmath</span> <span class="keyword">\Bbbk</span> <span class="keyword">\ell</span> <span class="keyword">\mho</span> <span class="keyword">\wp</span> <span class="keyword">\Re</span> <span class="keyword">\circledS</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Im\quad \imath\quad \jmath\quad \Bbbk\quad \ell\quad \mho\quad \wp\quad \Re\quad \circledS$</p>
<h1 id="数论用"><a href="#数论用" class="headerlink" title="数论用"></a>数论用</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>a<span class="keyword">\equiv</span>1<span class="keyword">\pmod</span>&#123;m&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$a\equiv1\pmod{m}$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>a<span class="keyword">\bmod</span> b<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $a\bmod b$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\gcd</span>(m,n) <span class="keyword">\operatorname</span>&#123;lcm&#125;(m,n)<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\gcd(m,n)\quad \operatorname{lcm}(m,n)$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mid</span> <span class="keyword">\nmid</span> <span class="keyword">\shortmid</span> <span class="keyword">\nshortmid</span><span class="built_in">$</span></span><br><span class="line">ps：<span class="keyword">\mid</span>可以用|代替。</span><br></pre></td></tr></table></figure>
<p> $\mid\quad \nmid\quad \shortmid\quad \nshortmid$ </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>a<span class="keyword">\%</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$a\%b$</p>
<h1 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\surd</span> <span class="keyword">\sqrt</span>&#123;2&#125; <span class="keyword">\sqrt</span>[n]&#123;&#125; <span class="keyword">\sqrt</span>[n]&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\surd\quad \sqrt{2}\quad \sqrt[n]{}\quad \sqrt[n]{x}$</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>+ - <span class="keyword">\pm</span> <span class="keyword">\mp</span> <span class="keyword">\dotplus</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$+\quad -\quad \pm\quad \mp\quad \dotplus$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\times</span> <span class="keyword">\div</span> <span class="keyword">\divideontimes</span> / <span class="keyword">\backslash</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\times\quad \div\quad \divideontimes\quad /\quad \backslash$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cdot</span> * <span class="keyword">\star</span> <span class="keyword">\circ</span> <span class="keyword">\bullet</span><span class="built_in">$</span></span><br><span class="line">ps:*可以用<span class="keyword">\ast</span>代替。</span><br></pre></td></tr></table></figure>
<p> $\cdot\quad *\quad \star\quad \circ\quad \bullet$ </p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\oplus</span> <span class="keyword">\ominus</span> <span class="keyword">\otimes</span> <span class="keyword">\oslash</span> <span class="keyword">\odot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\oplus\quad \ominus\quad \otimes\quad \oslash\quad \odot$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\circleddash</span> <span class="keyword">\circledcirc</span> <span class="keyword">\circledast</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\circleddash\quad \circledcirc\quad \circledast$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigoplus</span> <span class="keyword">\bigotimes</span> <span class="keyword">\bigodot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\bigoplus\quad \bigotimes\quad \bigodot$</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\&#123;</span> <span class="keyword">\&#125;</span> <span class="keyword">\emptyset</span> <span class="keyword">\varnothing</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> ${\quad }\quad \emptyset\quad \varnothing$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\in</span> <span class="keyword">\notin</span> <span class="keyword">\not</span><span class="keyword">\in</span> <span class="keyword">\ni</span> <span class="keyword">\not</span><span class="keyword">\ni</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\in\quad \notin\quad \not\in\quad \ni\quad \not\ni$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cap</span> <span class="keyword">\Cap</span> <span class="keyword">\sqcap</span> <span class="keyword">\bigcap</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\cap\quad \Cap\quad \sqcap\quad \bigcap$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cup</span> <span class="keyword">\Cup</span> <span class="keyword">\sqcup</span> <span class="keyword">\bigcup</span> <span class="keyword">\bigsqcup</span> <span class="keyword">\uplus</span> <span class="keyword">\biguplus</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\cup\quad \Cup\quad \sqcup\quad \bigcup\quad \bigsqcup\quad \uplus\quad \biguplus$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\setminus</span> <span class="keyword">\smallsetminus</span> <span class="keyword">\times</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\setminus\quad \smallsetminus\quad \times$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\subset</span> <span class="keyword">\Subset</span> <span class="keyword">\sqsubset</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\subset\quad \Subset\quad \sqsubset$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\supset</span> <span class="keyword">\Supset</span> <span class="keyword">\sqsupset</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\supset\quad \Supset\quad \sqsupset$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\subseteq</span> <span class="keyword">\nsubseteq</span> <span class="keyword">\subsetneq</span> <span class="keyword">\varsubsetneq</span> <span class="keyword">\sqsubseteq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\subseteq\quad \nsubseteq\quad \subsetneq\quad \varsubsetneq\quad \sqsubseteq$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\supseteq</span> <span class="keyword">\nsupseteq</span> <span class="keyword">\supsetneq</span> <span class="keyword">\varsupsetneq</span> <span class="keyword">\sqsupseteq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\supseteq\quad \nsupseteq\quad \supsetneq\quad \varsupsetneq\quad \sqsupseteq$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\subseteqq</span> <span class="keyword">\nsubseteqq</span> <span class="keyword">\subsetneqq</span> <span class="keyword">\varsubsetneqq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\subseteqq\quad \nsubseteqq\quad \subsetneqq\quad \varsubsetneqq$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\supseteqq</span> <span class="keyword">\nsupseteqq</span> <span class="keyword">\supsetneqq</span> <span class="keyword">\varsupsetneqq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\supseteqq\quad \nsupseteqq\quad \supsetneqq\quad \varsupsetneqq$</p>
<h1 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>= <span class="keyword">\ne</span> <span class="keyword">\neq</span> <span class="keyword">\equiv</span> <span class="keyword">\not</span><span class="keyword">\equiv</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $=\quad \ne\quad \neq\quad \equiv\quad \not\equiv$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\doteq</span> <span class="keyword">\doteqdot</span> <span class="keyword">\overset</span>&#123;<span class="keyword">\underset</span>&#123;def&#125;&#123;&#125;&#125;&#123;=&#125; :=<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\doteq\quad \doteqdot\quad \overset{\underset{def}{}}{=}\quad :=$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sim</span> <span class="keyword">\nsim</span> <span class="keyword">\backsim</span> <span class="keyword">\thicksim</span> <span class="keyword">\simeq</span> <span class="keyword">\backsimeq</span> <span class="keyword">\eqsim</span> <span class="keyword">\cong</span> <span class="keyword">\ncong</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\sim \quad\nsim\quad \backsim\quad \thicksim\quad \simeq \quad \backsimeq\quad \eqsim\quad \cong\quad \ncong$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\approx</span> <span class="keyword">\thickapprox</span> <span class="keyword">\approxeq</span> <span class="keyword">\asymp</span> <span class="keyword">\propto</span> <span class="keyword">\varpropto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\approx\quad\thickapprox\quad \approxeq\quad \asymp\quad \propto\quad \varpropto$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&lt; <span class="keyword">\nless</span> <span class="keyword">\ll</span> <span class="keyword">\not</span><span class="keyword">\ll</span> <span class="keyword">\lll</span> <span class="keyword">\not</span><span class="keyword">\lll</span> <span class="keyword">\lessdot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $&lt;\quad \nless\quad \ll\quad \not\quad\ll \quad\lll \quad\not\lll\quad \lessdot$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&gt; <span class="keyword">\ngtr</span> <span class="keyword">\gg</span> <span class="keyword">\not</span><span class="keyword">\gg</span> <span class="keyword">\ggg</span> <span class="keyword">\not</span><span class="keyword">\ggg</span> <span class="keyword">\gtrdot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $&gt; \quad\ngtr\quad \gg\quad \not\gg\quad \ggg\quad \not\ggg \quad\gtrdot$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\le</span> <span class="keyword">\leq</span> <span class="keyword">\lneq</span> <span class="keyword">\leqq</span> <span class="keyword">\nleq</span> <span class="keyword">\nleqq</span> <span class="keyword">\lneqq</span> <span class="keyword">\lvertneqq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\le\quad \leq\quad \lneq\quad \leqq\quad \nleq\quad \nleqq\quad \lneqq\quad \lvertneqq$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\ge</span> <span class="keyword">\geq</span> <span class="keyword">\gneq</span> <span class="keyword">\geqq</span> <span class="keyword">\ngeq</span> <span class="keyword">\ngeqq</span> <span class="keyword">\gneqq</span> <span class="keyword">\gvertneqq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\ge\quad \geq\quad \gneq\quad \geqq\quad \ngeq\quad \ngeqq\quad \gneqq\quad \gvertneqq$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lessgtr</span> <span class="keyword">\lesseqgtr</span> <span class="keyword">\lesseqqgtr</span> <span class="keyword">\gtrless</span> <span class="keyword">\gtreqless</span> <span class="keyword">\gtreqqless</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\lessgtr\quad \lesseqgtr\quad \lesseqqgtr\quad \gtrless\quad \gtreqless\quad \gtreqqless$</p>
<p>还有很多，大概率是用不上的，就不写了</p>
<h1 id="集合符号"><a href="#集合符号" class="headerlink" title="集合符号"></a>集合符号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\parallel</span> <span class="keyword">\nparallel</span> <span class="keyword">\shortparallel</span> <span class="keyword">\nshortparallel</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\parallel\quad \nparallel\quad \shortparallel\quad \nshortparallel$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\perp</span> <span class="keyword">\angle</span> <span class="keyword">\sphericalangle</span> <span class="keyword">\measuredangle</span> 45<span class="built_in">^</span><span class="keyword">\circ</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\perp\quad \angle\quad \sphericalangle\quad \measuredangle 45^\circ$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Box</span> <span class="keyword">\blacksquare</span> <span class="keyword">\diamond</span> <span class="keyword">\Diamond</span> <span class="keyword">\lozenge</span> <span class="keyword">\blacklozenge</span> <span class="keyword">\bigstar</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\Box\quad \blacksquare\quad \diamond\quad \Diamond\quad\lozenge\quad \blacklozenge\quad \bigstar$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcirc</span> <span class="keyword">\triangle</span> <span class="keyword">\bigtriangleup</span> <span class="keyword">\bigtriangledown</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\bigcirc\quad \triangle\quad \bigtriangleup\quad \bigtriangledown$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vartriangle</span> <span class="keyword">\triangledown</span> <span class="keyword">\triangleleft</span> <span class="keyword">\triangleright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\vartriangle\quad\triangledown \quad\triangleleft \quad\triangleright$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\blacktriangle</span> <span class="keyword">\blacktriangledown</span> <span class="keyword">\blacktriangleleft</span> <span class="keyword">\blacktriangleright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\blacktriangle\quad \blacktriangledown \quad\blacktriangleleft\quad \blacktriangleright$</p>
<h1 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\forall</span> <span class="keyword">\exists</span> <span class="keyword">\nexists</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\forall\quad \exists\quad \nexists$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\therefore</span> <span class="keyword">\because</span> <span class="keyword">\And</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\therefore\quad \because\quad \And$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lor</span> <span class="keyword">\vee</span> <span class="keyword">\curlyvee</span> <span class="keyword">\bigvee</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\lor\quad \vee\quad \curlyvee\quad \bigvee$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\land</span> <span class="keyword">\wedge</span> <span class="keyword">\curlywedge</span> <span class="keyword">\bigwedge</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\land\quad \wedge\quad \curlywedge\quad \bigwedge$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bar</span>&#123;q&#125; <span class="keyword">\bar</span>&#123;abc&#125; <span class="keyword">\overline</span>&#123;q&#125; <span class="keyword">\overline</span>&#123;abc&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\bar{q}\quad \bar{abc}\quad \overline{q}\quad \overline{abc}$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lnot</span> <span class="keyword">\neg</span> <span class="keyword">\bot</span> <span class="keyword">\top</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\lnot\quad \neg\quad \bot\quad \top$</p>
<h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rrightarrow</span> <span class="keyword">\Lleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Rrightarrow\quad \Lleftarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rightarrow</span> <span class="keyword">\nRightarrow</span> <span class="keyword">\Longrightarrow</span> <span class="keyword">\implies</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Rightarrow\quad \nRightarrow\quad \Longrightarrow\quad \implies$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftarrow</span> <span class="keyword">\nLeftarrow</span> <span class="keyword">\Longleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Leftarrow\quad \nLeftarrow\quad \Longleftarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftrightarrow</span> <span class="keyword">\nLeftrightarrow</span> <span class="keyword">\Longleftrightarrow</span> <span class="keyword">\iff</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Leftrightarrow\quad \nLeftrightarrow\quad \Longleftrightarrow\quad \iff$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Uparrow</span> <span class="keyword">\Downarrow</span> <span class="keyword">\Updownarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Uparrow \quad\Downarrow\quad \Updownarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftarrow</span> <span class="keyword">\rightarrow</span> <span class="keyword">\nleftarrow</span> <span class="keyword">\nrightarrow</span> <span class="keyword">\leftrightarrow</span> <span class="keyword">\nleftrightarrow</span> <span class="keyword">\longleftarrow</span> <span class="keyword">\longrightarrow</span> <span class="keyword">\longleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\leftarrow\quad \rightarrow\quad \nleftarrow\quad \nrightarrow \quad\leftrightarrow\quad \nleftrightarrow\quad \longleftarrow\quad \longrightarrow \quad\longleftrightarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\uparrow</span> <span class="keyword">\downarrow</span> <span class="keyword">\updownarrow</span> <span class="keyword">\nearrow</span> <span class="keyword">\searrow</span> <span class="keyword">\nwarrow</span> <span class="keyword">\swarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\uparrow\quad \downarrow\quad \updownarrow\quad \nearrow \quad\searrow \quad\nwarrow \quad\swarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mapsto</span> <span class="keyword">\longmapsto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\mapsto\quad \longmapsto$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightharpoonup</span> <span class="keyword">\rightharpoondown</span> <span class="keyword">\leftharpoonup</span> <span class="keyword">\leftharpoondown</span> <span class="keyword">\upharpoonleft</span> <span class="keyword">\upharpoonright</span> <span class="keyword">\downharpoonleft</span> <span class="keyword">\downharpoonright</span> <span class="keyword">\leftrightharpoons</span> <span class="keyword">\rightleftharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\rightharpoonup \quad\rightharpoondown\quad \leftharpoonup \quad\leftharpoondown \quad\upharpoonleft\quad \upharpoonright \quad\downharpoonleft \quad\downharpoonright\quad \leftrightharpoons\quad \rightleftharpoons$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowleft</span> <span class="keyword">\circlearrowleft</span> <span class="keyword">\Lsh</span> <span class="keyword">\upuparrows</span> <span class="keyword">\rightrightarrows</span> <span class="keyword">\rightleftarrows</span> <span class="keyword">\rightarrowtail</span> <span class="keyword">\looparrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\curvearrowleft\quad \circlearrowleft\quad \Lsh \quad\upuparrows\quad \rightrightarrows\quad \rightleftarrows \quad\rightarrowtail \quad\looparrowright$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowright</span> <span class="keyword">\circlearrowright</span> <span class="keyword">\Rsh</span> <span class="keyword">\downdownarrows</span> <span class="keyword">\leftleftarrows</span> <span class="keyword">\leftrightarrows</span> <span class="keyword">\leftarrowtail</span> <span class="keyword">\looparrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\curvearrowright\quad \circlearrowright\quad \Rsh \quad\downdownarrows \quad\leftleftarrows\quad \leftrightarrows \quad\leftarrowtail \quad\looparrowleft$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hookrightarrow</span> <span class="keyword">\hookleftarrow</span> <span class="keyword">\multimap</span> <span class="keyword">\leftrightsquigarrow</span> <span class="keyword">\rightsquigarrow</span> <span class="keyword">\twoheadrightarrow</span> <span class="keyword">\twoheadleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\hookrightarrow\quad \hookleftarrow \quad\multimap \quad\leftrightsquigarrow\quad \rightsquigarrow\quad \twoheadrightarrow \quad\twoheadleftarrow$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\xleftarrow</span>&#123;left&#125; <span class="keyword">\xrightarrow</span>&#123;right&#125; <span class="keyword">\xLeftarrow</span>&#123;Left&#125; <span class="keyword">\xRightarrow</span>&#123;Right&#125; <span class="keyword">\xleftrightarrow</span>&#123;left<span class="keyword">\&amp;</span> right&#125; <span class="keyword">\xLeftrightarrow</span>&#123;Left<span class="keyword">\&amp;</span> Right&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\xleftarrow{left}\quad \xrightarrow{right}\quad $后面四个貌似有点问题？</p>
<h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\amalg</span> <span class="keyword">\%</span> <span class="keyword">\dagger</span> <span class="keyword">\ddagger</span> <span class="keyword">\ldots</span> <span class="keyword">\cdots</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\amalg\quad \% \quad\dagger\quad \ddagger\quad \ldots\quad \cdots$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\smile</span> <span class="keyword">\frown</span> <span class="keyword">\wr</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\smile\quad \frown\quad \wr$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\diamondsuit</span> <span class="keyword">\heartsuit</span> <span class="keyword">\clubsuit</span> <span class="keyword">\spadesuit</span> <span class="keyword">\Game</span> <span class="keyword">\flat</span> <span class="keyword">\natural</span> <span class="keyword">\sharp</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\diamondsuit \quad\heartsuit\quad \clubsuit\quad \spadesuit \quad\Game\quad \flat\quad \natural\quad \sharp$</p>
<h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><p>简单的应用省略</p>
<p><strong>前置上下标</strong></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;&#125;<span class="built_in">^</span>2<span class="built_in">_</span>1<span class="keyword">\!</span>X<span class="built_in">^</span>3<span class="built_in">_</span>4<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>${}^2_1!X^3_4$</p>
<h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>(PNG)x<span class="built_in">^</span><span class="keyword">\prime</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$x^\prime$</p>
<h2 id="导数点"><a href="#导数点" class="headerlink" title="导数点"></a>导数点</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;x&#125; <span class="keyword">\ddot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\dot{x}\quad\ddot{x}$</p>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;x&#125; <span class="keyword">\overleftarrow</span>&#123;AB&#125; <span class="keyword">\overrightarrow</span>&#123;AB&#125; <span class="keyword">\widehat</span>&#123;AB&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\vec{x}\quad\overleftarrow{AB}\quad\overrightarrow{AB} \quad\widehat{AB}$</p>
<h1 id="上弧"><a href="#上弧" class="headerlink" title="上弧"></a>上弧</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overarc</span>&#123;<span class="keyword">\frown</span>&#125;&#123;AB&#125;<span class="built_in">$</span></span><br><span class="line">ps:正确的语法应该是<span class="keyword">\overarc</span>，但因为没有引入amsmath宏包，所以无法使用，只能用这个替代下。</span><br></pre></td></tr></table></figure>
<p> $\overset{\frown}{AB}$</p>
<h1 id="上划线"><a href="#上划线" class="headerlink" title="上划线"></a>上划线</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;ABC&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\overline{ABC}$</p>
<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;ABC&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\underline{ABC}$</p>
<h1 id="上括号"><a href="#上括号" class="headerlink" title="上括号"></a>上括号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overbrace</span>&#123;1+2+<span class="keyword">\cdots</span>+100&#125;<span class="built_in">$</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">5050<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\overbrace</span>&#123;1+2+<span class="keyword">\cdots</span>+100&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure>
<p> $\overbrace{1+2+\cdots+100}$ </p>
<script type="math/tex; mode=display">
\begin{matrix}5050 \\ \overbrace{1+2+\cdots+100}\end{matrix}</script><h1 id="下括号"><a href="#下括号" class="headerlink" title="下括号"></a>下括号</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;1+2+<span class="keyword">\cdots</span>+100&#125;<span class="built_in">$</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\underbrace</span>&#123;1+2+<span class="keyword">\cdots</span>+100&#125;<span class="keyword">\\</span></span><br><span class="line">5050</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\underbrace{1+2+\cdots+100}$ </p>
<script type="math/tex; mode=display">
\begin{matrix} \underbrace{1+2+\cdots+100} \\ 5050\end{matrix}</script><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;n<span class="keyword">\to</span><span class="keyword">\infty</span>&#125;x<span class="built_in">_</span>n <span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;n<span class="keyword">\to</span><span class="keyword">\infty</span>&#125;x<span class="built_in">_</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\lim_{n\to\infty}x_n\quad \lim\limits_{n\to\infty}x_n</script><h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>&#123;-N&#125;<span class="built_in">^</span>&#123;N&#125;e<span class="built_in">^</span>x<span class="keyword">\,</span>dx<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\int_{-N}^{N}e^x\,dx$</p>
<h1 id="双重积分"><a href="#双重积分" class="headerlink" title="双重积分"></a>双重积分</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iint</span><span class="built_in">_</span>M<span class="built_in">^</span>Ndx<span class="keyword">\,</span>dy<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\iint_M^Ndx\,dy$</p>
<h1 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iiint</span><span class="built_in">_</span>M<span class="built_in">^</span>Ndx<span class="keyword">\,</span>dy<span class="keyword">\,</span>dz<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\iiint_M^Ndx\,dy\,dz$</p>
<h1 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">_</span>1<span class="built_in">^</span>np <span class="keyword">\bigcap</span><span class="keyword">\limits</span><span class="built_in">_</span>1<span class="built_in">^</span>np<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\bigcap_1^np\quad \bigcap\limits_1^np$</p>
<h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">_</span>1<span class="built_in">^</span>np <span class="keyword">\bigcup</span><span class="keyword">\limits</span><span class="built_in">_</span>1<span class="built_in">^</span>np<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\bigcup_1^np\quad \bigcup\limits_1^np$</p>
<h1 id="分数矩阵"><a href="#分数矩阵" class="headerlink" title="分数矩阵"></a>分数矩阵</h1><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;=0.5<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\frac{1}{2}=0.5$</p>
<h2 id="小型分数"><a href="#小型分数" class="headerlink" title="小型分数"></a>小型分数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tfrac</span>&#123;1&#125;&#123;2&#125;=0.5<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\tfrac{1}{2}=0.5$</p>
<h2 id="大型分数"><a href="#大型分数" class="headerlink" title="大型分数"></a>大型分数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dfrac</span>&#123;1&#125;&#123;2&#125;=0.5 <span class="keyword">\dfrac</span>&#123;1&#125;&#123;x+<span class="keyword">\dfrac</span>&#123;3&#125;&#123;y+<span class="keyword">\dfrac</span>&#123;1&#125;&#123;5&#125;&#125;&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\dfrac{1}{2}=0.5\quad \dfrac{1}{x+\dfrac{3}{y+\dfrac{1}{5}}}$</p>
<h2 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dbinom</span>&#123;n&#125;&#123;m&#125;=<span class="keyword">\dbinom</span>&#123;n&#125;&#123;n-m&#125;=C<span class="built_in">_</span>n<span class="built_in">^</span>m=C<span class="built_in">_</span>n<span class="built_in">^</span>&#123;n-m&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\dbinom{n}{m}=\dbinom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<h2 id="小型二项式系数"><a href="#小型二项式系数" class="headerlink" title="小型二项式系数"></a>小型二项式系数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tbinom</span>&#123;n&#125;&#123;m&#125;=<span class="keyword">\tbinom</span>&#123;n&#125;&#123;n-m&#125;=C<span class="built_in">_</span>n<span class="built_in">^</span>m=C<span class="built_in">_</span>n<span class="built_in">^</span>&#123;n-m&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\tbinom{n}{m}=\tbinom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\binom</span>&#123;n&#125;&#123;m&#125;=<span class="keyword">\binom</span>&#123;n&#125;&#123;n-m&#125;=C<span class="built_in">_</span>n<span class="built_in">^</span>m=C<span class="built_in">_</span>n<span class="built_in">^</span>&#123;n-m&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\binom{n}{m}=\binom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;matrix&#125;a<span class="built_in">&amp;</span>b<span class="keyword">\\</span> c<span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;matrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{matrix}a&b\\ c&d\end{matrix}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;vmatrix&#125;a<span class="built_in">&amp;</span>b<span class="keyword">\\</span> c<span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;vmatrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{vmatrix}a&b\\ c&d\end{vmatrix}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;Vmatrix&#125;a<span class="built_in">&amp;</span>b<span class="keyword">\\</span> c<span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;Vmatrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{Vmatrix}a&b\\ c&d\end{Vmatrix}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;bmatrix&#125;a<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>b<span class="keyword">\\</span><span class="keyword">\vdots</span><span class="built_in">&amp;</span><span class="keyword">\ddots</span><span class="built_in">&amp;</span><span class="keyword">\vdots</span><span class="keyword">\\</span> c<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;bmatrix&#125;<span class="built_in">$</span></span><br><span class="line">ps:<span class="keyword">\vdots</span>是竖着3个点，<span class="keyword">\ddots</span>是斜着3个点。</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{bmatrix}a&\cdots&b\\\vdots&\ddots&\vdots\\ c&\cdots&d\end{bmatrix}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;Bmatrix&#125;a<span class="built_in">&amp;</span>c<span class="keyword">\\</span> b<span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;Bmatrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{Bmatrix}a&c\\ b&d\end{Bmatrix}</script><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;pmatrix&#125;a<span class="built_in">&amp;</span>c<span class="keyword">\\</span> b<span class="built_in">&amp;</span>d<span class="keyword">\end</span>&#123;pmatrix&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
 \begin{pmatrix}a&c\\ b&d\end{pmatrix}</script><h2 id="矩阵嵌套"><a href="#矩阵嵌套" class="headerlink" title="矩阵嵌套"></a>矩阵嵌套</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;vmatrix&#125; <span class="keyword">\begin</span>&#123;Bmatrix&#125;A <span class="built_in">&amp;</span> <span class="keyword">\\</span> c <span class="built_in">&amp;</span> d <span class="keyword">\end</span>&#123;Bmatrix&#125; <span class="built_in">&amp;</span> x<span class="keyword">\\</span> <span class="keyword">\dfrac</span>&#123;1&#125;&#123;2&#125; <span class="built_in">&amp;</span> <span class="keyword">\begin</span>&#123;matrix&#125; 1 <span class="built_in">&amp;</span> 2 <span class="keyword">\\</span> 3 <span class="built_in">&amp;</span> 4 <span class="keyword">\end</span>&#123;matrix&#125; <span class="keyword">\end</span>&#123;vmatrix&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{vmatrix} \begin{Bmatrix}A & \\ c & d \end{Bmatrix} & x\\ \dfrac{1}{2} & \begin{matrix} 1 & 2 \\ 3 & 4 \end{matrix} \end{vmatrix}</script><h2 id="条件定义-如分段函数"><a href="#条件定义-如分段函数" class="headerlink" title="条件定义(如分段函数)"></a>条件定义(如分段函数)</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x)=<span class="keyword">\begin</span>&#123;cases&#125;x-1<span class="built_in">&amp;</span>x<span class="keyword">\leqslant</span>3<span class="keyword">\\</span> x<span class="built_in">^</span>2+3x-1<span class="built_in">&amp;</span>x&gt;3<span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
f(x)=\begin{cases}x-1&x\leqslant3\\ x^2+3x-1&x>3\end{cases}</script><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;cases&#125;2x+9y-5z=10<span class="keyword">\\</span> 4x+20y+z=24<span class="keyword">\\</span> x-<span class="keyword">\dfrac</span>&#123;1&#125;&#123;2&#125;y+3z=8<span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{cases}2x+9y-5z=10\\ 4x+20y+z=24\\ x-\dfrac{1}{2}y+3z=8\end{cases}</script><h2 id="多行等式"><a href="#多行等式" class="headerlink" title="多行等式"></a>多行等式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;aligned&#125;f(x) <span class="built_in">&amp;</span> = (x + 1)<span class="built_in">^</span>2 <span class="keyword">\\</span> <span class="built_in">&amp;</span> = x<span class="built_in">^</span>2 + 2x + 1<span class="keyword">\end</span>&#123;aligned&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;aligned&#125;a<span class="built_in">_</span>1 <span class="built_in">&amp;</span> = 1 <span class="keyword">\\</span> a<span class="built_in">_</span>2 <span class="built_in">&amp;</span> = 2 <span class="keyword">\\</span> <span class="built_in">&amp;</span> <span class="keyword">\dots</span> <span class="keyword">\\</span> a<span class="built_in">_</span>n <span class="built_in">&amp;</span> = n<span class="keyword">\end</span>&#123;aligned&#125;<span class="built_in">$</span> </span><br><span class="line"></span><br><span class="line">ps:原语法为align，现在是aligned。感觉align没啥不好的</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{aligned}f(x) & = (x + 1)^2 \\ & = x^2 + 2x + 1\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}a_1 & = 1 \\ a_2 & = 2 \\ & \dots \\ a_n & = n\end{aligned}</script><h2 id="数组-表格"><a href="#数组-表格" class="headerlink" title="数组/表格"></a>数组/表格</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;array&#125;&#123;|c|c||c|&#125;x<span class="built_in">&amp;</span>y<span class="built_in">&amp;</span>z<span class="keyword">\\</span>8<span class="built_in">&amp;</span>2<span class="built_in">&amp;</span>4<span class="keyword">\\</span>2<span class="built_in">&amp;</span>3<span class="built_in">&amp;</span>9<span class="keyword">\\</span>10<span class="built_in">&amp;</span><span class="keyword">\dfrac</span>&#123;3&#125;&#123;4&#125;<span class="built_in">&amp;</span><span class="keyword">\sqrt</span>&#123;3&#125;<span class="keyword">\\</span>a<span class="built_in">&amp;</span>b<span class="built_in">&amp;</span>c<span class="keyword">\end</span>&#123;array&#125;<span class="built_in">$</span></span><br><span class="line"> ps:<span class="keyword">\begin</span>&#123;array&#125;&#123;&#125;←这个大括号里是形如&#x27;|c|c||c|&#x27;这样的格式，&#x27;|&#x27;是两列的分割线，&#x27;c&#x27;是表示这里有一列，而内容中使用&#x27;<span class="built_in">&amp;</span>&#x27;来分开每一列的内容。这里可能讲的不是很清楚，所以最好还是自己尝试一下。</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{array}{|c|c||c|}x&y&z\\ 8&2&4\\ 2&3&9\\ 10&\dfrac{3}{4}&\sqrt{3}\\ a&b&c\end{array}</script><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Alpha</span> <span class="keyword">\Beta</span> <span class="keyword">\Gamma</span><span class="keyword">\Delta</span> <span class="keyword">\Epsilon</span> <span class="keyword">\Zeta</span> <span class="keyword">\Eta</span> <span class="keyword">\Theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Alpha \Beta \Gamma\Delta \Epsilon \Zeta \Eta \Theta$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Iota</span> <span class="keyword">\Kappa</span> <span class="keyword">\Lambda</span> <span class="keyword">\Mu</span> <span class="keyword">\Nu</span> <span class="keyword">\Xi</span> <span class="keyword">\Omicron</span> <span class="keyword">\Pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rho</span> <span class="keyword">\Sigma</span> <span class="keyword">\Tau</span> <span class="keyword">\Upsilon</span> <span class="keyword">\Phi</span> <span class="keyword">\Chi</span> <span class="keyword">\Psi</span> <span class="keyword">\Omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\Rho\Sigma \Tau \Upsilon \Phi \Chi \Psi \Omega$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="keyword">\beta</span><span class="keyword">\gamma</span><span class="keyword">\delta</span><span class="keyword">\epsilon</span><span class="keyword">\zeta</span><span class="keyword">\eta</span><span class="keyword">\theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\alpha\beta\gamma\delta\epsilon\zeta\eta\theta$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iota</span><span class="keyword">\kappa</span><span class="keyword">\lambda</span><span class="keyword">\mu</span><span class="keyword">\nu</span><span class="keyword">\xi</span><span class="keyword">\omicron</span><span class="keyword">\pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\iota\kappa\lambda\mu\nu\xi\omicron\pi$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rho</span><span class="keyword">\sigma</span><span class="keyword">\tau</span><span class="keyword">\upsilon</span><span class="keyword">\phi</span><span class="keyword">\chi</span><span class="keyword">\psi</span><span class="keyword">\omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\rho\sigma\tau\upsilon\phi\chi\psi\omega$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varepsilon</span><span class="keyword">\digamma</span><span class="keyword">\varkappa</span><span class="keyword">\varpi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\varepsilon\digamma\varkappa\varpi$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varrho</span><span class="keyword">\varsigma</span><span class="keyword">\vartheta</span><span class="keyword">\varphi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p> $\varrho\varsigma\vartheta\varphi$</p>
<p>下次继续</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>其他板子</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算好题</title>
    <url>/AlanTuringLi/2020/09/28/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%A5%BD%E9%A2%98/</url>
    <content><![CDATA[<p>位运算是一个十分有助的工具</p>
<p>还是要好好学的</p>
<h1 id="P6034-Ryoku-与最初之人笔记"><a href="#P6034-Ryoku-与最初之人笔记" class="headerlink" title="P6034 Ryoku 与最初之人笔记"></a><a href="https://www.luogu.com.cn/problem/P6034">P6034 Ryoku 与最初之人笔记</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\sum_{a=0}^n\sum_{b=a+1}^n[a\equiv b\pmod{a\otimes b}]</script><p><del>当然，最开始的开始，是通过暴力运算直接拿的$20pt$的好成绩</del></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遇到位运算，换元是不错的处理方法</p>
<p>令：$y=a \text{&amp;} b,\;a=x+y,\;b=y+z$，那么有：$a|b=x+y+z,a\text^b=x+z$</p>
<p>那么通过这个换元，可以得到一些好东西：</p>
<script type="math/tex; mode=display">
(a\otimes b)|(b-a)=(x+z)|(z-x)</script><p>那么就发现了，当且仅当$x=0$时，这个才能成立</p>
<p>所以说原式可以写为：</p>
<script type="math/tex; mode=display">
\sum_{a=0}^n\sum_{b=a+1}^n[a\equiv b\pmod{a\otimes b}]=\sum_{a=1}^n\sum_{b=a+1}^n[a\text{&}b==a]</script><p>那么定义</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=1}^{x-1}[i\text{&}x==i]</script><p>显然这个可以写成是：</p>
<script type="math/tex; mode=display">
f(x)=2^{cnt_x}-1</script><p>其中$cnt_x$表示$x$再二进制下$1$的个数</p>
<p>所以原式交换求和顺序后可以变成下面的样子：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^n2^{f(i)}-n\\
令：s(n)=\sum_{i=1}^ns^{f(i)}</script><p>然后，还有这样一个性质：</p>
<script type="math/tex; mode=display">
f(i<<1)=f(i)\\
f(i<<1|1)=f(i)+1</script><p>所以求和的时候，可以分奇偶求：</p>
<script type="math/tex; mode=display">
\begin{align*}
s(2n)&=\sum_{i=1}^{2n}s^{f(i)}\\
&=\sum_{i=1}^n2^{f(2i-1)}+\sum_{i=1}^n2^{f(2i)}\\
&=\sum_{i=1}^n2^{f(i-1)+1}+\sum_{i=1}^n2^{f(i)}\\
&=2(1+\sum_{i=1}^{n-1}2^{f(i)})+\sum_{i=1}^{n-1}2^{f(i)}+2^{f(n)}\\
&=3\sum_{i=1}^{n-1}2^{f(i)}+2^{f(n)}+2\\
&=3s(n-1)+2^{f(n)}+2
\end{align*}</script><p>然后乱搞就完了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(ll x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">count</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pow</span>(<span class="number">2</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sum</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> (<span class="built_in">Sum</span>(x ^ <span class="number">1</span>) + <span class="built_in">count</span>(x)) % mod;</span><br><span class="line">    ll temp = <span class="built_in">Sum</span>((x &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (temp * <span class="number">3</span> + <span class="built_in">count</span>(x &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n = __read();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ((<span class="built_in">Sum</span>(n) - n) % mod + mod) % mod);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>关于子集枚举的时间复杂度证明</title>
    <url>/AlanTuringLi/2020/11/17/%E5%85%B3%E4%BA%8E%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>最近不知道为什么，感觉很多题多需要有子集枚举这样的操作来做一些优化，然后就不太会分析这个时间复杂度，这里就是简单证明一下啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= ((<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span>); ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> sta = i; sta; sta = (sta - <span class="number">1</span>) &amp; i)</span><br><span class="line">    <span class="keyword">do</span> something;</span><br></pre></td></tr></table></figure>
<p>就是这样的一个玩意，为什么它的时间复杂度是 $O(3^{len})$ 呢？</p>
<h2 id="简单证明"><a href="#简单证明" class="headerlink" title="简单证明"></a>简单证明</h2><p>对于一个有 $i$ 个 $1$ 的数来说（二进制下），它被枚举到的次数应该为：$\binom ni2^{len-i}$ ，感觉这个还是可以理解的。</p>
<p>然后就是说，要考虑到所有的情况，所以所有数的代价就应该是 ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
sum&=\sum\limits_{i=0}^{len}\binom {len}i2^{len-i}\\
&=\sum_{i=0}^{len}\binom{len}{len-i}2^{len-i}\\
&=\sum_{i=0}^{len}\binom{len}i2^i
\end{aligned}</script><p>然后在考虑一个二项式展开：</p>
<script type="math/tex; mode=display">
(1+x)^{len}=\sum_{i=0}^{len}\binom {len}ix^i</script><p>所以就会有一个十分惊奇的发现：$x=2$ 时，刚好和上面的退下来的那个玩意儿相等了。</p>
<p>所以就可以就可以得到这样的一个结论：</p>
<script type="math/tex; mode=display">
\begin{aligned}
sum&=\sum_{i=0}^{len}\binom {len}i2^i\\
&=(1+x)^{len}\\
&=(1+2)^{len}=3^{len}
\end{aligned}</script><p><strong>证毕！</strong></p>
<p>终于可以快乐的子集枚举了。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>从1开始的数论</title>
    <url>/AlanTuringLi/2020/07/28/%E4%BB%8E1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>整除</li>
<li>互质</li>
<li>素数</li>
<li>取整函数</li>
<li>最大公约数(最小公倍数)</li>
</ul>
<h2 id="整数分块"><a href="#整数分块" class="headerlink" title="整数分块"></a>整数分块</h2><p>易证已知$d,n\in\mathbb{Z}\;且\;d\le n$ , 那么$[\frac nd]$的取值不会超过$\sqrt n$个</p>
<h2 id="调和数"><a href="#调和数" class="headerlink" title="调和数"></a>调和数</h2><p>调和数的定义为</p>
<script type="math/tex; mode=display">
H_n=\sum\limits_{k=1}^n\frac1k</script><p>关于调和数有如下结论:</p>
<script type="math/tex; mode=display">
H_n=\ln n+\lambda+O(1)</script><p>可以推出一个常见的事见复杂度:</p>
<script type="math/tex; mode=display">
\sum\limits_{d=1}^n\left[\frac nd\right]=\Theta(n\log n)</script><h2 id="素数计数函数"><a href="#素数计数函数" class="headerlink" title="素数计数函数"></a>素数计数函数</h2><p>令素数计数函数$\pi(n)$表示不超过$n$的素数个数. 我们有如下的素数定理 :</p>
<script type="math/tex; mode=display">
\pi(n)\sim\frac n{\ln n}</script><p>推论:</p>
<ul>
<li>$n$附近的素数密度近似为$\frac 1{\ln n}$</li>
<li>第$n$个素数$p_n\sim n\ln n$</li>
</ul>
<h2 id="素数计数"><a href="#素数计数" class="headerlink" title="素数计数"></a>素数计数</h2><p>显然可以利用 $Euler$ 筛算出 $n$ 以内的所有素数，进而得到 $\pi(n)$。 存在更快的做法。<del>可惜一页课件太少，写不下</del>。 </p>
<p>用一种类似积性函数求和的筛法可以达到 $O(\frac{n^{\frac34}}{\log n})$ 的复杂度。 先进的做法似乎可以达到 $O(\frac{n^\frac 23}{\log n})$ 。</p>
<h2 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h2><p>任意一个正整数 $n$ 都可以表示成素数的乘积的形式：</p>
<script type="math/tex; mode=display">
n = p_1^{a_1}p_2^{a_2}\cdots p_s^{a_3}</script><p>式中 $p_1,\cdots, p_s$ 是不同素数。且不计次序的情况下，这一表达是唯一的。</p>
<h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><ul>
<li>欧拉函数</li>
<li>狄利克雷卷积</li>
<li><a href="https://alansblog.ink/2020/06/14/莫比乌斯反演/">莫比乌斯反演</a></li>
</ul>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>设 $f$ 是数论函数，若对任意互质的正整数 $a,\;b$，都有 $f(ab) = f(a)f(b)$，则称 $f$ 是积性函数。 </p>
<p>若对任意的正整数 $a, b$，都有 $f(ab) = f(a)f(b)$，则称 $f$ 是完全积性的。</p>
<p>若 $f$ 是积性函数，且 $n = p_1^{\alpha_1}p_2^{\alpha_2}\dots p_s^{\alpha_s}$ 是 $n$ 的标准分解，则 有 $f(n) = f(p_1^{\alpha_1} )f(p_2^ {\alpha_2} )\cdots(p_s^{\alpha_s} )$ 因此研究积性函数 $f$ 可以转化为研究 $f(p^α)$，即 f 在素数和素数的幂上的取值。</p>
<p>设 $f$ 是积性函数，为求 $f(n)$，可以对 $n$ 分解素因子，然后计算所有的 $f(p^α)$ 乘起来。 如果要对 $1$ 到 $n$ 之间的所有数求出 $f$，注意到 $Euler$ 筛法的过程中可以求出每个数的最小素因子和最小素因子的幂次，利用此就能在线性时间内计算出所需的 $f$ 的值。</p>
<h2 id="除数函数"><a href="#除数函数" class="headerlink" title="除数函数"></a>除数函数</h2><p>除数函数$\delta_k(n)$用来表示$n$的因子的$k$次方之和:</p>
<script type="math/tex; mode=display">
\sigma_k(n)=\sum\limits_{d|n}{}d^k</script><p>约数个数$\delta_0(n)$常记为$d(n)$, 约束和$\delta_1(n)$常记为$\delta(n)$</p>
<h2 id="Dirichlet-卷积"><a href="#Dirichlet-卷积" class="headerlink" title="$Dirichlet$卷积"></a>$Dirichlet$卷积</h2><p>设 $f, g$ 是数论函数，考虑数论函数 $h$ 满足:</p>
<script type="math/tex; mode=display">
h(n)=\sum\limits_{d|n}f(d)g(\frac nd)</script><p>则称$h$为$f$与$g$的$Dirichlet$卷积, 记作$h=f*g$</p>
<p>单位函数 $\epsilon$ 是 $Dirichlet$ 卷积的单位元，即对于任意函数 $f$，有 $\epsilon ∗ f = f ∗ \epsilon = f$。 </p>
<p>$Dirichlet$ 卷积满足交换律和结合律</p>
<p>如果 $f,g$ 都是积性函数，那么 $h = f ∗ g$ 也是积性函数。</p>
<p>除数函数的定义可以写为： $\delta_k = 1 ∗ Id_k$ </p>
<p>$Euler$ 函数的性质可以写为： $Id = \varphi ∗ 1$</p>
<p>设 $f, g$ 是数论函数，计算 $f$ 和 $g$ 的 $Dirichlet$ 卷积在 $n$ 处的值 需要枚举 $n$ 的所有约数</p>
<p>如果要计算 $f$ 和 $g$ 的 $Dirichlet$ 卷积的前 $n$ 项，可以枚举 $1$ 到 $n$ 中每个数的倍数，根据调和数的相关结论，这样做的复杂度是 $O(n\log n)$</p>
<h2 id="无平方因子数"><a href="#无平方因子数" class="headerlink" title="无平方因子数"></a>无平方因子数</h2><p>求 $n$ 以内的无平方因子数的个数。亦即，求 </p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^n\mu^2(k)</script><p>我们考虑一个素数 $p$，那么 $p^2$ 的倍数都有平方因子，个数是 $\left\lfloor \frac n {p^2} \right\rfloor$ ，应该从答案中去掉</p>
<p>但是这样多去掉了一些数。比如对于不同的素数 $p_1, p_2，p_1^2p_2^2$ 的倍数就被去掉了两次，个数是 $\left\lfloor\frac n {p_1^2p_2^2}\right\rfloor$ ，应该加回来 </p>
<p>显然这是容斥原理</p>
<p>如果 $d$ 是 $s$ 个不同素数的乘积，那么其对答案的贡献是 $(−1)^s \left\lfloor \frac n {d^2} \right\rfloor$ 。 如果 $d$ 不是不同素数的乘积，即 $d$ 有平方因子，那么 $d$ 对答案没有贡献。 容斥的系数恰好是 $Mobius$ 函数</p>
<p>因此, 答案为:</p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^n=\sum\limits_{d=1}^{\sqrt n}\mu(d)\left\lfloor \frac n{d^2}\right\rfloor</script><p>事实上，$Mobius$ 反演本身就可以看成是对整除关系的容斥</p>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>有一种利用 $Dirichlet$ 卷积来构造递推式，从而对一些数论函数 进行快速求和的方法</p>
<p>民间称呼杜教筛</p>
<p>我们用两个例子来了解一下这个方法</p>
<h3 id="例一"><a href="#例一" class="headerlink" title="例一:"></a>例一:</h3><p>令:</p>
<script type="math/tex; mode=display">
\phi(n)=\sum\limits_{k=1}^n\varphi(k)</script><p>找出高效求出$\phi(n)$值的方法</p>
<p>考虑$ID=\varphi*1$, 可以的到:</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac 12n(n+1)&=\sum_{k=1}^nk=\sum_{k=1}^n\sum_{d|k}\varphi(\frac kd)\\
&=\sum_{d=1}^n\;\sum_{1\le k\le n\\~~ d|k}\varphi(\frac kd)\\
&=\sum_{d=1}^n\sum_{k=1}^{\left\lfloor\frac nd\right\rfloor}\varphi(k)\\
&=\sum_{d=1}^n\phi(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>即, 我们得到了:</p>
<script type="math/tex; mode=display">
\frac12n(n+1)=\sum_{d=1}^n\phi(\left\lfloor\frac nd\right\rfloor)=\phi(n)-\sum_{d=2}^n\phi(\left\lfloor\frac nd\right\rfloor)\\
\therefore \phi(n)=\frac12n(n+1)-\sum_{d=2}^n\phi(\left\lfloor\frac nd\right\rfloor)</script><p>因此，如果对于 $2 \le d \le n$ 已经计算出了 $\phi(\left\lfloor\frac nd\right\rfloor)$，即特殊点处 的函数值，由于特殊点只有不超过 $2\sqrt n$ 个，利用之前见过的分段的方法，我们可以在 $O(\sqrt n)$ 的时间内计算 $\phi(n)$</p>
<p>而计算 $\phi(\left\lfloor \frac nd \right\rfloor)$ 是子问题，可以递归解决</p>
<p>递归过程中会不会需要计算更多的函数值？</p>
<p>由特殊点的性质，可以发现所有要计算的就是所有的特殊点处的 函数值</p>
<p>使用记忆化搜索，这样每个函数值只会被计算一遍</p>
<h3 id="例二"><a href="#例二" class="headerlink" title="例二:"></a>例二:</h3><p>令</p>
<script type="math/tex; mode=display">
M(n)=\sum_{k=1}^n\mu(k)</script><p>计算原理类似</p>
<script type="math/tex; mode=display">
\begin{align*}
1&=\sum_{k=1}^n\epsilon(k)=\sum_{k=1}^n\sum_{d|k}\mu(\frac kd)\\
&=\sum_{d=1}^n\sum_{1\le k\le n\\~~d|k}\mu(\frac kd)\\
&=\sum_{d=1}^n\sum_{k=1}^\frac nd\mu(k)\\
&=\sum_{d=1}^nM(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>即, 我们得到了:</p>
<script type="math/tex; mode=display">
M(n)=1-\sum_{d=2}^nM(\left\lfloor\frac nd\right\rfloor)</script><p>同理可以求得</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Mu;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>, ll&gt; Phi;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e6</span>;</span><br><span class="line"><span class="type">int</span> T, A, B;</span><br><span class="line"><span class="type">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="type">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line">ll phi[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i], phi[i * P[j]] = phi[i] * phi[P[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * P[j]] = phi[i] * P[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PPhi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span> (Phi[x]) <span class="keyword">return</span> Phi[x];</span><br><span class="line">    ll Ans = <span class="number">1ll</span> * x * (x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">PPhi</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Phi[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MMu</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">MMu</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld %d\n&quot;</span>, <span class="built_in">PPhi</span>(A), <span class="built_in">MMu</span>(A));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>算法的总时间复杂度就是计算所有特殊点处的函数值的时间复杂度</p>
<p>回忆特殊点的结构，时间复杂度 $T(n)$ 可以估计为</p>
<script type="math/tex; mode=display">
T(N)=\sum_{i=1}^{\sqrt n}O(\sqrt i)+\sum_{i=1}^{\sqrt n}O(\sqrt{\left\lfloor\frac ni\right\rfloor})</script><p><del>显然式中第一项渐进意义上小于第二项</del>, $DaWuMiMan$</p>
<p>而对于式中第二项我们可以利用积分估计:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\sqrt n}O(\sqrt{\left\lfloor\frac ni\right\rfloor})=O(\int_1^{\sqrt n}\sqrt\frac nx{\rm d}x)=O(n^{\frac12}\cdot n^{\frac14})=O(n^{\frac34})</script><p>于是算法的时间复杂度为 $O(n^{\frac34})$ 。</p>
<p>注意到我们还可以使用 $Euler$ 筛求出 $\varphi$ 的值，进而求出前缀和</p>
<p>假设我们使用 $Euler$ 筛预先求出了 $\varphi$ 的前 $S$ 项，那么递归部分的时间复杂度变为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\frac ns}O(\sqrt{\left\lfloor\frac ni\right\rfloor})=O(\int_1^\frac nS\sqrt\frac nx{\rm d}x)=O(n^\frac12\cdot\sqrt\frac nS)=O(\frac n{S^\frac12})</script><p>结合 $Euler$ 筛的时间复杂度 $O(S)$，总的时间复杂度为$O(S+\frac n{S^\frac12})$</p>
<p>如果取 $S = n^\frac23$，那么总的时间复杂度为 $O(n^\frac23)$</p>
<h3 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h3><p>在求 $\varphi$ 和 $\mu$ 的前缀和的过程中，我们都利用了一个 $Dirichlet$ 卷积。 </p>
<p>这就让我们考虑数论函数 $f, g$ 的前缀和与他们的 $Dirichlet$ 卷积 $f ∗ g$ 的前缀和之间的关系。</p>
<p>用 $F$ 表示 $f$ 的前缀和, $h=f*g$，我们有</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{k=1}^nh(k)&=\sum_{k=1}^n\sum_{d|k}f(\frac kd)g(d)\\
&=\sum_{d=1}^n\sum_{1\le k\le n\\~~d|k}g(d)f(\frac kd)\\
&=\sum_{d=1}g(d)\sum_{k=1}^{\left\lfloor\frac nd\right\rfloor}f(k)\\
&=\sum_{d=1}^ng(d)F(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>在上两例中，$f ∗ g$ 和 $g$ 的前缀和都可以 $O(1)$ 得出，因此 $f$ 可 以用杜教筛计算</p>
<p>其实并不需要如此强的性质</p>
<p>可以看到，在杜教筛的过程中，我们实际上求出了所有特殊点处的前缀和。 </p>
<p>注意到 $g$ 的前缀和是对使得 $\left\lfloor\frac nd\right\rfloor$ 相同 $d$ 分段的时候用到的，因此只需要用到 $g$ 在段落端点处的前缀和。 </p>
<p>可以发现，段落的端点恰好是所有的特殊点。 </p>
<p>因此，$f, g$ 以及 $f ∗ g$ 这三个函数中，只要有两个可以用不弱于杜教筛的方法求值，就可以杜教筛第三个。</p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="Euler-定理"><a href="#Euler-定理" class="headerlink" title="$Euler$定理"></a>$Euler$定理</h2><p>$Euler$ 定理指出，对于正整数 $n$ 以及与 $n$ 互质的正整数 $a$，有</p>
<script type="math/tex; mode=display">
a^{\varphi(n)}\equiv1\pmod n</script><h3 id="一个常用结论"><a href="#一个常用结论" class="headerlink" title="一个常用结论"></a>一个常用结论</h3><p>对于正整数 $n$ 与正整数 $a$，$Euler$ 定理说明如果 $a\perp n$，那么对 于任意的 $m$，有</p>
<script type="math/tex; mode=display">
a^m\equiv a^{m\mod \varphi(n)}\pmod n</script><p>如果 $a$ 与 $n$ 不一定互质，若 $m \ge \varphi(n)$，我们也有以下结论</p>
<script type="math/tex; mode=display">
a^m\equiv a^{m \mod \varphi(n)\;+\;\varphi(n)}\pmod n</script><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>给定正整数 $n$，对于 $a$ 满足 $a\perp n$，定义 $a$ 模 $n$ 的阶为最小的正整数 $d$ 使得下式成立：</p>
<script type="math/tex; mode=display">
a^d\equiv1\pmod n</script><p>$a$模$n$的阶记作$\delta_n(a)$</p>
<p>由 $Euler$ 定理可以得到 $\delta_n(a) | \varphi(n)$</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>若 $\delta_n(a) = \varphi(n)$，则称 $a$ 是模 $n$ 的原根。 可以看出，$a$ 是模 $n$ 的原根当且仅当 $a^0,a^1,\cdots,a^{\varphi(n)−1}$ 在 $\mod n$ 意义下两两不同</p>
<p>这也是原根重要的性质和等价定义 </p>
<p>模 $n$ 存在原根当且仅当 $n = 1, 2, 4, p^k , 2p^k$，其中 $p$ 为素数，$k$ 为正整数。</p>
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><p>设 $g$ 是模 $n$ 的原根。那么对于任意 $a$ 满足 $a\perp n$，均存在 $k$ 使 得</p>
<script type="math/tex; mode=display">
g^k\equiv a\pmod n</script><p>这样的关系有助于把 $\mod n$ 的乘法转化为 $\mod \varphi(n)$ 的加法，与对数的作用有相似之处</p>
<h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="$Lucas$ 定理"></a>$Lucas$ 定理</h2><p>用 $\dbinom{n}{k}$ 表示二项式系数</p>
<p>若 $p$ 是素数，则有：</p>
<script type="math/tex; mode=display">
\dbinom nm\equiv\dbinom{n\mod p}{m\mod p}\dbinom{\left\lfloor\frac np\right\rfloor}{\left\lfloor\frac mp\right\rfloor} \pmod p</script><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><p>若将 $n, m$ 都表示为 $k$ 位的 $p$ 进制数，即</p>
<script type="math/tex; mode=display">
n=\sum_{i=0}^{k-1}n_i\cdot p^i\\
m=\sum_{i=0}^{k-1}m_i\cdot p^i</script><p>那么有</p>
<script type="math/tex; mode=display">
\dbinom nm\equiv\prod_{i=1}^{k-1}\dbinom{n_i}{m_i} \pmod p</script><h2 id="组合数取模"><a href="#组合数取模" class="headerlink" title="组合数取模"></a>组合数取模</h2><p>如何求 $\dbinom{n}{m} \mod p\;$</p>
<p>如果 $n, m &lt; p$，我们可以预处理 $0$ 到 $n − 1$ 的阶乘及他们模 $p$ 的逆元，就可以 $O(1)$ 计算一个组合数 </p>
<p>否则利用 $Lucas$ 定理递归的计算</p>
<center> <a href="./download.zip">附件下载 </center>

<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数论</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初赛整合-临门一脚[转载&amp;置顶]</title>
    <url>/AlanTuringLi/2223/10/22/%E5%88%9D%E8%B5%9B%E6%95%B4%E5%90%88-%E4%B8%B4%E9%97%A8%E4%B8%80%E8%84%9A/</url>
    <content><![CDATA[<p><a href="https://denerate.ink/articles/%E5%88%9D%E8%B5%9B%E6%95%B4%E5%90%88-%E4%B8%B4%E9%97%A8%E4%B8%80%E8%84%9A/">🔗原文链接</a></p>
<ul>
<li><p>CSP一年三次，分为”入门组”，”提高组”，”专业认证”，到今年为止，CCF已成功举办19次CSP</p>
</li>
<li><p>NOIP开始于1996年，全称是National Olympiad in Informatics in Provinces</p>
</li>
<li><p>NOI开始于1983年，今年是第37届在湖南长沙一中举行</p>
</li>
<li><p>IOI第一届于1989年在保加利亚的布拉维茨举行</p>
</li>
<li><p>省队名额分为A,B,C,D,E，初中只能进E队</p>
</li>
<li><p>Linux系统具有开源且免费，跨平台等优良特征，而Mac OS，Windows系统并不开源</p>
</li>
<li><p>常用的电脑操作系统：Windows，UNIX，Linux，Mac OS，DOS，Windows系统使用最广，Linux深受码农喜爱</p>
</li>
<li><p>正数的补码为其本身，负数的补码为其除了符号位之后取反+1的值</p>
</li>
<li><p>计算机能直接执行的指令：操作码和操作数（而非：源操作数和目标操作数）<br>“∨” 表示”或”<br>“∧” 表示”与”<br>“┐”表示”非”</p>
</li>
<li><p>CSP和NOIP举办的目的不同，且没有从属关系</p>
</li>
<li><p>照片内存计算：分辨率 * 位数 / 字长(8) / $ 1024^x $</p>
</li>
<li><p>概念：贪心是求局部最优，以得到全局最优 true</p>
</li>
<li><p>函数式编程语言<br>定义：函数式编程语言（functional programming language）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）<br>特征：</p>
<ul>
<li>1.以“函数”为首，如同命令式语言中的“变量”，函数可以赋值给其他变量，可以作为其他函数的参数，或者作为其他函数的返回值</li>
<li>2.不修改变量的值</li>
<li>3.只有表达式，没有语句。此处的语句指的是没有返回值得某些操作</li>
<li>4.引用透明（Referential transparency），函数的运行不依赖与外部变量或“状态”，简单的说就是，同一个输入（参数），总是会产生同一个输出（返回值），这与数学函数的特征很一致。命令式语言因为全局变量等的存在，就无法做到这一点</li>
<li>5.对比命令式语言，递归形式的循环</li>
</ul>
</li>
<li><p>纯函数式编程语言：Concurrent Clean，Haskell，Miranda，Lazy K<br>非纯函数式编程语言：F#，ML，OCaml，Scala，Erlang，LISP，LOGOScheme，Clojure，Mathematica，R，Unlambda<br>其他函数编程语言：APL，XSLT</p>
</li>
<li><p>树边（tree edge）：每次搜索找到一个还没有访问过的结点的时候就形成了一条树边<br>反祖边（back edge）：也被叫做回边，即指向祖先结点的边<br>横叉边（cross edge）：它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 并不是 当前结点的祖先时形成的<br>前向边（forward edge）：它是在搜索的时候遇到子树中的结点的时候形成的<br>$ \therefore $ 对于DFS生成树有树边，返祖边，横叉边，无前向边</p>
</li>
<li><p><a href="https://denerate.ink/articles/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/">时间复杂度主定理</a></p>
</li>
<li><p>闰年-&gt;分为普通闰年和世纪闰年<br>普通闰年：公历年份是4的倍数的，且不是100的倍数，为普通闰年<br>世纪闰年：公历年份是整百数的，必须是400的倍数才是世纪闰年</p>
</li>
<li><p>闰月-&gt;是一种立法置闰方式，在亚洲（尤其在中国），闰月特指农历每$ 2 \sim 3 $年增加的一个月</p>
</li>
<li><p><a href="https://imgchr.com/i/06XN9S"><img src="https://s1.ax1x.com/2020/10/11/06XN9S.png" alt="06XN9S.png"></a></p>
</li>
<li><p>计算机在存储，传送或操作时<br>字：一个单元的一组二进制码<br>字长：一个字中的二进制位的位数</p>
</li>
<li><p>字长是决定电脑计算精度<br>衡量CPU指标的是字长<br>　字长越长，电脑运算能力越强，精度越高，有效数据的存储单元数越多，寻址能力越强</p>
</li>
<li><p>32位系统的最大寻址空间为4GB<br>64位系统的最大寻址空间为</p>
<script type="math/tex; mode=display">
2^{64} = 4^{32} >> 1e8</script></li>
<li><p>$ B \rightarrow KB \rightarrow MB \rightarrow GB \rightarrow TB \rightarrow PB \rightarrow EB \rightarrow ZB \rightarrow YB $</p>
</li>
<li><p>KiB是kilo binary byte的缩写，指千位二进制字节，1KiB=1024B<br>KB是kilobyte的缩写，指千字节，1KB=1000B</p>
</li>
<li><p>机器字长：是指计算机能直接处理的二知进制数据的位数，zhi决定了计算机的运算精度<br>指令字长：一个指令字中包含二进制代码的位数<br>存储字长：一个存储单元存储一串二进制代码（存储字专），这属串二进制代码的位数称为存储字长，存储字长可以是8位、16位、32位等</p>
</li>
<li><p><a href="https://denerate.ink/articles/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%89%A9%E5%B1%95%E6%A6%82%E5%BF%B5/">二分图相关概念</a></p>
</li>
<li><p>NOI各省组织单位必须遵循CCF《关于 NOIP 数据提交格式的说明》的规范在竞赛结束后规定时间内向 CCF 提交本赛区所有参赛选手的程序</p>
</li>
<li><p>英特尔是全球最大的半导体芯片制造商，成立于1968年<br>AMD是目前业内唯一一个可以提供高性能CPU，高性能独立显卡GPU，主板芯片组三大组件的半导体公司，并是首家推出x86架构处理器的公司</p>
</li>
<li><p>CPU<br>功能：解释计算机指令，处理计算机软件中的数据<br>组成：控制器，运算器，高速缓冲存储器，以及连接它们的数据控制的总线<br>功效：处理指令，执行操作，控制时间，处理数据</p>
</li>
<li><p>CPU性能衡量指标：主频，位数，缓存指令集<br>主频：时钟频率<br>位数：处理器能够一次性计算的浮点数位数<br>缓存指令集：主要指的是能够对CPU运算进行知道以及优化的硬程序</p>
</li>
<li><p>计算机三大核心部件：CPU，内部存储器，输入/输出设备</p>
</li>
<li><p>图形加速器（图形加速卡）：<br>概念：一种以芯片集成方式专门进行图形运算的图像适配卡<br>组成：一般由具备独立CPU的硬件和相应软件构成<br>用途：专门为图形图像显示而优化</p>
</li>
<li><p>3D加速器：一种可安装成城电脑</p>
</li>
<li><p>g++编译器常用指令：<br>-Ofast：-Ofast优化<br>-o：file生成指定的输出文件<br>-O0：不进行优化处理<br>-O（-O1）：优化生成代码<br>-O2：进一步优化<br>-O3：比-O2更进一步优化，包括inline函数<br>exec：将源文件编译为可执行程序且保留调试信息<br>-w：不生成任何警告信息<br>-Wall：生成所有警告信息<br>-E：只运行C预编译器<br>-c：只编译并生成目标文件<br>-g：生成调试信息（GNU调试器可利用该信息）<br>-shared：生成共享目标文件（通常用在建立共享库时）<br>-static：禁止使用共享链接</p>
</li>
<li><p>P类问题（polynominal，多项式）：存在多项式时间算法的问题<br>NP问题（Nondeterministic polynominal，非确定性多项式）：能在多项式时间内验证得出一个正确解的问题（不知道这个问题存不存在多项式时间的算法）<br>NPC问题（Nondeterminism Polynomial complete）：存在这样一个NP问题，所有的NP问题都可以约化成它<br>NP-Hard问题：NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是它不一定是一个NP问题<br><img src="https://i.loli.net/2020/10/10/PZqDrCM1gKpRfLz.jpg" alt="初赛-3.jpg"></p>
</li>
<li><p>常见图像文件格式：<br>PSD，PDD：Photoshop软件自身的专用格式，是唯一能支持全部图像颜色模式的格式<br>GIF：一种使用LZW压缩的格式，目的在于最小化文件和减少传输时间<br>JPEG，JPG：既是一种文件格式，又是一种压缩技术<br>PNG：可以存储透明，完爆GIF格式的地方在于失真小，没锯齿，缺点是不支持动画<br>PDF：一种灵活的，跨平台，跨应用程序的便携文档格式，可以精确地显示并保留字体<br>SVG：可缩放的矢量图形，当该格式文件的图像进行任意缩放，都不放影响他的清晰度和光滑度</p>
</li>
<li><p>编译器功能：一种语言（通常为高级语言）翻译为另一种语言（通常为低级语言）<br>主要工作流程：源代码 (source code) → 预处理器(preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器(Linker) → 可执行程序 (executables)</p>
</li>
<li><p>Gitee：基于Git的代码托管和研发协作平台</p>
</li>
<li><p><a href="https://denerate.ink/articles/memset%E5%A4%84%E7%90%86/">memset的一般设置</a></p>
</li>
<li><p>计算机发展代别划分：<br><img src="https://i.loli.net/2020/10/10/viQbReHfqO5ZP6l.png" alt="初赛-1.png"></p>
</li>
<li><p>1946年2月，在美国宾夕法尼亚大学诞生了世界上第一台电子计算机ENIAC（Electronic Numerical Integrator And Computer），这台计算机占地170 $ m^2 $，重达30t，用了18000多个电子管，加法运算次数5000次/s</p>
</li>
<li><p>1944年，美籍匈牙利数学家冯·诺依曼提出计算机基本结构和工作方式的设想，为计算机的诞生和发展提供了理论基础<br>其理论要点：计算机硬件设备由存储器、运算器、控制器、输入设备和输出设备5部分组成<br>存储程序思想：把计算过程描述为由许多命令按一定顺序组成的程序，然后把程序和数据一起输入计算机，计算机对已存入的程序和数据处理后，输出结果</p>
</li>
<li><p>计算机分类：巨型机，大中型机，小型机，微型机，工作站</p>
</li>
<li><p>图灵（Alan Turing）是英国人，1913年图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，二战爆发后回到剑桥，后曾协助军方破解德国著名密码系统Enigma，帮助盟军取得了二战胜利</p>
</li>
<li><p>汉字信息编码：<br>1.汉字交换码：汉字交换码是指不同的具有汉字处理功能的计算机系统之间在交换汉字信息时所使用的代码标准。国家标准GB2312－80公布以来，我国一直延用该标准所规定的国标码作为统一的汉字信息交换码(GB5007-85图形字符代码)。</p>
<ul>
<li>GB2312－80标准包括了6763个汉字，按其使用频度分为一级汉字3755个和二级汉字3008个。一级汉字按拼音排序，二级汉字按部首排序。该标准还包括标点符号、数种西文字母、图形、数码等符号682个。              </li>
<li>区位码的区码和位码均采用从01到94的十进制，国标码采用十六进制的21H到73H（数字后加H表示其为十六进制数）。区位码和国标码的换算关系是：区码和位码分别加上十进制数32。如“国”字在表中的25行90列，其区位码为2590，国标码是397AH<br>2.字形存储码：字形存储码是指供计算机输出汉字（显示或打印）用的二进制信息，也称字模。通常，采用的是数字化点阵字模              </li>
<li>一般的点阵规模有16×16，24×24等，每一个点在存储器中用一个二进制位（bit）存储。在16×16的点阵中，需8×32 bit 的存储空间，每8 bit为1字节，所以，需32字节的存储空间。在相同点阵中，不管其笔划繁简，每个汉字所占的字节数相等。             </li>
<li>为了节省存储空间，普遍采用字形数据压缩技术。所谓的矢量汉字是指用矢量方法将汉字点阵字模进行压缩后得到的汉字字形的数字化信息</li>
</ul>
</li>
<li><p>IP地址：所谓IP地址，是用于标识 IP Internet 网络上节点的 32 位地址(以后可能使用的V6版本是128位的，分8组，每组16位)。对于 IP Internet 网络上的每个节点都必须指派一个唯一的地址，它由网络 ID 和唯一的主机 ID 组成。该地址通常用由句点分隔的八位字节的十进制数表示(例:192.168.7.27)。</p>
</li>
<li><p>算法性质：有穷性，确定性，输入，输出，可行性</p>
</li>
<li><p>0的反码有两种表示：$ +0 \rightarrow 000 \cdots 000，-0 \rightarrow 111 \cdots 111 $</p>
</li>
<li><p>C++运算等级：<br><img src="https://i.loli.net/2020/10/10/5CZH6uYresFRg71.png" alt="初赛-2.png"></p>
</li>
</ul>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>动态DP</title>
    <url>/AlanTuringLi/2020/09/18/%E5%8A%A8%E6%80%81DP/</url>
    <content><![CDATA[<h1 id="DDp"><a href="#DDp" class="headerlink" title="DDp"></a><a href="https://www.luogu.com.cn/problem/P4719">DDp</a></h1><h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>大概就是说, 有一棵树, 点权是会发生改变的, 让你动态求最大权独立集</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到我们每次修改一个点, 能够受到影响的点就只有链上的点, 可以直接暴力更新</p>
<p>貌似这道题数据随机, 没有出到链的情况, 所以暴力更新是可以随便过的</p>
<p>先来一份暴力的</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p[maxn], f[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">2</span>], cur;</span><br><span class="line"><span class="type">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], __next[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __next[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>] = p[u], dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(head[u]); i; i = __next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[edge[i]][<span class="number">0</span>], dp[edge[i]][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[edge[i]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a = __read(), b = __read();</span><br><span class="line">        <span class="built_in">AddEdge</span>(a, b), <span class="built_in">AddEdge</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = __read(), val = __read();</span><br><span class="line">        <span class="type">int</span> update = val - p[x];</span><br><span class="line">        p[x] += update;</span><br><span class="line">        <span class="type">int</span> lst = x;</span><br><span class="line">        <span class="type">int</span> l0 = dp[x][<span class="number">0</span>], l1 = dp[x][<span class="number">1</span>];</span><br><span class="line">        dp[x][<span class="number">1</span>] += update;</span><br><span class="line">        x = f[x];</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="type">int</span> t0 = dp[x][<span class="number">0</span>], t1 = dp[x][<span class="number">1</span>];</span><br><span class="line">            dp[x][<span class="number">0</span>] -= <span class="built_in">max</span>(l0, l1);</span><br><span class="line">            dp[x][<span class="number">0</span>] += <span class="built_in">max</span>(dp[lst][<span class="number">0</span>], dp[lst][<span class="number">1</span>]);</span><br><span class="line">            dp[x][<span class="number">1</span>] += dp[lst][<span class="number">0</span>] - l0;</span><br><span class="line">            l0 = t0, l1 = t1;</span><br><span class="line">            lst = x;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//真挺暴力的</span></span><br></pre></td></tr></table></figure>
<p>那么显然不能就这样说过去了的, 至少还是要<del>看看别人这是怎么写的吧</del></p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>动态$dp$的套路是把$dp$方程写成矩阵乘法, 然后用什么$LCT$, 树剖, 线段树, 倍增啥啥啥的维护一下</p>
<p>这道题的矩阵乘法大概是这个样子:</p>
<script type="math/tex; mode=display">
C_{i,j}=\max_{k=1}^n(A_{i,k}+B_{k,j})</script><p>易证可以满足结合律, 可以像矩阵乘法一样乱写</p>
<p>然后就是构造矩阵, 找转移方程</p>
<p>老套路: $f(i,0)$表示这个点不作为独立集中的点, $f(i,1)$表示作为独立及中的点</p>
<p>那么显然有:</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{u,0}&=\sum _{v\in son_u}max(f_{v,0}, f_{v,1})\\
f_{u,1}&=val_u+\sum_{v\in sonu} f_{v,0}
\end{align*}</script><p>啊，全局平衡二叉树还没会，先搁着</p>
<p>看看这？<a href="https://www.mina.moe/archives/11789">优质题解</a></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>数据结构</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>名探偵コナン</title>
    <url>/AlanTuringLi/2021/04/30/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Part-One"><a href="#Part-One" class="headerlink" title="Part One"></a>Part One</h1><div class="table-container">
<table>
<thead>
<tr>
<th>TV 版</th>
<th>简单剧情</th>
</tr>
</thead>
<tbody>
<tr>
<td>001 云霄飞车杀人事件</td>
<td>（黑衣组织—琴酒 、伏特加出场，工藤新一喝下 APTX4869变小。 大幕拉开）</td>
</tr>
<tr>
<td>002 董事长千金诱拐事件</td>
<td>（阿笠博士知道其身份，工藤新一化名为江户川柯南，住进毛利侦探事务所）</td>
</tr>
<tr>
<td>005 新干线大爆破事件</td>
<td>（假琴酒和沃卡登场）</td>
</tr>
<tr>
<td>007 每月一件礼物威胁事件</td>
<td>（兰初次怀疑柯南是新一）</td>
</tr>
<tr>
<td>014 奇怪的寻人事件</td>
<td>（宫野明美初登场）</td>
</tr>
<tr>
<td>043 江户川柯南诱拐事件</td>
<td>（工藤父母知道变小）</td>
</tr>
<tr>
<td>049 ～ 050 外交官杀人事件（上集）</td>
<td>（服部平次登场，工藤新一第一次恢复 )</td>
</tr>
<tr>
<td>056 电玩公司杀人事件</td>
<td>（龙舌兰出现，被炸死）</td>
</tr>
<tr>
<td>059 ～ 060 福尔摩斯迷杀人事件</td>
<td>（服部平次知道柯南身份）</td>
</tr>
<tr>
<td>124 ～ 125 浪花连续杀人案</td>
<td>不仅是远山和叶的初登场，而且黑衣组织底层人员沼渊己一郎也在这一集初登场</td>
</tr>
<tr>
<td>135 黑暗组织 10 亿抢劫事件</td>
<td>（宫野明美被 GIN 杀死，黑衣组织浮出水面）</td>
</tr>
<tr>
<td>136 ～139 黑暗组织来的女子 大学教授杀人事件</td>
<td>（灰原哀出场）</td>
</tr>
<tr>
<td>140 ～ 141 竞技场一视同仁胁迫事件</td>
<td>（灰原说出了工藤新一与组织在半个世纪前就有了关系 )</td>
</tr>
<tr>
<td>181 ～182 黑暗之中的死角</td>
<td>（重要人物新出医生登场）</td>
</tr>
<tr>
<td>190 与黑暗组织的再会（灰原篇）</td>
<td>（皮斯克出场）</td>
</tr>
<tr>
<td>191 与黑暗组织的再会（柯南篇）</td>
<td>（宫野志保第一次恢复）</td>
</tr>
<tr>
<td>192 与黑暗组织的再会（解决篇）</td>
<td>（皮斯克被琴酒灭口，贝尔摩德出场）</td>
</tr>
<tr>
<td>205 生死一瞬间 第三个选择</td>
<td>（工藤新一第二次恢复）</td>
</tr>
<tr>
<td>235 ～ 238 被召集的名侦探 工藤新一 vs 怪盗基德 一</td>
<td>（提到了乌丸莲耶，疑似 BOSS，半个世纪以前很有钱）</td>
</tr>
<tr>
<td>245 战斗游戏的陷阱（上集）</td>
<td>（朱蒂出场）</td>
</tr>
<tr>
<td>246 战斗游戏的陷阱（下集）</td>
<td>（茱蒂称呼柯南为 Cool guy）</td>
</tr>
<tr>
<td>249 ～ 250 神秘乘客（上集）</td>
<td>（赤井秀一出场，形势复杂）</td>
</tr>
<tr>
<td>261 元太的灾难</td>
<td>（提到 GIN 是左撇子 )</td>
</tr>
<tr>
<td>277 来自芝加哥的男人（上集）</td>
<td>（詹姆斯·布莱克出场）</td>
</tr>
<tr>
<td>278 来自芝加哥的男人（下集）</td>
<td>（詹姆斯称呼柯南为福尔摩斯、 Cool guy）</td>
</tr>
<tr>
<td>291 犯罪的纪念品（上集）</td>
<td>（毛利小五郎的卷宗被盗，目标直指柯南）</td>
</tr>
<tr>
<td>292 犯罪的纪念品（下集）</td>
<td>（赤井秀一在毛利侦探事务所外监视）</td>
</tr>
<tr>
<td>293 情急之下的应变之道（上集）</td>
<td>（小兰开始回忆赤井秀一）</td>
</tr>
<tr>
<td>294 情急之下的应变之道（下集）</td>
<td>（茱蒂说：快到了收获苹果的时候了。同时灰原被贝尔摩德怀疑）</td>
</tr>
<tr>
<td>299 ～ 300 英语教师 VS关西名侦探</td>
<td>（柯南叫博士调查克里斯·宾亚德）</td>
</tr>
<tr>
<td>301 ～302 疯狂足球迷 上集</td>
<td>（知道克里斯·宾亚德在她母亲葬礼上说出了她的经典台词）</td>
</tr>
<tr>
<td>306 ～ 307 中华街的雨中幻影 下集</td>
<td>（小兰回忆起包含克丽斯和秀一的纽约的事情）</td>
</tr>
<tr>
<td>308 工藤新一的纽约事件 （事件篇）</td>
<td>（知道克里斯就是美国已故大明星莎隆 .宾亚德的女儿。 ）</td>
</tr>
<tr>
<td>310 工藤新一的纽约事件 （解决篇）</td>
<td>（贝尔摩德扮成杀人魔登场，赤井秀一对其进行追踪。兰得知赤井秀一是 FBI。）</td>
</tr>
<tr>
<td>311 光彦森林迷失记 上集</td>
<td>（沼渊己一郎跟黑暗组织有关）</td>
</tr>
<tr>
<td>326 ～ 329 震撼警政厅 1200 万人质</td>
<td>（松田警官跟安室有关系）</td>
</tr>
<tr>
<td>332 残留下来的无声证言（前篇）</td>
<td>（再次抓住黑暗组织的尾巴）</td>
</tr>
<tr>
<td>333 残留下来的无声证言（后篇）</td>
<td>（下一集的引子）</td>
</tr>
<tr>
<td>334 接触黑色组织（交涉篇）</td>
<td>（柯南从小兰得知赤井秀一是 FBI的事情）</td>
</tr>
<tr>
<td>335 接触黑色组织（追踪篇）</td>
<td></td>
</tr>
<tr>
<td>336 接触黑色组织 （决死篇）</td>
<td>（柯南得知组织在雇佣电脑工程师编写一个神秘的系统软件）</td>
</tr>
<tr>
<td>354 ～ 355 用钱买不到的友情</td>
<td>（本集中提到了灰原的父亲：宫野厚司。是阿笠博士的旧 识。）</td>
</tr>
<tr>
<td>360 东京现像所的秘密（前篇）</td>
<td>（灰原感觉被跟踪）</td>
</tr>
<tr>
<td>361 东京现像所的秘密（后篇）</td>
<td>（灰原被赤井秀一所派叼烟男子开车跟踪，赤井秀一最后 看着灰原照片说：但是，还真像啊）</td>
</tr>
<tr>
<td>363 ～ 364 四辆保时捷</td>
<td>（茱蒂、赤井发现灰原与黑衣组织有联系、贝尔摩德知道灰原的 身份）</td>
</tr>
<tr>
<td>365 ～ 366 隐藏在厕所中的秘密</td>
<td>（灰原在厕所中找到了妈妈的录音留言）</td>
</tr>
<tr>
<td>369 ～ 370 便利商店的陷阱（后篇）</td>
<td>（小兰发现茱蒂老师公寓墙后的照片，引起对朱蒂身份的怀疑）</td>
</tr>
<tr>
<td>371 ～ 375 与黑色组织面对面 满月之夜的两起神秘事件</td>
<td>（茱蒂、 赤井、詹姆斯身份曝光，贝尔摩德扮成新出医生暴露，柯南得知 BOSS邮箱按键音，贝尔摩德称呼柯南为银色子弹，并期待他能击垮黑衣组织， 并对 GIN 隐藏了柯南就是工藤的事实， 从此可看出贝尔摩德和组织不寻常的关系）</td>
</tr>
<tr>
<td>392 ～ 393帝丹高中校园灵异事件</td>
<td>（真正的新出医生回归）</td>
</tr>
<tr>
<td>405 ～ 406 星星与香烟的暗号</td>
<td>（柯南听到山村警官给他奶奶打电话的按键音和贝尔摩的 给 Boss发简讯时的按键音相似，推测 boss 在鸟取县）</td>
</tr>
<tr>
<td>419 斯特拉迪瓦里小提琴的不和谐音 (前奏曲 )</td>
<td>（boss 的邮箱号被发现是 0858）</td>
</tr>
<tr>
<td>421 斯特拉迪瓦里小提琴的不和谐音 (尾奏曲 )</td>
<td>（柯南得知 BOSS邮箱地址是日本童谣《七个孩子》）</td>
</tr>
<tr>
<td>428 诡异宅院大冒险（封印篇）</td>
<td>（柯南推理出 BOSS的邮箱号码，但灰原阻止柯南去调查这个号，并称之为“潘多拉之盒”）</td>
</tr>
<tr>
<td>459 ~ 463 黑色冲击 ! 组织之手逼近的瞬间</td>
<td>（水无怜奈、基安蒂、科恩出场， GIN 开始怀疑毛利小五郎，赤井秀一称呼 GIN 为宿敌，水无怜奈出车祸后被 FBI抓获）</td>
</tr>
<tr>
<td>467 无法回头的两人 (前篇 )</td>
<td>（本堂瑛佑出场，长得和水无怜奈很像）</td>
</tr>
<tr>
<td>502 ～ 505 黑暗组织之影</td>
<td>（本堂瑛佑行事诡异，引起柯南注意）</td>
</tr>
<tr>
<td>527 ～528 黑色相片的下落</td>
<td>（寻找本堂瑛佑父亲的照片，柯南怀疑本堂瑛佑父亲是CIA的人）</td>
</tr>
<tr>
<td>538 ~ 551 红与黑的碰撞</td>
<td>（此系列讲： GIN 用计将水无怜奈从赤井秀一手中夺回）（第二次对决，赤井秀一疑似牺牲，水无怜奈 CIA身份遭到组织怀疑）</td>
</tr>
<tr>
<td>554 ～ 555 卡拉 OK包房的死角（后篇）</td>
<td>（本堂瑛佑知道了柯南是工藤新一）</td>
</tr>
<tr>
<td>556 红白黄色和侦探团</td>
<td>（水无怜奈给朱蒂传递信息，组织派出一名代号为波本的成员专门调查雪莉。冲矢昴出场，灰原哀察觉出异样）</td>
</tr>
<tr>
<td>572 ～ 573 新一的真实身份和兰的眼泪</td>
<td>（工藤新一第三次恢复）</td>
</tr>
<tr>
<td>593 ～ 594 鱼儿消失的一角岩</td>
<td>（冲矢昴的言语直逼灰原）</td>
</tr>
<tr>
<td>614 ～ 615 侦探团 VS抢匪团</td>
<td>（“烧伤赤井秀一”登场）</td>
</tr>
<tr>
<td>629 引发危机的红色前兆</td>
<td>（发生诸多故事为下集埋伏笔）</td>
</tr>
<tr>
<td>630 黑与 13 的暗示</td>
<td>（疑似秀一的男子和冲矢昴同时出现， 局势再次混乱， 赤井秀一身份再次遭人怀疑）</td>
</tr>
<tr>
<td>631 步步逼近的黑色期限</td>
<td>（水无怜奈被琴酒怀疑没有杀掉赤井秀一）</td>
</tr>
<tr>
<td>632 摇曳的红色目标</td>
<td>（琴酒准备让基安蒂对疑似 赤井秀一的人进行狙击但并未成功，后来得知贝尔摩德通知后， GIN 主动放弃，还笑着说： “真是独断专行， 他还是那么让我不爽。 ……真希望他只是小说中的人物， 像夏洛克福尔摩 斯那样的侦探” )</td>
</tr>
<tr>
<td>673 ～ 674 紧急事态 252 下集</td>
<td>（冲矢昴行为诡异，证明了他有极强的洞察力，身手也不凡。灰原再次对冲矢昴有组织感觉）</td>
</tr>
<tr>
<td>697 幽灵饭馆的推理对决 上集</td>
<td>（世良真纯登场，自称侦探，身份可疑）</td>
</tr>
<tr>
<td>698 幽灵饭馆的推理对决 下集</td>
<td>（世良似乎对“新一”的名字有耳闻。之后转到小兰班上）</td>
</tr>
<tr>
<td>699 侦探事务所挟持事件 突发</td>
<td>（世良来侦探事务所打听柯南信息，柯南感觉她可能很像自己认识的某个人。侦探事务所遭炸弹劫持，事态危急）</td>
</tr>
<tr>
<td>702 ～ 703 柯南 VS平次东西侦探推理对决 上集</td>
<td>（ FBI的茱蒂、卡迈尔等人对世良有似曾相识的感觉。詹姆斯则一眼就认出世良是女生，显得更加可疑）</td>
</tr>
<tr>
<td>708 ～ 709 博士的影音网站</td>
<td>（世良她对灰原有很大兴趣。并对着冲矢昴的窗户说： “我还以为是谁随随便便地住进来了呢， 不过现在看起来真是杞人忧天了啊……” 最后世良将视频中意外拍到的灰原影像在电脑中删除。）</td>
</tr>
<tr>
<td>719 ～ 720 婚礼前夕（前篇）</td>
<td>（安室透登场）</td>
<td></td>
</tr>
<tr>
<td>725 侦探们的夜想曲（推理）</td>
<td>（毛利小五郎暴露自己设置密码通常为： 5563）</td>
</tr>
<tr>
<td>726 侦探们的夜想曲（波本）</td>
<td>（简单的案件引出了波本，安室透、世良真纯、冲矢昴他们 互相见面，最后苦艾酒给波本打电话，安室透，冲矢昴，世良真纯同时接到电话，说明以上人中有一个就是波本）</td>
</tr>
<tr>
<td>727 ～ 728 一丁点都不原谅（前篇）</td>
<td>（里边提到了上集的一些内容，让灰原哀想到了冲矢昴和诸星大 {也就是赤井秀一 }有某方面的联系，暗示出冲矢昴有可能是赤井秀一假扮的，赤井秀一是没有死的）</td>
</tr>
<tr>
<td>733 ～ 735 以性命为赌注的恋爱转播（转播开始）</td>
<td>（伊达航成安室透为老朋友）</td>
</tr>
<tr>
<td>736 ～ 737 泡沫 热气与烟</td>
<td>（剧中提到了灰原哀对冲矢昴的认识：就是前几集提到的认为他是赤井秀一扮的；冲矢昴表现出了极强的洞察力，结尾处冲矢昴叫灰原哀为公主）</td>
</tr>
<tr>
<td>742 工藤优作未解决的事件（上）</td>
<td>（世良和冲矢昂见面，冲矢昂知道柯南真实身份）</td>
</tr>
<tr>
<td>743 工藤优作未解决的事件（下）</td>
<td>（世良说出 :我果然是个坏孩子呢）</td>
</tr>
<tr>
<td>751 ～ 752 迫近灰原秘密的黑影</td>
<td>（安室透， 冲矢昂， 世良纯真无意间都见到了变大后的雪莉， 冲矢昂喝波本酒。为下文埋伏笔）</td>
</tr>
<tr>
<td>753 ～ 756 漆黑的神秘列车</td>
<td>（波本身份揭露，怪盗基德代替雪莉假死）</td>
</tr>
<tr>
<td>757 密室里的柯南</td>
<td>（波本在知道自己身份暴露后，仍接近柯南）</td>
</tr>
<tr>
<td>758 推理的波本</td>
<td>（波本开始对毛利小五郎感兴趣，并看见柯南用麻醉针）</td>
</tr>
<tr>
<td>776 ～ 777 怪盗基德与赤面人鱼</td>
<td>（怪盗基德知道世良是女生，世良暴露出来自己对自己 的帽子很重视，暗示了世良和赤井秀一的关系）</td>
</tr>
<tr>
<td>779 ～ 780 装满水果的宝箱（后篇）</td>
<td>（小兰回忆起自己之前好像见过世良，看见世良的背影能想 起波浪，最后世良表示在时机成熟时会告诉柯南自己什么时候与柯南见过）</td>
</tr>
<tr>
<td>786 ～ 787 朱蒂的追忆与赏花的陷阱</td>
<td>（茱蒂知道假秀一的事情，波本和贝尔摩德合作调查出 了一些事情）</td>
</tr>
<tr>
<td>791 ～ 792 小五郎在酒吧里（后篇）</td>
<td>（柯南从高木知道了波本和贝尔摩德调查茱蒂的事情，并担 心灰原）</td>
</tr>
<tr>
<td>793 小兰也倒在了浴室里了（前篇）</td>
<td>（柯南知道了波本和贝尔摩德合作调查茱蒂的事情， 波本疑似发现雪莉假死的事情）</td>
</tr>
<tr>
<td>794 小兰也倒在了浴室了（后篇）</td>
<td>（柯南知道世良一直在跟她哥哥打电话，可能是在监视柯南）</td>
</tr>
<tr>
<td>804 ～ 805 招财三色猫事件</td>
<td>（安室透称柯南“将利爪隐藏在天真的笑容之下”）</td>
</tr>
<tr>
<td>809 赤女的惨剧 （复仇）</td>
<td>（世良故意让柯南看见自己的手机上的照片，领域外的妹妹登场）</td>
</tr>
<tr>
<td>812 结局惊人的恋爱小说 (前篇 )</td>
<td>（知道世良母亲一直在美国，在日本除了 2 个哥哥没有一个亲戚了，柯南见到了“领域外的妹妹”）</td>
</tr>
<tr>
<td>813 结局惊人的恋爱小说 (后篇 )</td>
<td>（“领域外的妹妹”调查柯南的眼镜架，说：这个窃听器，是我从来没见过的类型呢。 说明她见过很多这种发明， 怀疑她也吃了变小的药， 并开始对柯南感兴趣，并对世良说，以后柯南问起自己，就说自己是“领域外的妹妹”）</td>
</tr>
<tr>
<td>823 气氛僵硬的茶会 前篇</td>
<td>（波本开始调查楠田陆道，暴露了自己的外号“零”）</td>
</tr>
<tr>
<td>824 气氛僵硬的茶会 后篇</td>
<td>（高木暴露楠田陆道是被手枪所杀，为下级埋伏笔）</td>
</tr>
<tr>
<td>832 绯色的序章</td>
<td>（波本调查赤井秀一计划开始）</td>
</tr>
<tr>
<td>833 绯色的追求</td>
<td>（波本对 FBI 说出：从我们的日本离开。柯南怀疑波本是公安警察，卡迈尔暴露了楠田陆道自杀的消息）</td>
</tr>
<tr>
<td>834 绯色的交错</td>
<td>（波本和茱蒂同时分析出赤井秀一可能活着的消息）</td>
</tr>
<tr>
<td>835 绯色的回归</td>
<td>（波本进入冲矢昂家中当面对峙，赤井秀一现身）</td>
</tr>
<tr>
<td>836 绯色的真相</td>
<td>（波本公安警察身份公布，波本真实名字降谷零暴露，冲矢昂真实身份赤 井秀一公布，但在组织内未暴露，同时赤井秀一对波本说：至今对他的事情扔感抱歉，柯南知道新人物 -在琴酒之上的人物朗姆 RUM 出场）</td>
</tr>
<tr>
<td>838 太阁之恋的名人战上</td>
<td>（领妹和冲矢昴都对羽田秀吉夺冠感到高兴，而世良真纯却说领 妹的反应“好恶心”）</td>
</tr>
<tr>
<td>840 盛夏里沉入泳池的迷 上</td>
<td>（“领域外的妹妹”说出要测试柯南，要谨慎行事，还说如果 不符合她的期待，她们就必须尽快离开这儿，去寻找新的根据地。声音明显老气）</td>
</tr>
<tr>
<td>841 盛夏里沉入泳池的迷 下</td>
<td>（兰回忆自己也见过“领域外的妹妹”，同时回忆起世良纯真 小时侯说过：你是魔法师吧。说明兰和小世良和“领域外的妹妹”之间都有关系）</td>
</tr>
<tr>
<td>845 三名第一发现人 上</td>
<td>（新人物 RUM 出场，在 GIN 之上的人物，长相又像是老人又像是长发哥哥又像是大汉）</td>
</tr>
<tr>
<td>846 三名第一发现人 下</td>
<td>（得知朗姆有一只义眼）</td>
</tr>
<tr>
<td>865 县警的黑暗（前篇）</td>
<td>（啄木鸟事件，柯南发现大和警官有朗姆特征，还有黑田警官， 也被人评论“像某个组织的 BOSS”）</td>
</tr>
<tr>
<td>868 悄悄靠近安室的黑影</td>
<td>（苦艾酒通知安室透被 GIN 监视）</td>
</tr>
<tr>
<td>870 博客女演员的密室事件（后篇）</td>
<td>（显示出黑田警官特别看中柯南）</td>
</tr>
<tr>
<td>882 好吃得要死的拉面 2（前篇）</td>
<td>（领域外的“妹妹”名字疑似叫“玛丽”）</td>
</tr>
<tr>
<td>917 与 17 年前一样的案发现场（后篇）</td>
<td>（发现了在 17 年前杀害羽田浩司的是 RUM）</td>
</tr>
<tr>
<td>918 灵魂侦探被杀事件（前篇）</td>
<td>(继续寻找羽田浩司事件相关的线索 )</td>
</tr>
<tr>
<td>919 灵魂侦探被杀事件（后篇）</td>
<td>（“领妹”用变声器破解事件，并说那个少年已经跟跟10年前不一样了）</td>
</tr>
<tr>
<td>922 背叛的舞台（后篇）</td>
<td>（贝姐出现）</td>
</tr>
<tr>
<td>933 试衣间的死角 上篇</td>
<td>（小兰感觉隐约的见过世良）</td>
</tr>
<tr>
<td>934 试衣间的死角 后篇</td>
<td>（柯南也终于想起来了在哪里见过世良）</td>
</tr>
<tr>
<td>936 涟綺上的魔法师 前篇</td>
<td>（ 10 年前新一见到世良一家的场景）</td>
</tr>
<tr>
<td>945 新老师的骸骨事件 后篇</td>
<td>（疑似 RUM 的新老师登场）</td>
</tr>
<tr>
<td>950 隔壁的江户式推理秀 后篇</td>
<td>（疑似 RUM 的饭馆店员出现）</td>
</tr>
</tbody>
</table>
</div>
<h1 id="HIGH-LIGHT"><a href="#HIGH-LIGHT" class="headerlink" title="HIGH LIGHT"></a>HIGH LIGHT</h1><iframe src="//player.bilibili.com/player.html?aid=802604477&bvid=BV1Ay4y147Hs&cid=325082181&page=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<h1 id="Something-I-Wanna-Say"><a href="#Something-I-Wanna-Say" class="headerlink" title="Something I Wanna Say"></a>Something I Wanna Say</h1><p>柯南剧场版（TV版）在某种程度上讲，淡化了本应着重刻画的推理情节、柯南的人物特色，而加重的武打片的成份，有刻意博得观众眼球的嫌疑。这也是快餐文欢的一种表现，希望柯南能够重新回到曾经推理严密、人物特色鲜明的时代，再创动漫的巅峰。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>班会</tag>
      </tags>
  </entry>
  <entry>
    <title>基础多项式</title>
    <url>/AlanTuringLi/2020/07/29/%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>一个环 $R$ 上的关于 $x$ 的多项式可以写作 </p>
<script type="math/tex; mode=display">
A(x) = \sum_{i=0}^na_ix^i</script><p>其中 $a_i \in \mathbb{R}$</p>
<p>$x$ 被称为这个多项式的自由元</p>
<p>多项式的次数被定义为其最高非零次项的次数，记为 $\deg A(x)$</p>
<h2 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h2><p>设 $A(x),\; B(x)$ 是次数不超过 $n$ 的多项式</p>
<p>那么加法和减法运算被定义为： </p>
<script type="math/tex; mode=display">
A(x) \pm B(x) = \sum^n_{i=0} (a_i \pm b_i)x^i</script><p>显然可以在 $O(n)$ 时间内计算这两个多项式的和或差</p>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>设 $a, b$ 是两个数列，那么这两个数列的卷积 $c$ 的定义为 </p>
<script type="math/tex; mode=display">
c_k = \sum_{i+j=k} a_ib_j</script><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p>两个多项式的乘积被定义为：</p>
<script type="math/tex; mode=display">
A(x)B(x)=\sum_{i=0}^n\sum_{i=0}^na_ib_jx^{i+j}=\sum_{k=0}^{2n}c_kx^k</script><p>其中 $c$ 是 $a$ 与 $b$ 的卷积</p>
<p>朴素的按定义计算多项式乘法的时间复杂度是 $O(n^2)$ 的</p>
<h2 id="多项式点值表示"><a href="#多项式点值表示" class="headerlink" title="多项式点值表示"></a>多项式点值表示</h2><p>给定一个不超过 $n$ 次的多项式 $A(x)$ 以及 $n + 1$ 个不同的点 $x_0,\cdots,x_n$,令 $y_i = A(x_i)$</p>
<p>则这 $n + 1$ 组 $(xi , yi)$ 唯一的确定了这个多项式 $A(x)$</p>
<p>这些 $(x_i,y_i)$ 称作这个多项式的点值表示</p>
<p>如果给出 $A(x)$ 和 $B(x)$ 分别在 $x_0,\cdots,x_n$ 下的点值，则可以在 $O(n)$ 时间内得到 $A(x) \pm B(x)$ 或 $A(x)B(x)$ 在同一组位置处的点值</p>
<h2 id="系数与点值表示"><a href="#系数与点值表示" class="headerlink" title="系数与点值表示"></a>系数与点值表示</h2><p>给出 $n$ 次多项式 $A(x)$ 的各项系数，可以通过求值计算多项式的点值表示</p>
<p>给出 $n$ 次多项式 $A(x)$ 的点值表示，可以通过待定系数，解方程得到多项式的各项系数</p>
<p>得到多项式的各项系数</p>
<p>如何在多项式的系数和点值表示之间快速转换？</p>
<p>这促使我们考虑一组特殊的点值</p>
<h2 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h2><p><a href="https://alansblog.ink/2020/07/19/复数入门/#四-单位根"><strong>仅供参考</strong></a></p>
<p>满足 $x^n−1=0$ 的 $x$ 被称作 $n$ 次单位根</p>
<p>设 $\omega$ 是 $n$ 次单位根</p>
<p>如果 $ω_0,ω_1,\cdots, ω_m(m=n-1)$ 恰好生成了所有的 $n$ 次单位根（即两两不同），则称 $ω$ 为本原单位根</p>
<p>这等价于 $n$ 是 最小的使得 $\omega^n−1=0$ 的正整数。我们用 $\omega_n$ 来表示一个 $n$ 次本原单位根</p>
<p>在复数域 $\mathbb{C}$ 上，$\omega_n = \exp(\frac{2πi}n)=\cos\frac{2π}n +i\sin\frac{2π}n$ 是一个本原单位根</p>
<p>下文首先考虑 $\mathbb{C}$ 上的多项式</p>
<p>在有限域（即模素数的情况）中，本原单位根与数论中的原根有关</p>
<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>设 $a$ 是长度为 $n$ 的数列，对 $0 \le k &lt; n$，令</p>
<script type="math/tex; mode=display">
b_k=\sum_{i=0}^{n-1}a_i\cdot{\omega_n}^{ki}</script><p>则称 $b$ 为 $a$ 的离散傅里叶变换 $(DFT)$ ，记作 $b = F(a)$</p>
<p>容易看出，令 $A(x) = \sum a_ix^i$，则 $b_k$ 就是 $A(x)$ 在 ${ω_n}^k$ 处的点值</p>
<p>因此计算 $a$ 的 $DFT$ 与计算 $A(x)$ 在 ${\omega_n}^0,{\omega_n}^1,\cdots,{\omega_n}^{n−1}$ 处的点值表示是等价的</p>
<h2 id="离散傅里叶变换的逆变换"><a href="#离散傅里叶变换的逆变换" class="headerlink" title="离散傅里叶变换的逆变换"></a>离散傅里叶变换的逆变换</h2><p>对于长度为 $n$ 的序列 $a, b$，回忆 $DFT$ 的定义 :</p>
<script type="math/tex; mode=display">
b_k=\sum_{i=0}^{n-1}a_i{\omega_n}^{ki}(0\le k<n)\qquad(1)</script><p>下面我们来证明 $(1)$ 的逆变换$(IDFT)$如下 :</p>
<script type="math/tex; mode=display">
a_k=\frac 1n\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}(0\le k<n)\qquad(2)</script><p>考虑将$(1)$代入$b_i$, 有:</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}&=\sum_{i=0}^{n-1}{\omega_n}^{-ki}\sum_{j=0}^{n-1}{\omega_n}^{ij}a_j\\
&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{-ki}{\omega_n}^{ij}\\
&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}
\end{align*}</script><p>我们考虑式子中的$\sum\limits_{i=0}^{n-1}{\omega_n}^{i(j-k)}$这一部分</p>
<p>若 $j=k$ , 则</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}=\sum_{i=0}^{n-1}1=n</script><p>若 $j=k$, 则由 $0\le j, k\le n$, 有$|j-k| &lt; n$, 故${\omega_n}^{j-k}\ne1$</p>
<p>因此可以由等比数列数列求和的结论得到</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}&=\sum_{i=0}^{n-1}({\omega_n}^{j-k})^i\\
&=\frac{1-({\omega_n}^{j-k})^n}{1-{\omega_n}^{j-k}}\\
&=\frac{1-({\omega_n}^n)^{j-k}}{1-{\omega_n}^{j-k}}\\
&=\frac{1-1}{1-{\omega_n}^{j-k}}=0
\end{align*}</script><p>因此, 有</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac 1n\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}&=\frac 1n\sum_{i=0}^{n-1}{\omega_n}^{-ki}\sum_{j=0}^{n-1}{\omega_n}^{ij}a_j\\
&=\frac 1n\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}\\
&=\frac 1nna_k=a_k
\end{align*}</script><p>即$(2)$成立</p>
<p>类似的，可以证明由 $(2)$ 成立可以推出 $(1)$ 成立，故这两式是互逆的</p>
<p>这就是 $IDFT$</p>
<p>$IDFT$ 是 $DFT$ 的逆变换，也就意味着已知多项式在单位根处的点值，$IDFT$ 能够求出多项式的各项系数. 在这种意义上，这个 过程也可以看作插值</p>
<h2 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积"></a>循环卷积</h2><p>对于两个长度为 $n$ 的序列 $a, b$，定义</p>
<script type="math/tex; mode=display">
c_k=\sum_{(i+j)\;mod\;n\;=\;k}a_ib_j</script><p>则称 $c$ 为 $a$ 与 $b$ 的循环卷积，记为 $c = a ∗ b$</p>
<p>关于循环卷积与 $DFT$，我们有如下定理：</p>
<script type="math/tex; mode=display">
F(a*b)=F(a)\cdot F(b)</script><p>其中 $\cdot$ 表示逐点乘积</p>
<h2 id="快速傅里叶变换1"><a href="#快速傅里叶变换1" class="headerlink" title="快速傅里叶变换1"></a>快速傅里叶变换1</h2><p>按定义，我们可以 $O(n^2)$ 实现 $DFT$ 或 $IDFT$. 快速傅里叶变换是快速计算 $DFT$ 的方法，时间复杂度为 $O(n \log n)$</p>
<p>当 $n$ 为 $2$ 的幂次的时候，我们可以使用 $Cooley–Tukey$ 算法来实现 $FFT$</p>
<h2 id="单位根的一些性质"><a href="#单位根的一些性质" class="headerlink" title="单位根的一些性质"></a>单位根的一些性质</h2><p>考虑 $\omega_n$ 与$ω_m(m=2n)$, 我们有</p>
<script type="math/tex; mode=display">
({\omega_{2n}}^k)^2={\omega_n}^k\\
{\omega_{2n}}^{n+k}=-{\omega_{2n}}^k</script><p>设 $n = 2m$. 我们考虑将 $A(x)$ 的项按次数的奇偶性分类：</p>
<script type="math/tex; mode=display">
\begin{align*}
A(x)=\sum_{0\le i<n}a_ix^i&=\sum_{0\le i<m}a_{2i}x^{2i}+\sum_{0\le i<m}a_{2i+1}x^{2i+1}\\
&=\sum_{0\le i<m}a_{2i}x^{2i}+x\sum_{0\le i<m}a_{2i+1}x^{2i}
\end{align*}</script><p>定义</p>
<script type="math/tex; mode=display">
\begin{align*}
A_0(x)&=\sum_{0\le i<m}a_{2i}x^i\\
A_1(x)&=\sum_{0\le i<m}a_{2i+1}x^i
\end{align*}</script><p>那么 $A_0(x)$, $A_1(x)$ 都是次数不超过 $m$ 的多项式，并且有</p>
<script type="math/tex; mode=display">
A(x)=A_0(x^2)+xA_1(x^2)</script><h2 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h2><p>结合单位根的性质，对于 $0 ≤ k &lt; m$，我们有</p>
<script type="math/tex; mode=display">
\begin{align*}
A({ω_n}^k) &= A_0(({ω_n}^k)^2 ) + {ω_n}^kA_1(({ω_n}^k)^2) \\
&= A_0({ω_m}^k)+ {ω_n}^kA_1({ω_m}^k)\\
A({ω_n}^{m+k})&= A_0(({ω_n}^{m+k})^2)+{ω_n}^{m+k}A_1(({ω_n}^{m+k} )^2)\\
&= A_0({ω_m}^k)−{ω_n}^kA_1({ω_m}^k)
\end{align*}</script><p>以上两式常被称为蝴蝶操作</p>
<h2 id="快速傅里叶变换2"><a href="#快速傅里叶变换2" class="headerlink" title="快速傅里叶变换2"></a>快速傅里叶变换2</h2><p>通过蝴蝶操作的过程可以看出，如果我们得到了 $A_0(x), A_1(x)$ 在点 ${ω_m}^0,{ω_m}^1, . . . , {ω_m}^{m−1}$ 处的点值，我们可以在 $O(n)$ 时间内计算出 $A(x)$ 在 ${ω_n}^0 , {ω_n}^1,\cdots, {ω_n}^{n−1}$ 处的点值</p>
<p>而计算 $A0, A1$ 的点值的过程可以递归分治进行</p>
<p>根据主定理，我们可以在 $O(n \log n)$ 的时间内求出所要的 $A(x)$ 的点值表示</p>
<p>为了快速的进行 $IDFT$，对比 $DFT$ 与 $IDFT$ 的表达式，可以发现我们只需要将 $FFT$ 过程中用到的 $ω_n$ 全部替换为 $ω_n^{-1}$，最后再 乘以 $\frac 1n$ 即可。</p>
<p><img src="./FFT.png" alt=""></p>
<h2 id="位逆序置换"><a href="#位逆序置换" class="headerlink" title="位逆序置换"></a>位逆序置换</h2><p>可以观察到，令 $rev(x)$ 表示将 $x$ 的二进制位的顺序反转之后得到的数字，令 </p>
<script type="math/tex; mode=display">
a_i^\prime=a_{rev(i)}</script><p>则每次需要对 $a$ 进行的蝴蝶操作在 $a\prime$ 中变成了对两个相邻的序列的操作</p>
<p>把 $a$ 转化为 $a\prime$ 的过程常称为位逆序置换</p>
<h2 id="非递归的-FFT-实现"><a href="#非递归的-FFT-实现" class="headerlink" title="非递归的 $FFT$ 实现"></a>非递归的 $FFT$ 实现</h2><p>因此得到 $a\prime$ 后，我们首先对 $a\prime$ 的每一对相邻的长度为 $1$ 的子序 列做蝴蝶操作，然后对每一对相邻的长度为 $2$ 的子序列$\cdots\cdots$最 后对两个长度为 $\frac n2$ 的子序列做蝴蝶操作，我们就完成了对 $a$ 的 $FFT$</p>
<p>$DFT$ 与 $FFT$ 都是在 $\mathbb{C}$ 中进行的过程</p>
<p>在很多时候，我们往往是在对整数进行操作，并且经常要对某个素数 $p$ 取模</p>
<p>注意到单位根在 $DFT$ 中起了重要的作用，我们来考虑在模素数的时候是否存在和单位跟性质类似的元素</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>设 $p$ 是素数. 由费马小定理，我们知道对于任意 $a$ 满足 $p - a$， 有</p>
<script type="math/tex; mode=display">
a^{p-1}\equiv1\pmod p</script><p>$g$ 称为模 $p$ 的原根，当且仅当 $g_0 , g_1 ,\cdots, g_q(q=p−2)$ 在模 p 意义下互 不相同。 可以证明，模质数的原根总是存在的</p>
<p>原根的性质和本原单位根非常类似. 换句话说，在 $\mod p$ 意义 下，$g$ 可以被看做一个 $p − 1$ 次本原单位根</p>
<h2 id="数论变换"><a href="#数论变换" class="headerlink" title="数论变换"></a>数论变换</h2><p>设 $n$ 满足 $n | p − 1$. 令 $ωn = g^{\frac{p−1}n} $. 那么有</p>
<script type="math/tex; mode=display">
{\omega_n}^n=(g^{\frac{p-1}n})^n\equiv1\pmod p</script><p>并且 ${ω_n}^0 , {ω_n}^1 ,\cdots, {ω_n}^{n−1}$ 互不相同</p>
<p>于是 $ω_n$ 在 $\mod p$ 意义下具有 $n$ 次本原单位根的性质。我们 以利用它类似的定义 $DFT$. 这被称为数论变换$NTT$</p>
<h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><p>如果 $n = 2k$，则也可以利用与 $FFT$ 类似的方式快速的计算数论变换。 但是因为 $2^k = n | p − 1$，这意味着快速数论变换对所选取的素数模数有着特殊的要求</p>
<p>比如常见的模数</p>
<script type="math/tex; mode=display">
P_{UOJ}=998244353=7\times17\times2^{23}+1</script><h2 id="FFT-的基本应用"><a href="#FFT-的基本应用" class="headerlink" title="$FFT$ 的基本应用"></a>$FFT$ 的基本应用</h2><p>$FFT$ 计算的是 $DFT$，因此 $FFT$ 的直接应用主要与卷积有关</p>
<ul>
<li>直接计算卷积 </li>
<li>进行多项式相关运算 </li>
<li>卷积与字符串匹配</li>
</ul>
<h3 id="计算卷积"><a href="#计算卷积" class="headerlink" title="计算卷积"></a>计算卷积</h3><p>注意到利用 $FFT$，我们能直接进行的是长度为 $2^k$ 的循环卷积</p>
<p>如果要进行一般的卷积运算，注意到两个长度为 $n$ 的序列的卷积长度为 $2n − 1$，因此一般会选择 $k$ 使得 $2^k \ge 2n − 1$，然后对序列进行长度为 $2^k$ 的 $FFT$</p>
<p>如果要进行一般的长度的循环卷积，则使用普通卷积来模拟</p>
<blockquote>
<ul>
<li><p>利用 FFT 进行多项式乘法 </p>
<blockquote>
<p>多项式乘法就是系数进行卷积的过程，因此可以使用 FFT 计算</p>
</blockquote>
</li>
<li><p>利用 FFT 进行高精度乘法</p>
<blockquote>
<p>高精度乘法就是多项式乘法，只需处理进位即可</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="卷积与字符串匹配"><a href="#卷积与字符串匹配" class="headerlink" title="卷积与字符串匹配"></a>卷积与字符串匹配</h2><p>假设 $x, y$ 是两个用正整数表示的字符，那么 $x = y$ 当且仅当 $(x − y)^2 = 0$</p>
<p>若 $a = (ai) $与 $b = (bi)$ 是长度分别是 $n, m$ 的两个字符串，那么 $b$ 在 $a$ 的第 $k$ 个位置匹配当且仅当</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m(a_{i+k}-b_i)^2=\sum_{i=1}^m{a_{i+k}}^2+\sum_{i=1}^m{b_i}^2-2\sum_{i=1}^ma_{i+k}b_i=0</script><p>注意到其中前两项容易计算，而第三项可以化为卷积，因此可以使用 $FFT$ 计算</p>
<h2 id="含有通配符的字符串匹配"><a href="#含有通配符的字符串匹配" class="headerlink" title="含有通配符的字符串匹配"></a>含有通配符的字符串匹配</h2><p>如果 $b$ 中含有一种特殊的字符（通配符）可以与 $a$ 的任意字符匹配，如何求 $b$ 在 $a$ 中的匹配？ </p>
<p>不妨把通配符用 $0$ 表示，如果 $x$ 是普通字符，$y$ 可能是通配符， 那么 $x$ 与 $y$ 匹配当且仅当 $x = y$ 或 $y = 0$，也就是 $y(x − y)^2 = 0$</p>
<p>那么字符串的匹配就可以表达为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^mb_i(a_{i+k}-b_i)^2=\sum_{i=1}^m{a_{i+k}}^2b_i+\sum_{i=1}^m{b_i}^3-2\sum_{i=1}^ma_{i+k}{b_i}^2=0</script><p>类似的，这个转化后也可以利用 $FFT$ 计算</p>
<h1 id="多项式与形式幂级数"><a href="#多项式与形式幂级数" class="headerlink" title="多项式与形式幂级数"></a>多项式与形式幂级数</h1><h2 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h2><p>环 $R$ 上的形式幂级数形如</p>
<script type="math/tex; mode=display">
A(x)=\sum_{n\ge0}a_nx^n</script><p>其中 $a_n\in R$. x 称为这个形式幂级数的自由元</p>
<p>多项式是仅有有限项非零的形式幂级数</p>
<p>因此，形式幂级数可以 看成是对多项式的推广</p>
<p> 一般形式幂级数中的自由元不带入具体数值</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>形式幂级数的运算规则与多项式的运算规则是类似的 </p>
<p>同样多项式类似，形式幂级数的乘法对应两个无穷数列的卷积</p>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>可以看出，形式幂级数 $A(x)$ 自然的对应着一个无穷的数列 $a = (a_0, a_1, a_2, \cdots)$</p>
<p>因此 $A(x)$ 称为数列 $a$ 的生成函数</p>
<h2 id="模意义下的多项式"><a href="#模意义下的多项式" class="headerlink" title="模意义下的多项式"></a>模意义下的多项式</h2><p>设 $A(x), B(x), P(x)$ 是多项式。我们称 $A(x) ≡ B(x) \pmod {R(x)}$，如果存在多项式 $Q(x)$，使得</p>
<script type="math/tex; mode=display">
A(x)-B(x)=P(x)Q(x)</script><p>因此，多项式也可以在模意义下讨论</p>
<p>在实际运算中，我们时常只关心多项式（形式幂级数）的前有限 项，并且希望多项式（形式幂级数）在这种意义下参与运算</p>
<p>如 果只关心前 $n$ 项，我们采用记号 $\mod x^n$ 表示</p>
<h2 id="形式幂级数的逆元"><a href="#形式幂级数的逆元" class="headerlink" title="形式幂级数的逆元"></a>形式幂级数的逆元</h2><p>设 $A(x)$ 是形式幂级数。如果 $a_0\ne0$, 那么存在形式幂级数 $B(x)$，使得 $A(x)B(x) = 1$. 这时，称 $B(x)$ 是 $A(x)$ 的逆元，记 作 $B(x) = \frac1{A(x)}$</p>
<p>通过比较系数，我们可以得到:</p>
<script type="math/tex; mode=display">
\sum_{i=0}^ka_ib_{k-i}=[k=0]\Rightarrow
\begin{cases}
b_0=\frac 1{a_0}\\
b_n=-\frac 1{a_0}\sum\limits_{i=0}^{n-1}a_{n-i}b_i
\end{cases}</script><h2 id="形式幂级数的除法"><a href="#形式幂级数的除法" class="headerlink" title="形式幂级数的除法"></a>形式幂级数的除法</h2><p>通过定义逆元，我们可以定义除以一个形式幂级数为乘以其逆元</p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>定义斐波那契数列满足 $f(0) = f(1) = 1, f(n) = f(n−1) + f(n−2)$<br>求斐波那契数列的生成函数</p>
<p>可以发现我们有 $F(x) = (x + x^2 )F(x) + 1$. 因此答案是</p>
<script type="math/tex; mode=display">
F(x)=\frac 1{1-x-x^2}</script><h2 id="逆元的计算"><a href="#逆元的计算" class="headerlink" title="逆元的计算"></a>逆元的计算</h2><p>假设我们已经计算出了 $B_0(x) = B(x) \mod x^k$，那么我们有</p>
<script type="math/tex; mode=display">
A(x)B_0(x)\equiv1\pmod {x^k}</script><p>这意味着</p>
<script type="math/tex; mode=display">
(A(x)B_0(x)-1)^2\equiv0\pmod {x^{2k}}</script><p>那么我们有</p>
<script type="math/tex; mode=display">
B(x)\equiv B_0(x)(2-A(x)B_0(x))\pmod{x^{2k}}</script><p>由此可以计算出 $g(x)$ 的前 $2k$ 项</p>
<p>根据主定理，计算 $B(x) \mod x^n$ 的时间复杂度为 $O(n \log n)$</p>
<h2 id="导数与积分"><a href="#导数与积分" class="headerlink" title="导数与积分"></a>导数与积分</h2><p>设 $A(x) = \sum\limits_{n≥0}a_nx^n$ 是形式幂级数。定义 $A(x)$ 的（形式）导数为</p>
<script type="math/tex; mode=display">
A\prime(x)=\frac{\mathrm d}{\mathrm dx}A(x)=\sum_{n\ge1}na_nx^{n-1}</script><p>类似的，定义定义 $A(x)$ 的（形式）积分为</p>
<script type="math/tex; mode=display">
\int A(x)\mathrm x=\sum_{n\ge0}\frac1{n+1}a_nx^{n+1}</script><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>（自然）对数可以由下式定义：</p>
<script type="math/tex; mode=display">
\log(1 + x)=\sum_{n≥1}(−1)^{n−1}\frac{x^n}n</script><p>设 $A(x)$ 是形式幂级数。如果 $[x^0]A(x) = 1$, 则 $A(x)$ 的对数也可以类似定义：</p>
<script type="math/tex; mode=display">
\log A(x)=\sum_{n\ge1}(-1)^{n-1}\frac{(A(x)-1)^n}n</script><p>我们有</p>
<script type="math/tex; mode=display">
\frac{\mathrm d}{\mathrm dx}\log A(x)=\frac{A\prime(x)}{A(x)}</script><p>因此，</p>
<script type="math/tex; mode=display">
\log A(x)=\int\frac{A\prime(x)}{A(x)}\mathrm dx</script><h2 id="等幂和"><a href="#等幂和" class="headerlink" title="等幂和"></a>等幂和</h2><p>给出 $n$ 个数 $α<em>1, . . . , α_n$ 定义 $p_k = \sum\limits^n</em>{i=1} α_i^k$</p>
<p>对于 $1 \le k \le n$， 求 $p_k, n ≤ 10^5$</p>
<p>注意到 $\sum\limits_{k≥0} α_kx^k = \frac1 {1−αx}$因此</p>
<p><img src="./TD.png" alt=""></p>
<p><img src="./TD2.png" alt=""></p>
<h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><p><img src="./TD3.png" alt=""></p>
<p><img src="./TD4.png" alt=""></p>
<center> <a href="./基础多项式.pdf">附件下载 </center><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>复数入门</title>
    <url>/AlanTuringLi/2021/02/07/%E5%A4%8D%E6%95%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一-复数"><a href="#一-复数" class="headerlink" title="(一) 复数"></a>(一) 复数</h1><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一.定义"></a>一.定义</h2><p>若$i$符合方程$X^2+1=0$, 则$i$被称为虚数单位</p>
<p>复数$z=a+bi \left(a,b\in \mathbb{R}\right)$</p>
<p>$a$为实部, $b$为虚部, 记$:a=Re(z),b=Im(z)$</p>
<h2 id="二-分类"><a href="#二-分类" class="headerlink" title="二.分类"></a>二.分类</h2><p>当$b=0$时, 复数$z$为实数</p>
<p>当$b\ne0$时, 复数$z$为虚数</p>
<p>当$b\ne0$且$a=0$时, 复数$z$为纯虚数</p>
<script type="math/tex; mode=display">
\mathbb{R}实数集\qquad\mathbb{P}虚数集\qquad\mathbb{C}复数集\qquad\mathbb{Q}纯虚数集
\\
\mathbb{R}\cap\mathbb{P}=\varnothing \qquad\mathbb{R}\cup\mathbb{P}=\varnothing\qquad \mathbb{Q}\subsetneqq\mathbb{P}\subsetneqq\mathbb{C}</script><h2 id="三-法则"><a href="#三-法则" class="headerlink" title="三.法则"></a>三.法则</h2><p>若有复数$z_1=a+bi\;,z_2=c+di\left(a,b,c,d\in\mathbb{R}\right)$</p>
<p>加法$:z_1+z_2=(a+c)+(b+d)i$</p>
<p>减法$:z_1-z_2=(a-c)+(b-d)i$</p>
<p>乘法$:z_1\cdot z_2 = (ac-bd)+(bc+ad)i$</p>
<p>除法$:\frac{z_1}{z_2}=\frac{a+bi}{c+di}=\frac{(a+bi)(c-di)}{(c+di)(c-di)}=\frac{ac+bd}{c^2+d^2}+\frac{(bc-ad)i}{c^2+d^2}$</p>
<h2 id="四-定律"><a href="#四-定律" class="headerlink" title="四.定律"></a>四.定律</h2><p>复数运算满足加法交换律,加法结合律,乘法交换律,乘法结合律,乘法分配律</p>
<h2 id="五-共轭"><a href="#五-共轭" class="headerlink" title="五.共轭"></a>五.共轭</h2><p>当两个复数的实部相等, 虚部互为相反数时, 称这两个复数为共轭复数</p>
<p><strong>特别的</strong>, 若虚部不为零时, 也称作互为共轭虚数</p>
<p>对于复数$z=a+bi(a,b\in\mathbb{R})$, 共轭复数用$\overline{z}=a-bi(a,b\in\mathbb{R})$表示</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质:"></a>性质:</h3><script type="math/tex; mode=display">
\begin{align*}
&(1)\overline{z_1\pm z_2}=\overline{z_1}\pm\overline{z_2}\\
&(2)\overline{z_1z_2}=\overline{z_1}\overline{z_2}\\
&(3)\overline{\frac{z_1}{z_2}}=\frac{\overline{z_1}}{\overline{z_2}}\\
&(4)\overline{z^n}=\overline{z}^n\\
&(5)z+\overline{z}=2Re(z),\;z-\overline{z}=2iIm(z)\\
&(6)\overline{\overline{z}} = z\\
&(7)z=\overline{z}\Leftrightarrow z\in\mathbb{R}\quad -z=\overline{z}且z\ne0\Leftrightarrow z\in\mathbb{Q}
\end{align*}</script><h2 id="六-几何"><a href="#六-几何" class="headerlink" title="六.几何"></a>六.几何</h2><p>$z=a+bi(a,b\in\mathbb{R})$与复平面上的点$Z(a,b)$是一一对应的。点$Z(a,b)$与向量$\vec{OZ}$也成一一对应关系，点 $Z$与$\vec{OZ}$均为复数$z=a+bi(a,b\in\mathbb{R})$的几何形式</p>
<p>向量$\vec{OZ}$的模称为复数$Z$的模$\left\vert z \right\vert$，即</p>
<script type="math/tex; mode=display">
r=\left\vert z\right\vert=\sqrt{a^2+b^2}</script><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><script type="math/tex; mode=display">
\begin{align*}
&(1)z\overline{z}=\left\vert z\right\vert^2=\left\vert \overline{z}\right\vert^2\\
&(2)\left\vert\left\vert z_1\right\vert-\left\vert z_2\right\vert\right\vert\leqslant\left\vert z_1\pm z_2\right\vert\leqslant\left\vert z_1\right\vert+\left\vert z_2\right\vert\\
&(3)\max(\left\vert Re(z)\right\vert,\left\vert Im(z)\right\vert)\geqslant\left\vert z\right\vert\geqslant\left\vert Re(z)\right\vert+\left\vert Im(z)\right\vert
\end{align*}</script><h2 id="七-表示形式"><a href="#七-表示形式" class="headerlink" title="七.表示形式"></a>七.表示形式</h2><ul>
<li>代数形式：$z=a+bi$，其中 $a,b\in \mathbb R$</li>
<li>几何形式：$z=a+bi\Rightarrow z(a,b)$，可以看由原点发出的向量 $\vec{OZ}$</li>
<li>三角形式：$z=r(\cos\theta+i\sin\theta)$，其中 $r\ge0,\theta\in \mathbb R$</li>
<li>指数形式：$z=re^{i\theta}$，其中 $r\ge0,\theta\in \mathbb R$<ul>
<li>有欧拉公式：$e^{i\theta}=\cos\theta+i\sin\theta$</li>
</ul>
</li>
</ul>
<h1 id="二-复数的模与辐角"><a href="#二-复数的模与辐角" class="headerlink" title="(二) 复数的模与辐角"></a>(二) 复数的模与辐角</h1><p>设复数$z=a+bi(a,b\in\mathbb{R})$ 所对应的向量为$\vec{OZ}$，我们称始边是$x$轴正半轴，终边是$\vec{OZ}$的角称为复数$z$的辐角，记作：$Arg\;z$</p>
<p>在 $[0,2\pi)$的辐角叫做复数$z$的辐角主值，记作：$\arg{z}$</p>
<p>且有：</p>
<script type="math/tex; mode=display">
Arg\;z=\arg{z}+2k\pi(k\in\mathbb{Z})</script><p>当$z\in\mathbb{R}^*$时，有：</p>
<script type="math/tex; mode=display">
\arg{a}=0,\arg(-a)=\pi\\
\arg(ai)=\frac{\pi}{2},\arg(-ai)=\frac{3\pi}{2}\\
注意：\text{0的辐角时任意的}</script><p>结论：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)Arg\;(z_1z_2)=Arg(z_1)+Arg(z_2)\\
&(2)Arh(\frac{z_1}{z_2})=Arg(z_1)-Arg(z_2)\\
&(3)Arg(z^n)=nArg(z)
\end{align*}</script><p>若复数$z=a+bi(a,b\in\mathbb{R}且ab\ne0)$，则有：</p>
<script type="math/tex; mode=display">
\arg{z}=\begin{cases}
            \arctan(\frac{b}{a}) \text{，点$(a,b)$在第一象限}\\
            \pi+\arctan(\frac{b}{a}) \text{，点$(a,b)$在第二、三象限}\\
            2\pi+\arctan(\frac{b}{a}) \text{，点$(a,b)$在第四象限}\\
            \end{cases}</script><p>设复数$z=a+bi(a,b\in\mathbb{R})$的模等于$r$，辐角为$\theta$</p>
<p>那么称$z=r(\cos{\theta}+i\sin{\theta})$为复数$z=a+bi(a,b\in\mathbb{R})$的三角式</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="一-平方与开方"><a href="#一-平方与开方" class="headerlink" title="一.平方与开方"></a>一.平方与开方</h3><p>若$z_1=r_1(\cos{\theta_1}+i\sin{\theta_1}),z_2=r_2(\cos{\theta_2}+i\sin{\theta_2})$，则：</p>
<script type="math/tex; mode=display">
\begin{align*}
z_1\cdot z_2&=r_1(\cos{\theta_1}+i\sin{\theta_1})\cdot r_2(\cos{\theta_2}+i\sin{\theta_2})\\
&=r_1r_2[\cos(\theta_1+\theta_2)+isin(\theta_1+\theta_2)]
\end{align*}\\
即: 积的模为模的积，积的辐角为辐角的和</script><p>复数的$n$次幂的模等于这个复数模的$n$次幂，它的辐角等于这个复数的辐角的$n$倍(棣莫佛定理)，即：</p>
<script type="math/tex; mode=display">
z^n=r^n(\cos(n\theta)+i\sin(n\theta))</script><h3 id="二-除法"><a href="#二-除法" class="headerlink" title="二.除法"></a>二.除法</h3><p>若$z_1=r_1(\cos{\theta_1}+i\sin{\theta_1}),z_2=r_2(\cos{\theta_2}+i\sin{\theta_2})$，则：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{z_1}{z_2}&=\frac{r_1(\cos{\theta_1}+i\sin{\theta_1})}{r_2(\cos{\theta_2}+i\sin{\theta_2})}\\
&=\frac{r_1}{r_2}[\cos(\theta_1-\theta_2)+i\sin(\theta_1-\theta_2)]
\end{align*}\\
即: 商的模为模的商，商的辐角为辐角的被除数减去除数的辐角</script><h3 id="三-开方"><a href="#三-开方" class="headerlink" title="三.开方"></a>三.开方</h3><p>复数$z=r(\cos\theta+i\sin\theta)$的$n(n\in\mathbb{N}^*)$次方根为：</p>
<script type="math/tex; mode=display">
\sqrt[n]z=\sqrt[n]r(\cos(\frac{\theta+2k\pi}{n})+i\sin(\frac{\theta+2k\pi}{n}))(k\in[0,n-1]\&k\in\mathbb{N})</script><p>复数的$n$次方根为$n$个复数，模均为这个复数的模的$n$次算数平方根，辐角分等于这个数的辐角与$2\pi$的$0,1,2\cdots n-1$倍的和的$n$分之一</p>
<h3 id="四-三角函数"><a href="#四-三角函数" class="headerlink" title="四.三角函数"></a>四.三角函数</h3><p>复数$z=\cos\theta+i\sin\theta=e^{i\theta}$，则：</p>
<script type="math/tex; mode=display">
\cos(n\theta)=Re(z^n)=\frac{z^{2n}+1}{2z^n}\\
\sin(n\theta)=Im(z^n)=\frac{z^{2n}-1}{2z^ni}\\
\tan(n\theta)=\frac{Im(z^n)}{Re(z^n)}=\frac{z^{2n}-1}{(z^{2n}+1)i}</script><h1 id="三-复数与方程"><a href="#三-复数与方程" class="headerlink" title="(三) 复数与方程"></a>(三) 复数与方程</h1><h2 id="一-实际方程-ax-2-bx-c-0-a-ne0-在复数集-mathbb-C-中有两个根"><a href="#一-实际方程-ax-2-bx-c-0-a-ne0-在复数集-mathbb-C-中有两个根" class="headerlink" title="一.实际方程$ax^2+bx+c=0(a\ne0)$在复数集$\mathbb{C}$中有两个根"></a>一.实际方程$ax^2+bx+c=0(a\ne0)$在复数集$\mathbb{C}$中有两个根</h2><script type="math/tex; mode=display">
x=\frac{-b\pm i\sqrt{-\Delta}}{2a}(\Delta<0)</script><h2 id="二-复平面上的曲线方程"><a href="#二-复平面上的曲线方程" class="headerlink" title="二.复平面上的曲线方程"></a>二.复平面上的曲线方程</h2><p>若复数$z$对应着复平面上的一个点$Z(x,y)$，就可以得出一些常用曲线的复数形式的方程：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)方程\left\vert z-z_0\right\vert=r，表示以z_0为圆心，r为半径的圆\\
&(2)方程\left\vert z-z_1\right\vert=\left\vert z-z_2\right\vert，表示线段z_1z_2的垂直平分线\\
&(3)方程\left\vert z-z_1\right\vert+\left\vert z-z_2\right\vert=2a(a>0,2a>\left\vert Z_1Z_2\right\vert)，表示以Z_1Z_2为焦点，a为长半轴的椭圆\\
&\qquad若2a=\left\vert Z_1Z_2\right\vert，则此方程表示以Z_1Z_2为断点的线段\\
&(4)方程\left\vert \left\vert z-z_1\right\vert-\left\vert z-z_2\right\vert\right\vert=2a(0<2a<\left\vert Z_1Z_2\right\vert)表示以Z_1Z_2为焦点，实轴长为2a的椭圆
\end{align*}</script><h1 id="四-单位根"><a href="#四-单位根" class="headerlink" title="(四)单位根"></a>(四)单位根</h1><p>对于方程$x^n-1=0(n\in\mathbb{N}^*,n\geqslant2)$</p>
<p>由复数开方法则，就可以得到它的$n$个根</p>
<script type="math/tex; mode=display">
\epsilon_k=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}\qquad(k\in[0, n-1])</script><p>他们显然是1的$n$次方根，称为$n$次单位根</p>
<p>利用复数乘方公式，有：</p>
<script type="math/tex; mode=display">
\epsilon_k=(\cos\frac{2\pi}{n}+\sin\frac{2\pi}{n})^k=\epsilon_1^k</script><p>这说明，$n$个$n$次单位根可以表示为：</p>
<script type="math/tex; mode=display">
1,\epsilon_1,\epsilon_1^2,\epsilon_1^3,\cdots\epsilon_1^{n-1}</script><p>关于$n$次单为根，性质如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)\left\vert\epsilon_k\right\vert=1\quad (k\in\mathbb{N})\\
&(2)\epsilon_j\epsilon_k=\epsilon_{j+k}\quad (j,k\in\mathbb{N})\\
&(3)\sum\limits_{i=0}^{n-1}\epsilon_1^i=0\quad (n\geqslant2)\\
&设m为整数，则：\\
&\sum\limits_{i=0}^{n-1}\epsilon_i^m=\begin{cases}n，当m时n的倍数\\
0，当m不是n的倍数\end{cases}
\end{align*}</script><h1 id="五-复数与向量的应用"><a href="#五-复数与向量的应用" class="headerlink" title="(五) 复数与向量的应用"></a>(五) 复数与向量的应用</h1><ul>
<li><strong>设复平面上两点$Z_1Z_2$对应的复数分别是$z_1,z_2$，那么两点的距离满足：</strong></li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
\left\vert Z_1Z_2\right\vert^2&=\left\vert z_1-z_2\right\vert^2\\
&=(z_1-z_2)(\overline{z_1}-\overline{z_2})\\
&=\left\vert z_1\right\vert^2+|z_2|^2-(z_1\overline{z_1}+z_2\overline{z_2})
\end{align*}</script><ul>
<li><strong>二.设复平面上两点$Z_1,Z_2$应的复数分别是$z_1,z_2$，那么线段$Z_1Z_2$定比分点$Z$对应的复数可以表示为</strong><script type="math/tex; mode=display">
z=\frac{z_1+\lambda z_2}{1+\lambda}</script></li>
</ul>
<ul>
<li><strong>三.设复平面上三个点$Z_1,Z_2,Z_3$应的复数分别是$z_1,z_2,z_3$，这三点共线的充要条件是存在不全为零的实数$\lambda_1\lambda_2\lambda_3$,使如下两式同时成立:</strong></li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
\lambda_1+\lambda_2+\lambda_3=0\\
\lambda_1z_1+\lambda_2z_2+\lambda_3z_3=0
\end{cases}</script><ul>
<li><strong>四.设不共线的四点$A,B,C,D$对应的复数分别为$z_1,z_2,z_3,z_4$,则四点共圆的充要条件是:</strong></li>
</ul>
<script type="math/tex; mode=display">
\frac{z_3-z_1}{z_4-z_1}=\frac{z_3-z_2}{z_4-z_2}=\lambda(\lambda\in\mathbb{R}且\lambda\ne0)</script><ul>
<li><strong>五.设不共线的三点$A,B,C$对应的复数$z_1,z_2,z_3$,则$\Delta ABC$的面积公式为:</strong></li>
</ul>
<script type="math/tex; mode=display">
S_{\Delta ABC}=\frac{i}{4}\cdot
\begin{vmatrix}
1&1&1\\
z_1&z_2&z_3\\
\overline{z_1}&\overline{z_2}&\overline{z_3}
\end{vmatrix}</script><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大素数</title>
    <url>/AlanTuringLi/2020/10/17/%E5%A4%A7%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="记号声明"><a href="#记号声明" class="headerlink" title="记号声明"></a>记号声明</h1><p>首先，声明几个记号：</p>
<ul>
<li>$p_i$ 表示第 $i$ 个素数</li>
<li>$\pi(x)$ 表示 $[1,x]$ 范围内的素数个数</li>
<li>$\Phi(m,n)$ 表示不大于 $m$ 且不能整除任何一个 $p_i\quad i\in[1,n]$ 的自然数个数</li>
</ul>
<h1 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h1><p>那么显然有：</p>
<ul>
<li><script type="math/tex; mode=display">
  \Phi(m,n)=\Phi(m-n-1)-\Phi(\frac m{p_i}, n-1)</script></li>
<li><script type="math/tex; mode=display">
  \Phi(m,0)=\left\lfloor m\right\rfloor</script></li>
</ul>
<p>给定一个自然数 $m$，如果 $n=\pi(\sqrt[3]{m})\quad\mu=\pi(\sqrt m)-n$，那么有：</p>
<script type="math/tex; mode=display">
\pi(m)=\Phi(m,n)+n(\mu+1)+\frac{\mu^2-\mu}2-1-\sum_{k=1}^\mu\pi\left(\frac m{p_{n+k}}\right)</script><p>这个方法大概可以计算 $1e8$ 数量级的素数个数<br>但是有一种更快的处理方式，对于实数 $m$，和自然数 $n$ 和 $k$, 定义 $P_k(m,n)$ 表示不大于 $m$，且恰好有 $k$ 个大于 $p_n$ 的<strong>素因子</strong>的整数个数，更进一步，设定： $P_0(m,n)=1$，那么有：</p>
<script type="math/tex; mode=display">
\Phi(m,n)=\sum_{k\ge0}P_k(m,n)</script><p>这个和 实际上只有有限个非零的项。设 $y$ 为一个整数，使得 $\sqrt[3]m\le y\le\sqrt m$，并设 $n=\pi(y)$。那么当 $k \ge 3$ 时， $P_1(m,n)=\pi(m)-n$ 且 $P_k(m,n)=0$。因此有：</p>
<script type="math/tex; mode=display">
\pi(m)=\Phi(m,n)+n-1-P_2(m,n)</script><p>$P_2(m,n)$ 的计算方式可以用这种方法来获得：</p>
<script type="math/tex; mode=display">
P_2(m,n)=\sum_{y<p\le \sqrt m}\left(\pi\left(\frac mp\right)-\pi(p)+1\right)</script><p>这样，我们就可以在 $O(n^{\frac 23})$ 的时间复杂度内完成 $1\sim n$ 的素数个数的计算</p>
<h1 id="例题LOJ6235"><a href="#例题LOJ6235" class="headerlink" title="例题LOJ6235"></a>例题<a href="https://loj.ac/problem/6235">LOJ6235</a></h1><p>板子题。。。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxp = maxn * <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> prime</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> phi[maxn][maxm];</span><br><span class="line">    <span class="type">int</span> p[maxn], pi[maxn * <span class="number">10</span>], cnt;</span><br><span class="line">    <span class="type">bool</span> vis[maxn * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn * <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++cnt] = i;</span><br><span class="line">            pi[i] = cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn * <span class="number">10</span>; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; maxm; ++n)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; maxn; ++m)</span><br><span class="line">                <span class="keyword">if</span> (!n) phi[m][n] = m;</span><br><span class="line">                <span class="keyword">else</span> phi[m][n] = phi[m][n - <span class="number">1</span>] - phi[m / p[n]][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">Phi</span><span class="params">(ll m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[n] &gt;= m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; maxn &amp;&amp; n &lt; maxm) <span class="keyword">return</span> phi[m][n];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Phi</span>(m, n - <span class="number">1</span>) - <span class="built_in">Phi</span>(m / p[n], n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">Pi</span><span class="params">(ll m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; maxn) <span class="keyword">return</span> pi[m];</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">sqrt</span>(m + <span class="number">0.9</span>), y = <span class="built_in">cbrt</span>(m + <span class="number">0.9</span>), n = pi[y];</span><br><span class="line">        ll res = <span class="built_in">Phi</span>(m, n) + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; p[i] &lt;= s; ++i) res -= <span class="built_in">Pi</span>(m / p[i]) - <span class="built_in">Pi</span>(p[i]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prime::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n))</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, prime::<span class="built_in">Pi</span>(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解递归</title>
    <url>/AlanTuringLi/2022/11/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数在一任何语言里，都起着无比重要的作用。但是对初学者来说，计算机的函数可能会比较抽象，那么就先来看看数学里的函数。</p>
<p>数学里的函数可以简单的看作一个数集通过一定法则到另一个数集的映射。</p>
<p>那么，在计算机中，带有返回值的函数也可以同样理解。只不过计算机的函数的功能远远大于数学中函数的，除了得到值于值之间的关系，你可以在一个函数中写出你想拥有的任何功能 （<del>只要你会写</del>）。</p>
<p>而无返回值的函数就由此诞生了，它不需要值于值之间的对应关系，或者这个对应关系可以通过指针参数来完成导致它不需要返回值。</p>
<p>例如，在数学中，我们可以定义如下函数：</p>
<script type="math/tex; mode=display">
f(x)=\frac{sinx}{x}</script><p>同样的，在 $C$ 语言中，我们可以通过构造一个函数实现相同的功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sin</span>(x) / x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，在 $C$ 语言中，你可以定义很多带有多个自变量（参数）、或者更为抽象的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_num</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x % <span class="number">10</span> == t) ++count;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;<span class="comment">//统计数字x中，各位数字t出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> x[], <span class="type">bool</span> cmp(<span class="type">int</span>, <span class="type">int</span>))</span></span>;<span class="comment">//排序函数，就不细写了</span></span><br></pre></td></tr></table></figure>
<p>至此，你可以认为，在计算机中，函数的概念是包括了数学的函数，也远大于数学的函数的。</p>
<h1 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h1><p>在理解指针之前，先不考虑函数做参数的情况。</p>
<p>同样的，这个部分也可以和数学类比：</p>
<script type="math/tex; mode=display">
f(x) = g(x) + h(x) + \varphi(x)</script><p>那么在程序里，也可以有同样的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">g</span>(x) + <span class="built_in">h</span>(x) + <span class="built_in">phi</span>(x);</span><br><span class="line">&#125;<span class="comment">//都是有返回值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">g</span>(x);</span><br><span class="line">    <span class="built_in">h</span>(x);</span><br><span class="line">    <span class="built_in">phi</span>(x);</span><br><span class="line">&#125;<span class="comment">//也有可能表示的是一种没有返回值的功能</span></span><br></pre></td></tr></table></figure>
<h2 id="特例：递归"><a href="#特例：递归" class="headerlink" title="特例：递归"></a>特例：递归</h2><p>其实递归与函数的调用是没有本质的区别的，无非就是调用的自己。</p>
<p>数学里也有类似的例子，例如：</p>
<script type="math/tex; mode=display">
已知f(1) = 1,\;f(x) =kf(n/k), \quad 求f(k)</script><p>可以看见，这里也有对自己的调用。</p>
<p>那么这个问题用程序怎么解决？（<del>虽然肉眼能看出来，但是写写递归有助于理解</del>）</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> x * <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>那么在来一个抽象一点的。</p>
<p>你站在第零级台阶（地面上），在你的面前有 $n$ 级台阶，每次你可以跨一级或者两级台阶，问你有多少种方案可以到达第 $n$ 级台阶？</p>
<blockquote>
<p>提示：用 $f(x)$ 表示走到第 $x$ 级台阶的方案数 </p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x - <span class="number">1</span>) + <span class="built_in">f</span>(x - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何理解？</p>
<p>已知 $f(x)$ 表示的是走到第 $x$ 级台阶的方案数，那么 $f(x)$ 可以怎么表示呢？</p>
<p>反过来想，上一步可能在那里？</p>
<p>从 $x - 1$ 跨一步到 $x$，从 $x - 2$ 跨两步到 $x$。</p>
<p>那么就可以得到 $f(x) = f(x - 1) + f(x - 2)$</p>
<p>这就是斐波那契数列的一个实现方式——递归</p>
</blockquote>

    </div>
</div>
<h3 id="例题-数的计算"><a href="#例题-数的计算" class="headerlink" title="例题  数的计算"></a>例题 <a href="https://www.luogu.com.cn/problem/P1028"> 数的计算</a></h3><p>这个题略有一些抽象，因为你可能不知道怎么用函数去表达这个答案。</p>
<p>那么请你再仔细读一次题，去找到一个和题目有相似之处的子问题。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        想法
    </div>
    <div class='spoiler-content'>
        <p>想知道以 $x$ 开头的方案数，就是求所有小于等于以 $\frac x2$ 开头的数的方案之和。</p>
<p>由此可以写出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//细节处理，加零可看作就是x本身不往后添加任何数字</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; ++i)</span><br><span class="line">        ans += <span class="built_in">f</span>(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//细节处理，加零可看作就是x本身不往后添加任何数字</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; ++i)</span><br><span class="line">        ans += <span class="built_in">f</span>(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>当然，你也可以发现一个问题，就是这样写你拿不到满分。</p>
<p>为什么呢，当 $n$ 足够大时，你会发现有很多数其实是被重复计算过了的，那么只需要用一个数组保存一下这个答案，当再次调用它时，可以直接返回这个答案。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CODE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count[<span class="number">1005</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count[x]) <span class="keyword">return</span> count[x];<span class="comment">//已经知道答案的，就不需要再次计算了</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; ++i)</span><br><span class="line">        ans += <span class="built_in">f</span>(i);</span><br><span class="line">    <span class="keyword">return</span> count[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>还有一个八皇后，就暂时不急了，有空了再更新一下博客吧~</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>子段和</title>
    <url>/AlanTuringLi/2022/10/10/%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/AlanTuringLi/2020/11/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h1><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a><a href="https://www.luogu.com.cn/problem/P3805">Manacher</a></h2><p>就是处理回文串的一个玩意，时间复杂度空间复杂度均为 $O(n)$，挺有用的一种工具吧。</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>由于串的长度有奇数也有偶数就很烦，为了方便讨论，就会往字符串里插入一些字符变得规整一点。</p>
<p>如：${abcba}\rightarrow$，${abccba}\rightarrow$</p>
<p>然后就把串强制变成了一个长度为奇数的串，所以转移的话就很方便，不需要考虑回文串的奇偶性。</p>
<h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>计 $p_i$ 表示以字符 $i$ 为回文中心的回文半径，然后就会发现一件很有趣的事情：现在的回文半径刚好就是原串的回文长度 $+1$。</p>
<p>那么现在这里提出一个十分暴力的做法，非常的显然：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (str[i + p[i]] == str[i - p[i]]) ++p[i];</span><br></pre></td></tr></table></figure>
<p>如果直接整样跑的话，它显然是一个 $O(n^2)$  的暴力。</p>
<p>所以考虑用已知状态转移过来，就是让每个点被扫过的次数为一个常数，来降低暴力的复杂度。</p>
<p>就是说，如果这个点在某个点的回文半径范围内，那么有些信息他是可以直接用的。</p>
<p>令 $mx$，为上一个回文中心的右端点，$id$ 为上一个回文中心，有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mx &gt; i) p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], p[id] - (i - id));</span><br><span class="line"><span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个 <code>p[2 * id - i]</code> 表示的 $i$ 关于 $id$ 对称的那个点的回文半径，<code>p[id] - (i - id)</code> 则是这个点到当前中心的右边界的距离，取 $\min$ 就是当前点的最小可行回文半径，正确性可以画图感性理解一下。</p>
<p>所以其实马拉车就结束了。。。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p[maxn], ans;</span><br><span class="line"><span class="type">char</span> s[maxn], str[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>, str[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) str[(i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>] = s[i], str[(i &lt;&lt; <span class="number">1</span>) + <span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    n = (n &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>, str[n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manachar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mx</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">id</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], p[id] - (i - id));</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; str[i + p[i]] == str[i - p[i]]; ++p[i]);</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; mx) mx = p[i] + i, id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">manachar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = <span class="built_in">max</span>(ans, p[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文自动机-text-PAM"><a href="#回文自动机-text-PAM" class="headerlink" title="回文自动机($\text{PAM}$)"></a><a href="https://www.luogu.com.cn/problem/P5496">回文自动机($\text{PAM}$)</a></h2><p>也是处理回文串的一个玩意儿，时间复杂度是 $O(n)$ 的，空间常数略大。 </p>
<p><img src="https://s1.ax1x.com/2020/11/05/B2m6cn.png" alt=""></p>
<p>（图片来源：<a href="https://oi-wiki.org/string/pam/">oi-wiki</a>）</p>
<p>大概就长成这个样子，和 $\text{Trie}$ 树类似的建图，然后通过构造失配指针来访问节点信息。</p>
<h3 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理"></a>预处理</h3><p>同样的，这个还是会出现回文串的长度为奇数和偶数的问题，所以就会出现两个根，分别表示奇根和偶根。</p>
<p>关于这个回文树，需要注意：</p>
<ul>
<li>偶根的失配指针是奇根</li>
<li>奇根的长度默认为 $-1$</li>
</ul>
<h3 id="转移-1"><a href="#转移-1" class="headerlink" title="转移"></a>转移</h3><p>找到了失配点，那么长度就可以直接 $+2$ 了。</p>
<p>所以可以有如下构造失配指针的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetFail</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (S[N - Len[X] - <span class="number">1</span>] !=  S[N]) X = Fail[X];</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> S[Maxn];</span><br><span class="line"><span class="type">int</span> X, P, Q, <span class="built_in">Tot</span>(<span class="number">1</span>), Last, Lsa, Ans[Maxn];</span><br><span class="line"><span class="type">int</span> Ch[Maxn][<span class="number">30</span>], Len[Maxn], Fail[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Newnode</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Len[++Tot] = X;</span><br><span class="line">    <span class="keyword">return</span> Tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetFail</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (S[N - Len[X] - <span class="number">1</span>] !=  S[N]) X = Fail[X];</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, S + <span class="number">1</span>);</span><br><span class="line">    Fail[<span class="number">0</span>] = <span class="number">1</span>, Len[<span class="number">1</span>] = S[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; S[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) S[i] = (S[i] - <span class="number">97</span> + Lsa) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        X = S[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        P = <span class="built_in">GetFail</span>(Last, i);</span><br><span class="line">        <span class="keyword">if</span> (!Ch[P][X])</span><br><span class="line">        &#123;</span><br><span class="line">            Q = <span class="built_in">Newnode</span>(Len[P] + <span class="number">2</span>);</span><br><span class="line">            Fail[Q] = Ch[<span class="built_in">GetFail</span>(Fail[P], i)][X];</span><br><span class="line">            Ans[Q] = Ans[Fail[Q]] + <span class="number">1</span>;</span><br><span class="line">            Ch[P][X] = Q;</span><br><span class="line">        &#125;</span><br><span class="line">        Last = Ch[P][X];</span><br><span class="line">        Lsa = Ans[Last];</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, Lsa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/AlanTuringLi/2020/09/23/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://www.luogu.com.cn/problem/P4318">完全平方数</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>就是请你求第$n$无平方因字数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有感觉的同学会发现，这个似乎和$\mu$有关</p>
<p>此话怎讲？</p>
<p>先考虑$\mu$的定义</p>
<script type="math/tex; mode=display">
\mu(x)=
\begin{cases}
1\quad\qquad\text{x = 1}\\
0\quad\qquad\text{x为某个不为1的完全平方数的倍数}\\
(-1)^k\quad\text{x为无平方因子数}\land x=p_1p_2\cdots p_k
\end{cases}</script><p>那么显然可以得到，无平方因子数的个数可以有如下表示</p>
<script type="math/tex; mode=display">
count=\sum_{i=1}^n\mu^2(i)</script><p>即所有无平方因字数的贡献都为$1$，而其他数没有贡献</p>
<p>那么从这里开始就可以有两种做法了</p>
<h2 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h2><p>就是说，要从简单的入手</p>
<p>用$n$去减掉带有平方因子数的个数</p>
<p>那么就可以来枚举一下每个完全平方数对答案的贡献</p>
<p>那么，现在有$p_1,p_2\cdots p_k$这些素数</p>
<p>$p_i^2$的贡献就有$\left\lfloor\frac n{p_i^2}\right\rfloor$</p>
<p>但是例如$p_1^2p_2^2$这个数它其实是被计算了两次的</p>
<p>多枚举几个数以后，会发现由偶数个素数构成的数会被重复计算，那么重复的部分是需要减去的</p>
<p><img src="https://s1.ax1x.com/2020/09/23/wxldOJ.png" alt=""></p>
<p>如图，红绿蓝三个交集再三个大圆中被重复计算了，中间那个像勒洛三角形的部分再减去原交集的时候同时也被剪掉了，所以又要加上它的贡献</p>
<p>那么回到这道题，就是说，一个数由$k$个因子构成，那么他的贡献可以表示为<code>(k &amp; 1) ? -1 : 1</code></p>
<p>那么这不就变回了莫比乌斯函数了吗？</p>
<p>所以可以得到：</p>
<script type="math/tex; mode=display">
ans=n-\sum_{i=2}^\sqrt n\mu(i)\left\lfloor\frac n{i^2}\right\rfloor</script><p>就可以直接写了</p>
<p>用二分查找这个应该就不用说了吧</p>
<h3 id="Code-100"><a href="#Code-100" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="type">int</span> T, A, B;</span><br><span class="line"><span class="type">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="type">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, r; i * i &lt;= x; ++i)</span><br><span class="line">		ans += mu[i] * (x / i / i);</span><br><span class="line">	<span class="keyword">return</span> ans &gt;= A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">l</span><span class="params">(X)</span>, <span class="title">r</span><span class="params">(X &lt;&lt; <span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(Mid)) ans = Mid, r = Mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">Find</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时间复杂度是$O(5e4+T\log n)$</p>
<p>理论上乱写都是可以过的</p>
<p>但是还是可以在稍稍优化一下</p>
<p>那么就要考虑对这个求和进行类整数分块</p>
<p>可以证明$\left\lfloor\frac n{i^2}\right\rfloor$在$i\in[1,\sqrt n]$的取值是连续的</p>
<p>那么加上这样一个分块，这道题就可以过了</p>
<h3 id="Code-100-1"><a href="#Code-100-1" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="type">int</span> T, A, B;</span><br><span class="line"><span class="type">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="type">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">ans</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>, r; l * l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">		r = <span class="built_in">min</span>(<span class="built_in">sqrt</span>(x / (x / l / l)), <span class="built_in">sqrt</span>(x));</span><br><span class="line">		ans += (mu[r] - mu[l - <span class="number">1</span>]) * (x / l / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans &gt;= A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">l</span><span class="params">(X)</span>, <span class="title">r</span><span class="params">(X &lt;&lt; <span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(Mid)) ans = Mid, r = Mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">Find</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>其实我们发现$\mu^2(i)$也是一个不完全积性函数</p>
<p>那么就是可以考虑使用杜教筛的</p>
<p>杜教筛就不细说了，需要了解杜教筛的可以看我的<a href="https://alansblog.ink/2020/08/19/杜教筛/">这篇博客</a></p>
<p>考虑构造函数$g(x)$</p>
<p>使得$\mu^2*g$能够方便的表示</p>
<p>能够方便表示的函数可以想到有：$\epsilon,1,id$</p>
<p>那么显然$\epsilon,id$是不好的得到的</p>
<p>那就考虑$\mu^2*g=1$的$g$的构造（其实可以直接$\text{Min_25筛}$，不需要怎么构造别的函数）</p>
<p>那么就是说要让：</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu^2(d)g(\frac nd)=1</script><p>考虑$\mu^2(d)$有贡献时，当且仅到$d$为无平方因子数，此时要让$g(\frac nd)$也有贡献，整体贡献才可能为$1$</p>
<p>那么感觉一下，$g(\frac nd)$大概是一个与完全平方数有关的函数</p>
<p>那么定义$g(x)=[x==\left\lfloor\sqrt x\right\rfloor^2]$，即 $x$是否是完全平方数</p>
<p>那么对于$\mu^2*g=1$就是成立的了，简单证明一下：</p>
<blockquote>
<p>要让$\mu^2(d)g(\frac nd)=1$当且仅当$d$为无平方因字数且$\frac nd$为完全平方数时才有贡献</p>
<p>那么分两种情况考虑：</p>
<blockquote>
<p>$d$为无平方因子数：那么显然当$\frac nd$不为$1$时$g(\frac nd)$的函数值都为$0$，那么只有$d=n$时，$f(n)g(1)=1$</p>
<p>$d$不为无平方因子数：就是只有当$\frac nd$为$n$的最大平方因子时，$d$才是无平方因子数，$\frac nd$也是完全平方数，此时才有$1$的贡献</p>
</blockquote>
</blockquote>
<p>所以证明了这个构造是没有问题的</p>
<p>接下来，就是杜教筛的套路：</p>
<script type="math/tex; mode=display">
\begin{align*}
g(1)S(n)&=\sum_{i=1}^n(\mu^2*g)(i)-\sum_{i=2}^ng(i)S(\left\lfloor\frac ni\right\rfloor)\\
g(1)S(n)&=n-\sum_{i=2}^ng(i)S(\left\lfloor\frac ni\right\rfloor)\\
\end{align*}</script><p>考虑到$g$函数的性质，会发现只有当$i$为完全平方数时，才有贡献</p>
<p>那么这个又可以写成：</p>
<script type="math/tex; mode=display">
S(n)=n-\sum_{i=2}^\sqrt n S(\left\lfloor\frac n{i^2}\right\rfloor)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MMu</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">l</span>(<span class="number">2</span>); <span class="number">1ll</span> * l * l &lt;= x; ++l) Ans += <span class="built_in">MMu</span>(x / (l * l));</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = x - Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个样子的，最后套上二分，这道题就愉快的结束了</p>
<h3 id="Code-100-2"><a href="#Code-100-2" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Mu;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> T, A, B;</span><br><span class="line"><span class="type">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="type">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; <span class="number">1ll</span> * i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MMu</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">l</span>(<span class="number">2</span>); <span class="number">1ll</span> * l * l &lt;= x; ++l) Ans += <span class="built_in">MMu</span>(x / (l * l));</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = x - Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">l</span><span class="params">(X)</span>, <span class="title">r</span><span class="params">(X &lt;&lt; <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MMu</span>(Mid) &gt;= X) r = Mid;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">Find</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时间的话，再用$\text{Min_25}$筛写一次吧</p>
<p><strong>注意：</strong>不用开$\text{long long}$的地方就别开$\text{long long}$，不明白为什么有的$OJ$连这个都要卡</p>
<p><img src="https://s1.ax1x.com/2020/09/24/wxXz4K.png" alt=""></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
        <tag>容斥</tag>
        <tag>前缀和</tag>
        <tag>Min_25筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>强连通分量(CSS)</title>
    <url>/AlanTuringLi/2023/01/09/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-SCC/</url>
    <content><![CDATA[<h1 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h1><p><strong>强连通：</strong>有向图 $G$ 中任意两个节点相连</p>
<p>$DFS$ <strong>树：</strong></p>
<ul>
<li>树边（$tree\;edge$）：搜索到为访问的点</li>
<li>返祖边（$back\;tree$）：指向祖先节点，亦称回边</li>
<li>横叉边（$cross\;edge$）：搜索到并非祖先节点的已访问的节点</li>
<li>前向边（$forward\;edge$）：搜索到子树中的节点</li>
</ul>
<h1 id="Tarjan-求-SCC"><a href="#Tarjan-求-SCC" class="headerlink" title="$Tarjan$ 求 $SCC$"></a>$Tarjan$ 求 $SCC$</h1><p><strong>定理：</strong>一个 $SCC$ 一定存在于以 $G$ 为根的子树中，其中 $G$ 是这个 $SCC$ 中的一个点</p>
<p>在该算法中需要维护以下几个变量：</p>
<ul>
<li>$dfn_u$：在搜索过程中结点 $u$ 的搜索次序</li>
<li>$low_u$：在 $u$ 的子树中能回溯到的最早的已在栈中的结点</li>
</ul>
<p>容易发现，当 $dfn_u\;=\;low_u$ 时，一定存在一个 $SCC$</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Low[u] = Dfn[u] = ++Tim;</span><br><span class="line">    Stac[++Top] = u, Vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjin</span> (v);</span><br><span class="line">            Low[u] = <span class="built_in">min</span>(Low[u], Low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Vis[v])Low[u] = <span class="built_in">min</span>(Low[u], Dfn[v]); <span class="comment">//前向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Dfn[u] == Low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Tot++;</span><br><span class="line">        <span class="keyword">while</span>(Stac[Top + <span class="number">1</span>] != u)</span><br><span class="line">        &#123;</span><br><span class="line">            Color[Stac[Top]] = Tot;</span><br><span class="line">            Vis[Stac[Top--]] = <span class="number">0</span>;</span><br><span class="line">            Sum[Tot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>图论</tag>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title>悬线Dp</title>
    <url>/AlanTuringLi/2020/07/24/%E6%82%AC%E7%BA%BFDp/</url>
    <content><![CDATA[<h1 id="ZJOI2007-棋盘制作"><a href="#ZJOI2007-棋盘制作" class="headerlink" title="[ZJOI2007]棋盘制作"></a><a href="https://www.luogu.com.cn/problem/P1169">[ZJOI2007]棋盘制作</a></h1><p>这比较模板, 算是裸的悬线$dp$</p>
<p>看见$N,M\leqslant2000$, 对了, 那就是了</p>
<p>时间复杂度$O(NM)$妥妥的</p>
<p>那么悬线法就是维护以这个点为某个边界条件, 维护其他边界范围</p>
<p>一般常用的是将这个点作为矩形的下底边, 用$left$维护最左边的范围, $right$维护最右边的范围, $up$维护上边界</p>
<p>所以这个点所在的矩阵大小就是$(right-left+1)*up$</p>
<p>如果要求什么正方形之类的, 对边特殊处理一下即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> N, M, Map[Maxn][Maxn];</span><br><span class="line"><span class="type">int</span> Left[Maxn][Maxn], Right[Maxn][Maxn], Up[Maxn][Maxn];</span><br><span class="line"><span class="type">int</span> AnsS, AnsQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, Map[i] + j), Left[i][j] = Right[i][j] = j, Up[i][j] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= M; ++j) <span class="keyword">if</span> (Map[i][j] ^ Map[i][j - <span class="number">1</span>]) Left[i][j] = Left[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = M - <span class="number">1</span>; j; --j) <span class="keyword">if</span> (Map[i][j + <span class="number">1</span>] ^ Map[i][j]) Right[i][j] = Right[i][j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; Map[i][j] ^ Map[i - <span class="number">1</span>][j])</span><br><span class="line">            &#123;</span><br><span class="line">                Left[i][j] = <span class="built_in">max</span>(Left[i - <span class="number">1</span>][j], Left[i][j]);</span><br><span class="line">                Right[i][j] = <span class="built_in">min</span>(Right[i - <span class="number">1</span>][j], Right[i][j]);</span><br><span class="line">                Up[i][j] = Up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> Len = Right[i][j] - Left[i][j] + <span class="number">1</span>;</span><br><span class="line">            AnsS = <span class="built_in">max</span>(AnsS, <span class="built_in">min</span>(Len, Up[i][j]));</span><br><span class="line">            AnsQ = <span class="built_in">max</span>(AnsQ, Len * Up[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n%d\n&quot;</span>, AnsS * AnsS, AnsQ);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>悬线Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索专题</title>
    <url>/AlanTuringLi/2020/09/05/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h1><ul>
<li>STL</li>
</ul>
<blockquote>
<ul>
<li>队列</li>
<li>优先队列</li>
</ul>
</blockquote>
<p>那就可以了</p>
<hr>
<h1 id="fc-DFS-amp-BFS"><a href="#fc-DFS-amp-BFS" class="headerlink" title="fc(DFS&amp;BFS)"></a>fc(DFS&amp;BFS)</h1><p>相信大家都对搜索(深搜/款搜)有了一定程度上自己的理解了</p>
<p>然后据我所了解，可能大家对这两个东西的区分度可能不是特别高，然后请允许我来<del>口胡</del>(对比、分析？)一下这两个东西</p>
<p>先来一个小练习：</p>
<p>用搜索求斐波那契数列的第$n$项</p>
<p><del>可能在座的各位已经会了递推求解、矩阵快速幂求解、通项公式求解</del></p>
<p>但还是希望大家能拿起自己的草稿纸，画一画这个运行的大概的过</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        斐波那契数列
    </div>
    <div class='spoiler-content'>
        <p><img src="https://s1.ax1x.com/2020/09/08/wQlXmn.png" alt=""></p>

    </div>
</div>
<h2 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth First Search)"></a>深度优先搜索(Depth First Search)</h2><p>优势：</p>
<ul>
<li>适合状态不易储存的情况</li>
<li>有时候对子问题的依赖很强</li>
<li>符合人类的思考习惯</li>
</ul>
<p>劣势：</p>
<ul>
<li>很容易超时</li>
<li>很容易爆栈</li>
</ul>
<h2 id="宽度优先搜索-Breadth-First-Search-（Baidu-First-Search）"><a href="#宽度优先搜索-Breadth-First-Search-（Baidu-First-Search）" class="headerlink" title="宽度优先搜索(Breadth First Search （Baidu First Search）)"></a>宽度优先搜索(Breadth First Search <del>（Baidu First Search）</del>)</h2><p>优势：</p>
<ul>
<li>适合状态容易储存的问题</li>
<li>不容易爆栈（搜索深度远大于$\text{DFS}$）</li>
<li>能够将父状态继承给子状态</li>
<li>可以跑最短路啊，各种最优化问题</li>
</ul>
<p>劣势：</p>
<ul>
<li>可能产生大量的无用状态导致$MLE$</li>
<li>对某些数据结构的要求有点高</li>
</ul>
<p>接下来干嘛，练题？</p>
<p><del>太没意思了吧。。。</del></p>
<p>来点有意思的？</p>
<hr>
<h1 id="奇技淫巧一：记忆化搜索-伪dp"><a href="#奇技淫巧一：记忆化搜索-伪dp" class="headerlink" title="奇技淫巧一：记忆化搜索(伪dp)"></a>奇技淫巧一：记忆化搜索(伪dp)</h1><p>先让大家用搜索求一求</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        斐波那契数列
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, Feb[<span class="number">105</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">feb</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">feb</span>(x - <span class="number">1</span>) + <span class="built_in">feb</span>(x -  <span class="number">2</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        Feb[i] = (Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Feb[n]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">feb</span>(n));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>好像$n$从$40$开始，这两个方式跑出来的时间差距就越来越大了</p>
<p>咋搞？</p>
<p>嗯，如题：记忆化</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, Feb[<span class="number">105</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">ll ans[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">feb</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans[x]) <span class="keyword">return</span> ans[x];</span><br><span class="line">    <span class="keyword">return</span> ans[x] = (<span class="built_in">feb</span>(x - <span class="number">1</span>) + <span class="built_in">feb</span>(x -  <span class="number">2</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        Feb[i] = (Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Feb[n]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">feb</span>(n));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>其实这个没有什么不一样的</p>
<p>就是记忆化，请大家$YY$一下就好</p>
<h2 id="来点例题？"><a href="#来点例题？" class="headerlink" title="来点例题？"></a>来点例题？</h2><h3 id="SHOI2012滑雪"><a href="#SHOI2012滑雪" class="headerlink" title="SHOI2012滑雪"></a><a href="https://www.luogu.com.cn/problem/P1434">SHOI2012滑雪</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        solution
    </div>
    <div class='spoiler-content'>
        <p>那么就是用一个$f[i][j]$来记录在$(i,j)$能往下滑的最大距离</p>
<p>那么转移的话就是</p>
<script type="math/tex; mode=display">
f[i][j]=max(f[i-1][j], f[i+1][j],f[i][j-1],f[i][j+1])+1</script><p>当然，这个方程并不完全正确，大家还需要判断一下边界条件和这个高度的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> f[<span class="number">105</span>][<span class="number">105</span>], h[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> my[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    f[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (h[nx][ny] &gt;= h[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        f[x][y] = <span class="built_in">max</span>(f[x][y], <span class="built_in">dfs</span>(nx, ny) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">j</span>(<span class="number">1</span>); j &lt;= m; ++j)</span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">j</span>(<span class="number">1</span>); j &lt;= m; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>    
<h3 id="Achen"><a href="#Achen" class="headerlink" title="Achen"></a><a href="https://www.luogu.com.cn/problem/U130279">Achen</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        solution
    </div>
    <div class='spoiler-content'>
        <p>手动模拟一下</p>
<p>会发现，其实$A/B$左右是否是空的，对于这道题没有本质的影响</p>
<p>因为要走遍所有的点的话，这只有一种方案</p>
<p>然后$A/B$的顺序对于本题也没有本质影响</p>
<p>来两张图？</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wGGFde.png" alt=""></p>
<p><img src="https://s1.ax1x.com/2020/09/10/wGoMo8.png" alt=""></p>
<p>好像就是如果$A$不是最靠左的点，那么$A$的实际位置应该是再往右走一格的位置，$B$也同理</p>
<p>那么所有的问题都可以转化为$A,B$分别为端点的问题了</p>
<p>再想，这个又能怎么考虑呢？</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wG7sq1.png" alt=""></p>
<p>这啥意思？</p>
<p>就是到最右端点的两种方案</p>
<p>如果我们用一个数组$f[i]$来表示经过了$i$点左边的所有点后，最后到达$i$这样的情况的方案数</p>
<p>那么它可以写成这样$f[i] = f[i - 1] + f[i - 3]$</p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span>()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll Feb[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">ll T, N, A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Feb[x]) <span class="keyword">return</span> Feb[x];</span><br><span class="line">	<span class="keyword">return</span> Feb[x] = (<span class="built_in">dfs</span>(x - <span class="number">1</span>) + <span class="built_in">dfs</span>(x - <span class="number">3</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T = <span class="built_in">Read</span>();</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		N = <span class="built_in">Read</span>(), A = <span class="built_in">Read</span>(), B = <span class="built_in">Read</span>();</span><br><span class="line">		<span class="keyword">if</span> (A &gt; B) <span class="built_in">swap</span>(A, B);</span><br><span class="line">		<span class="keyword">if</span> (A &gt; <span class="number">1</span>) A += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; N) B -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; A) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(B - A));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<p><del>其实递推更简单，但是没有这个记搜快</del></p>

    </div>
</div>
<h3 id="过河卒"><a href="#过河卒" class="headerlink" title="过河卒"></a><a href="https://www.luogu.com.cn/problem/P1002">过河卒</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        solution
    </div>
    <div class='spoiler-content'>
        <p>个人觉得这是一个板子题<del>水题</del></p>
<p>极其无脑的模拟就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line">ll f[maxn][maxn];</span><br><span class="line"><span class="type">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> my[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || y &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">return</span> f[x][y] = <span class="built_in">dfs</span>(x + <span class="number">1</span>, y) + <span class="built_in">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    x = __read(), y = __read();</span><br><span class="line">    f[n][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt; n || ny &lt; <span class="number">0</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        f[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，记得开$long\;long$我失算了，因为没开，交了三次。。。</p>
<p>难受。。。</p>

    </div>
</div>
<h1 id="奇技淫巧二：疯狂剪枝"><a href="#奇技淫巧二：疯狂剪枝" class="headerlink" title="奇技淫巧二：疯狂剪枝"></a>奇技淫巧二：疯狂剪枝</h1><p>那就是遇见不可能有贡献的答案可以直接返回</p>
<h2 id="来点例题？-1"><a href="#来点例题？-1" class="headerlink" title="来点例题？"></a>来点例题？</h2><h3 id="数的划分-加强版"><a href="#数的划分-加强版" class="headerlink" title="数的划分(加强版)"></a><a href="https://www.luogu.com.cn/problem/U130408">数的划分(加强版)</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        solution
    </div>
    <div class='spoiler-content'>
        <p>我们可以先写一个暴力，康康它可以怎么记忆化</p>
<p>$DFS$的时候，我们就记录三个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> f[<span class="number">205</span>][<span class="number">10</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rest, <span class="type">int</span> num, <span class="type">int</span> last)</span><span class="comment">//rest -&gt; 还剩多少， 还应该分几次， last -&gt; 保证枚举出来时单调的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last; i &lt;= rest; ++i)</span><br><span class="line">        ans += <span class="built_in">dfs</span>(rest - i, num - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n, k, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记忆化一下，代码没怎么变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> f[<span class="number">205</span>][<span class="number">10</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rest, <span class="type">int</span> num, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~f[rest][num][last]) <span class="keyword">return</span> f[rest][num][last];</span><br><span class="line">    <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest) <span class="keyword">return</span> f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> f[rest][num][last] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; num * last) <span class="keyword">return</span> f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">    f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = last; i &lt;= rest; ++i)</span><br><span class="line">        f[rest][num][last] += <span class="built_in">dfs</span>(rest - i, num - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">return</span> f[rest][num][last];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n, k, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看题解，惊艳了，这种吊打我代码神仙写法都有</p>
<p>当然，我将这种写法呢，只是为了让大家深刻理解一下这的记忆化搜索还有剪枝优化</p>

    </div>
</div>
<h1 id="奇技淫巧三：双向BFS、折半搜索"><a href="#奇技淫巧三：双向BFS、折半搜索" class="headerlink" title="奇技淫巧三：双向BFS、折半搜索"></a>奇技淫巧三：双向BFS、折半搜索</h1><p>怎么说？如题！</p>
<h2 id="八数码难题"><a href="#八数码难题" class="headerlink" title="八数码难题"></a><a href="https://www.luogu.com.cn/problem/P1379">八数码难题</a></h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        solution
    </div>
    <div class='spoiler-content'>
        <p>双向$BFS$嘛，对吧？</p>
<p>那就从首尾两端分别搜一次呗</p>
<p>这有什么好处呢？</p>
<p>简单的说，这个东西它及大幅度的剪掉了无用的状态</p>
<p>上图？</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYbAtx.png" alt=""></p>
<p>如果要把这个搜索树给遍历完，那么这个的时间复杂度就是$O(2^{n+1})$</p>
<p>那么如果$n$的数量级在$30、40$左右，那么恭喜你，完了！绝对$TLE$！</p>
<p>但是$CJ$我表示不服，我就只会搜索。。。</p>
<p>那么我们稍微修改一下这棵树</p>
<p>怎么讲？</p>
<p>有很多叶子节点时没有用的！！！</p>
<p>那么我们让这棵树有两个根，看看那些叶子结点的信息重合了</p>
<p>重合了就可以更新答案</p>
<p>那么时间复杂度？$O(\sqrt{2^{n+1}})$，很可以！</p>
<p>如果原来是$1e12$的复杂度</p>
<p>根号一下就是$1e6$，随便跑啊！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> my[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> Now, Next, Ans = <span class="number">123804765</span>;</span><br><span class="line"></span><br><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; en[<span class="number">2</span>];</span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mswap</span><span class="params">(<span class="type">char</span> &amp;a, <span class="type">char</span> &amp;b)</span></span>&#123;a ^= b ^= a ^= b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> state,<span class="type">int</span> k,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="type">short</span> x, y, l = en[w][state];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(state % <span class="number">10</span> == <span class="number">0</span>) x = i,y = j;</span><br><span class="line">			a[i][j] = <span class="built_in">char</span>((state % <span class="number">10</span> - <span class="number">0</span>) + <span class="string">&#x27;0&#x27;</span>), state /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">short</span> nx = x + mx[k];</span><br><span class="line">	<span class="type">short</span> ny = y + my[k];</span><br><span class="line">	<span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt; <span class="number">2</span> || ny &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mswap</span>(a[x][y], a[nx][ny]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">			state = state * <span class="number">10</span> + <span class="built_in">int</span>(a[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(en[w].<span class="built_in">count</span>(state)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	en[w][state] = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	Now = q[x].<span class="built_in">front</span>();</span><br><span class="line">		q[x].<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">			Next = <span class="built_in">Get</span>(Now, i, x);</span><br><span class="line">			<span class="keyword">if</span>(!Next)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(en[!x].<span class="built_in">count</span>(Next))&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, en[<span class="number">0</span>][Next] + en[<span class="number">1</span>][Next]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">			&#125;</span><br><span class="line">			q[x].<span class="built_in">push</span>(Next);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	q[<span class="number">0</span>].<span class="built_in">push</span>(Now);</span><br><span class="line">	q[<span class="number">1</span>].<span class="built_in">push</span>(Ans);</span><br><span class="line">	<span class="keyword">while</span>(q[<span class="number">0</span>].<span class="built_in">size</span>() || q[<span class="number">1</span>].<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[<span class="number">0</span>].<span class="built_in">size</span>())<span class="built_in">work</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(q[<span class="number">1</span>].<span class="built_in">size</span>())<span class="built_in">work</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Now);</span><br><span class="line">	<span class="keyword">if</span>(Now == Ans)<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是吧，挺简单的</p>

    </div>
</div>
<h1 id="奇技淫巧四：IDA"><a href="#奇技淫巧四：IDA" class="headerlink" title="奇技淫巧四：IDA*"></a>奇技淫巧四：IDA*</h1><h2 id="来到例题？"><a href="#来到例题？" class="headerlink" title="来到例题？"></a>来到例题？</h2><h3 id="铁盘整理"><a href="#铁盘整理" class="headerlink" title="铁盘整理"></a><a href="https://www.luogu.com.cn/problem/P2534">铁盘整理</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[maxn], f[maxn], limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> _abs(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Check</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        res += (_abs(a[i] - a[i + <span class="number">1</span>]) != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bdfs</span><span class="params">(<span class="type">int</span> dep, <span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">Check</span>();</span><br><span class="line">    <span class="keyword">if</span> (dep + g &gt; limit) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep &gt; limit) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, dep);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i != pre) &#123;</span><br><span class="line">            <span class="built_in">reverse</span> (a + <span class="number">1</span>, a + i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">bdfs</span>(dep + <span class="number">1</span>, i);</span><br><span class="line">            <span class="built_in">reverse</span> (a + <span class="number">1</span>, a + i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read(), f[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span> (f + <span class="number">1</span>, f + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + n + <span class="number">1</span>, a[i]) - f;</span><br><span class="line">    a[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; limit &lt;= (n &lt;&lt; <span class="number">1</span>) - <span class="number">2</span>; ++limit) <span class="built_in">bdfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="骑士精神"><a href="#骑士精神" class="headerlink" title="骑士精神"></a><a href="https://www.luogu.com.cn/problem/P2324">骑士精神</a></h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, X, Y, Get;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> my[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">char</span> Now[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> Goal[<span class="number">10</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">char</span> &amp;x,<span class="type">char</span> &amp;y)</span></span>&#123;x ^= y ^= x ^= y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">G</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>;++j)<span class="keyword">if</span> (Now[i][j] != Goal[i][j])++Cnt;</span><br><span class="line">    <span class="keyword">return</span> Cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDA_STAR</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> Dep, <span class="type">int</span> Limit, <span class="type">int</span> Dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Get)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Dep &gt; Limit)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">G</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Dep);</span><br><span class="line">        Get = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= <span class="number">5</span> || nx &lt;<span class="number">0</span> || ny &gt;= <span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i + Dir == <span class="number">7</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(Now[x][y], Now[nx][ny]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">G</span>() + Dep &lt;= Limit)<span class="built_in">IDA_STAR</span>(nx, ny, Dep + <span class="number">1</span>, Limit, i);</span><br><span class="line">        <span class="built_in">Swap</span>(Now[x][y], Now[nx][ny]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        Get = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> Ch = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">while</span>((Ch != <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (Ch != <span class="string">&#x27;1&#x27;</span>) &amp;&amp; (Ch != <span class="string">&#x27;*&#x27;</span>))Ch = <span class="built_in">getchar</span>();</span><br><span class="line">            Now[i][<span class="number">0</span>] = Ch;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j)Now[i][j] = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(Now[i][j] == <span class="string">&#x27;*&#x27;</span>) X = i, Y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i)<span class="built_in">IDA_STAR</span>(X, Y, <span class="number">0</span>, i, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Get)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><del>我可能没时间写了，<a href="https://oi-wiki.org/search/astar/">好网站</a></del></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>摆渡车</title>
    <url>/AlanTuringLi/2020/09/15/%E6%91%86%E6%B8%A1%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="摆渡车"><a href="#摆渡车" class="headerlink" title="摆渡车"></a><a href="https://ac.nowcoder.com/acm/problem/21471">摆渡车</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你可以操控一辆车的发车时间，你也知道跑一次往返的时间，你还知道每一个人到达车站的时间</p>
<p>让你找到一种方案使得所有人的等待时间之和最少，求这个最小时间</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一反应是把到达车站的人作为一个整体<br>然后我们可以枚举最近的一次发车时间</p>
<p>假设现在的时间是$\text{i}$，最近的一次发车时间是$\text{j}$<br>那么从$j\sim i$的等待时间可以表示为$\sum_{j&lt;t_x\le i}i-t_x$<br>那么我们把这个拆开来看</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{j<t_x\le i}i-t&=\sum_{j<t_x\le i}i-\sum_{j < t_x\le i}t_x\\
&=(cnt_i-cnt_j)*i-(sum_i-sumj)
\end{align*}</script><p>貌似变得友好了呢</p>
<p>直观感觉一下，我们有效的最近的发车时间应该是不能小于($\text{i-m}$)的</p>
<p>那么其实就是有一部分人在上一次发车时就开始等待了<br>那么这个也是要加入贡献的</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, mt, <span class="built_in">ans</span>(<span class="number">0x7fffffff</span>);</span><br><span class="line"><span class="type">int</span> cnt[maxn], sum[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) o = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cnt[r] - cnt[l]) * r - (sum[r] - sum[l]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">Read</span>(), m = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mt = <span class="built_in">max</span>(t = <span class="built_in">Read</span>(), mt);</span><br><span class="line">        cnt[t]++, sum[t] += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + mt; ++i) cnt[i] += cnt[i - <span class="number">1</span>], sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + mt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m &amp;&amp; cnt[i] == cnt[i - m]) &#123;</span><br><span class="line">            f[i] = f[i - m];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = cnt[i] * i - sum[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(i - <span class="number">2</span> * m + <span class="number">1</span>, <span class="number">0</span>); j &lt;= i - m; ++j)</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], f[j] + <span class="built_in">wait</span>(j, i));</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= mt) ans = <span class="built_in">min</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/AlanTuringLi/2020/07/22/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="HDU3652-B-Number"><a href="#HDU3652-B-Number" class="headerlink" title="HDU3652 B-Number"></a><a href="https://vjudge.net/problem/HDU-3652#author=0">HDU3652 B-Number</a></h1><p>这道题, 是非常典型的一个例子, 堪称数位$Dp$的模板</p>
<h2 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计:"></a>状态设计:</h2><p>令$Dp[Pos][Lst][Num]$表示当前枚举的这个数是第$Pos$位, 前面数字的状态为$Lst$, 前面的数的和对$13$取模的结果为$Num$</p>
<p>可以枚举第$Pos$为可能的值$i$, 并有如下转移</p>
<script type="math/tex; mode=display">
Ans=\sum\limits_{i=1}^{\min(limit,\;9)}Dp[pos-1][State][(Num*10+i)\%13]</script><p>解释一下$State$:</p>
<script type="math/tex; mode=display">
\begin{align*}
    if (&State == 0)\\
        &if (i == 1) return 1;\\
        &else\;return 0;\\
    else& if (State == 1)\\
        &if (i == 1) return 1;\\
        &else\;if (i == 3) return 2;\\
        &else\;return 0;\\
    retu&rn 2;
\end{align*}</script><p>这应该算是比较明白的了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> N, A[<span class="number">15</span>], Dp[<span class="number">15</span>][<span class="number">3</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> Lst, <span class="type">int</span> Now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Lst == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (Now == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Lst == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (Now == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Now == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> Pos, <span class="type">int</span> Lst, <span class="type">int</span> Num, <span class="type">int</span> Lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pos == <span class="number">0</span>) <span class="keyword">return</span> Num == <span class="number">0</span> &amp;&amp; Lst == <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; ~Dp[Pos][Lst][Num]) <span class="keyword">return</span> Dp[Pos][Lst][Num];</span><br><span class="line">    <span class="type">int</span> Limit = Lim ? A[Pos] : <span class="number">9</span>, <span class="built_in">Ans</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Limit; ++i)</span><br><span class="line">        Ans += <span class="built_in">DFS</span>(Pos - <span class="number">1</span>, <span class="built_in">Get</span>(Lst, i), (Num * <span class="number">10</span> + i) % M, Lim &amp;&amp; i == Limit);</span><br><span class="line">    <span class="keyword">return</span> Lim ? Ans : Dp[Pos][Lst][Num] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Work</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (X)</span><br><span class="line">    &#123;</span><br><span class="line">        A[++Pos] = X % <span class="number">10</span>;</span><br><span class="line">        X /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DFS</span>(Pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N) != EOF) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Work</span>(N));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ZJOI2010-数字计数"><a href="#ZJOI2010-数字计数" class="headerlink" title="[ZJOI2010]数字计数"></a><a href="https://www.luogu.com.cn/problem/P2602">[ZJOI2010]数字计数</a></h1><p>重复十次相同的操作……</p>
<p>因为考虑到有前导0,  会对0的统计造成影响, 所以要排除前导零的影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll A, B;</span><br><span class="line">ll Dp[<span class="number">20</span>][<span class="number">20</span>], Num[<span class="number">20</span>];</span><br><span class="line"><span class="function">ll <span class="title">DFS</span><span class="params">(<span class="type">int</span> Pos, <span class="type">int</span> Nmb, ll Sum, <span class="type">bool</span> Lim, <span class="type">bool</span> Led)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pos == <span class="number">0</span>) <span class="keyword">return</span> Sum;</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; Led &amp;&amp; ~Dp[Pos][Sum]) <span class="keyword">return</span> Dp[Pos][Sum];</span><br><span class="line">    <span class="type">int</span> Up = Lim ? Num[Pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Up; ++i)</span><br><span class="line">        Ans += <span class="built_in">DFS</span>(Pos - <span class="number">1</span>, Nmb, Sum + ((i || Led) &amp;&amp; (i == Nmb)), (i == Up) &amp;&amp; Lim, Led || i);</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; Led) Dp[Pos][Sum] = Ans;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll X, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Len</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (X)</span><br><span class="line">    &#123;</span><br><span class="line">        Num[++Len] = X % <span class="number">10</span>;</span><br><span class="line">        X /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DFS</span>(Len, N, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld&quot;</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%lld &quot;</span>, <span class="built_in">Get</span>(B, i) - <span class="built_in">Get</span>(A - <span class="number">1</span>, i));</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数位Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>旧试题</title>
    <url>/AlanTuringLi/2020/08/23/%E6%97%A7%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="P4619-SDOI2018-旧试题"><a href="#P4619-SDOI2018-旧试题" class="headerlink" title="P4619 [SDOI2018]旧试题"></a><a href="https://www.luogu.com.cn/problem/P4619">P4619 [SDOI2018]旧试题</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这里没有奇奇怪怪的描述</p>
<p>这道题说白了就是求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\text{d}(ijk)\\
其中\text{d}(x)表示x的约数个数</script><p>这道题和<a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a>比较类似，其实就是多了一个$j$</p>
<h2 id="问题化简"><a href="#问题化简" class="headerlink" title="问题化简"></a>问题化简</h2><p>我们可以知道：</p>
<script type="math/tex; mode=display">
\text{d}(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][z\perp x]</script><p>即，原式可以化为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\text{d}(ijk)&=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][x\perp z]\\
&=\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C[x\perp y][y\perp z][x\perp z][\frac Ax][\frac By][\frac Cz]\\
&\text{选择x$\perp$y进行反演，即：}\\
&=\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C(\sum_{d|\gcd(x,y)}\mu(d))[y\perp z][x\perp z][\frac Ax][\frac By][\frac Cz]\\
&=\sum_{d=1}^{\min(A,B)}\mu(d)\sum_{x=1}^{\lfloor\frac Ad\rfloor}\sum_{y=1}^{\lfloor\frac Bd\rfloor}\sum_{z=1}^C[yd\perp z][xd\perp z][\frac A{xd}][\frac B{yd}][\frac Cz]\\
&\text{整理一下可以得到：}\\
&=\sum_{z=1}^C[\frac Cz]\sum_{d=1}^{\min(A,B)}\mu(d)[d\perp z](\sum_{x=1}^{\frac Ad}[x\perp z][\frac A{dx}])(\sum_{y=1}^{\frac Bd}[y\perp z][\frac B{dx}])
\end{align*}</script><p>这样一来，我们就成功了一大半了</p>
<p>现在，我们发现有两串看似比较相似的运算，我们可以用一个函数来代替它:</p>
<script type="math/tex; mode=display">
f(n,k)=\sum_{i=1}^n[i\perp k][\frac ni]\\
g(n,k)=\sum_{i=1}^n\mu(i)[i\perp k]</script><p>那么：</p>
<script type="math/tex; mode=display">
\begin{align*}
Ans&=\sum_{z=1}^C[\frac Cz]\sum_{d=1}^{\min(A,B)}\mu(d)[d\perp z]f(\frac Ad,z)f(\frac Bd,z)\\
&=\sum_{z=1}^C[\frac Cz]\sum (g(r,z)-g(l-1,z))f(\frac Al,z)f(\frac Bl,z)\\
\end{align*}</script><p>这里，我们发现$\sum (g(r,z)-g(l-1,z))f(\frac Al,z)f(\frac Bl,z)$其实与$z$本身无关</p>
<p>简言之，我们只需要考虑$z$的无平方因子数</p>
<p>即：</p>
<script type="math/tex; mode=display">
lw(z)=\prod_{i=1} P_i^1</script><p>但是如何快速求解这两个函数呢？</p>
<p>按照老套路，我们可以用$f(n,k/x)\;or\;g(n,k/x)$减去这其中不可行的得到</p>
<p>那么就有：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,k)&=\sum_{i=1}^n[i\perp k][\frac ni]\\
&=\sum_{i=1}^n[i\perp \frac kx][\frac ni]-\sum_{i=1}^n[i\perp \frac kx][\frac ni][x|i]\\
&=f(n,k/x)-\sum_{d=1}^{[\frac nx]}[dx\perp\frac kx][\frac n{dx}][x|kx]\\
&=f(n,k/x)-\sum_{d=1}^{[\frac nx]}[dx\perp\frac kx][\frac n{dx}]\\
&=f(n,k/x)-[x\perp \frac kx]\sum_{d=1}^{[\frac nx]}[d\perp\frac kx][\frac n{dx}]\\
&=f(n,k/x)-f([\frac nx],k/x)
\end{align*}</script><p>那么还有：</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,k)&=\sum_{i=1}^n\mu(i)[i\perp k]
\\&=\sum_{i=1}^n\mu(i)[i\perp \frac kx]-\sum_{i=1}^n\mu(i)[i\perp\frac kx][x|i]
\\&=g(n,k/x)-\sum_{d=1}^{[\frac nx]}\mu(dx)[dx\perp\frac kx][x|dx]
\\&=g(n, k/x)-\sum_{d=1}^{[\frac nx]}\mu(d)\mu(x)[d\perp x][dx\perp \frac kx][x|dx]
\\&=g(n,k/x)-\mu(x)[x\perp\frac kx]\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp x][d\perp\frac kx]
\\&=g(n,k/x)-\mu(x)[x\perp\frac kx]\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp (x*\frac kx)]
\\&=g(n,k/x)+\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp k]
\\&=g(n,k/x)+g([\frac nx],k)
\end{align*}</script><p>根据上文，我们知道所有的$k$都一定是我平方因字数，所以这个结论很好得到</p>
<p>即：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,k)&=f(n,k/x)-f(\lfloor\frac nx\rfloor,k/x)\\
g(n,k)&=g(n,k/x)+g(\lfloor\frac nx\rfloor,k)
\end{align*}</script><p>现在，最后的问题就是关于这两个函数的边界的问题了</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,1)&=\sum_{i=1}^n\mu(i)\qquad\text{这个可以直接前缀和预处理}
\\f(n,1)&=\sum_{i=1}^n[\frac ni]\qquad\,\text{这个用数论分块吗？}
\end{align*}</script><p>下面有一个非常巧妙的，线性求接的办法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Prework</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Ip[i]) P[++P[<span class="number">0</span>]] = i, D[i] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= P[<span class="number">0</span>] &amp;&amp; i * P[j] &lt;= N; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Ip[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % P[j]) D[i * P[j]] = D[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				D[i * P[j]] = (D[i] &lt;&lt; <span class="number">1</span>) - D[i / P[j]];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) D[i] += D[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个的证明我先鸽了，<del>不会</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>, Lim = <span class="number">2e5</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll D[Maxn], F[Maxn][<span class="number">10</span>], G[Maxn][<span class="number">10</span>], S[Maxn], Ans;</span><br><span class="line"><span class="type">int</span> Prim[Maxn], Mu[Maxn], Lw[Maxn];</span><br><span class="line"><span class="type">bool</span> IP[Maxn];</span><br><span class="line"><span class="type">int</span> T, A, B, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (O &lt; <span class="string">&#x27;0&#x27;</span> || O &gt; <span class="string">&#x27;9&#x27;</span>) O = <span class="built_in">getchar</span> ();</span><br><span class="line">    <span class="keyword">for</span> (; O &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; O &lt;= <span class="string">&#x27;9&#x27;</span>; O = <span class="built_in">getchar</span> ()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> X; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = D[<span class="number">1</span>] = Lw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IP[i]) Prim[++Prim[<span class="number">0</span>]] = i, Mu[i] = <span class="number">-1</span>, D[i] = <span class="number">2</span>, Lw[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Prim[<span class="number">0</span>] &amp;&amp; i * Prim[j] &lt;= Lim; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> New = i * Prim[j];</span><br><span class="line">            IP[New] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Prim[j]) D[New] = D[i] &lt;&lt; <span class="number">1</span>, Lw[New] = Lw[i] * Prim[j], Mu[New] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                D[New] = (D[i] &lt;&lt; <span class="number">1</span>) - D[i / Prim[j]];</span><br><span class="line">                Lw[New] = Lw[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lim; ++i) D[i] += D[i - <span class="number">1</span>], Mu[i] += Mu[i - <span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(A / (A / l), B / (B / l));</span><br><span class="line">        G[r][<span class="number">1</span>] = Mu[r];</span><br><span class="line">        F[A / l][<span class="number">1</span>] = D[A / l];</span><br><span class="line">        F[B / l][<span class="number">1</span>] = D[B / l];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span> (S, <span class="number">0</span>, <span class="keyword">sizeof</span> S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">1</span>; z &lt;= C; ++z) S[Lw[z]] += <span class="number">1ll</span> * C / z;</span><br><span class="line">    Ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UpDate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(A / (A / l), B / (B / l));</span><br><span class="line">        G[r][k] = G[r][k - <span class="number">1</span>] + G[r / x][k];</span><br><span class="line">        F[A / l][k] = F[A / l][k - <span class="number">1</span>] - F[(A / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        F[B / l][k] = F[B / l][k - <span class="number">1</span>] - F[(B / l) / x][k - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//x就是上文中推公式用的x，k表示的是第k个素数，因为空间的问题，就写成这个鬼样子了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> z, <span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">Tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(A / (A / l), B / (B / l));</span><br><span class="line">        Tmp += (G[r][k] - G[l - <span class="number">1</span>][k]) * F[A / l][k] * F[B / l][k];</span><br><span class="line">        Tmp = (Tmp % Mod + Mod) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    Ans = (Ans + S[z] * Tmp % Mod) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = u; <span class="number">1ll</span> * Prim[v] * z &lt;= C; v++) <span class="built_in">UpDate</span>(Prim[v], k + <span class="number">1</span>), <span class="built_in">DFS</span>(z * Prim[v], v + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">Read</span>();</span><br><span class="line">    <span class="built_in">Prework</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        A = <span class="built_in">Read</span>(), B = <span class="built_in">Read</span>(), C = <span class="built_in">Read</span>();</span><br><span class="line">        <span class="keyword">if</span> (A &gt; B) <span class="built_in">swap</span> (A, B);</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="built_in">DFS</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>最长异或路径</title>
    <url>/AlanTuringLi/2020/09/16/%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="The-XOR-longest-Path"><a href="#The-XOR-longest-Path" class="headerlink" title="The XOR-longest Path"></a><a href="https://ac.nowcoder.com/acm/problem/50349">The XOR-longest Path</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一棵树, 让你求树上异或和最大的简单路径的异或和</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>想要异或和最大, 那么我们想要的显然是贪心, 那就是尽量让他们在二进制下不相同</p>
<p>这样考虑的话, 我们可以想到的是$01$字典树, 从高次项向低处贪心, 能保证最值</p>
<p>那么还有一个问题, 如何求一个简单路径的异或值?</p>
<p>我们又可以想到关于异或的优良性质:$x\otimes y\otimes x=y$</p>
<p>就是说, 可以随机找一个根, 求$root$到其他所有结点的链的路径异或和</p>
<p>如果我们要求的是$sum<em>{i,j}$, 那么它就可以十分简单的表示为$sum</em>{root,i}\otimes sum_{root,j}$</p>
<p>那么我们把所有的从根开始的路径插入到$01$字典树中, 暴力查询跟新答案就好惹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> Tree[Maxn * <span class="number">31</span>][<span class="number">2</span>], Id;</span><br><span class="line"><span class="type">int</span> Xor[Maxn];</span><br><span class="line"><span class="type">int</span> N, U, V, C, Ans;</span><br><span class="line"><span class="type">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], Edge[Maxn &lt;&lt; <span class="number">1</span>], W[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> V, <span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    Edge[Cur] = V;</span><br><span class="line">    W[Cur] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Rt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> F = X &amp; i;</span><br><span class="line">        <span class="keyword">if</span> (!Tree[Rt][F]) Tree[Rt][F] = ++Id;</span><br><span class="line">        Rt = Tree[Rt][F];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Rt = <span class="number">0</span>, <span class="type">int</span> Ans = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> F = X &amp; i;</span><br><span class="line">        <span class="keyword">if</span> (Tree[Rt][!F]) Ans += i, Rt = Tree[Rt][!F];</span><br><span class="line">        <span class="keyword">else</span> Rt = Tree[Rt][F];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> U, <span class="type">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Edge[i] == F) <span class="keyword">continue</span>;</span><br><span class="line">        Xor[Edge[i]] = Xor[U] ^ W[i];</span><br><span class="line">        <span class="built_in">DFS</span>(Edge[i], U);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;U, &amp;V, &amp;C);</span><br><span class="line">        <span class="built_in">AddEdge</span>(U, V, C), <span class="built_in">AddEdge</span>(V, U, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">Insert</span>(Xor[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Ans = <span class="built_in">max</span>(Ans, <span class="built_in">Query</span>(Xor[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>有的没的</title>
    <url>/AlanTuringLi/2021/02/02/%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/</url>
    <content><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p>有向量 $\overrightarrow{a}=(x_a,y_a,z_a), \overrightarrow{b}=(x_b,y_b,z_b)$</p>
<ul>
<li><strong>点乘</strong> <ul>
<li>$\overrightarrow{a}\cdot\overrightarrow{b}=|\overrightarrow{a}||\overrightarrow{b}|\cos\theta$</li>
<li>$\overrightarrow{a}\cdot\overrightarrow{b}=x_ax_b+y_ay_b+z_az_b$</li>
</ul>
</li>
<li><strong>叉乘</strong><ul>
<li>$\overrightarrow{c}=\overrightarrow{a}\times \overrightarrow{b}=|\overrightarrow{a}||\overrightarrow{b}|\sin\theta$  ，方向遵循右手定则（右手坐标系）</li>
<li><script type="math/tex; mode=display">
\overrightarrow{c}=\overrightarrow{a}\times\overrightarrow{b}=\begin{vmatrix}\overrightarrow{i}&\overrightarrow{j}&\overrightarrow{k}\\x_a&y_a&z_a\\x_b&y_b&z_b\end{vmatrix}=\overrightarrow{i}\,\begin{vmatrix}y_a&z_a\\y_b&z_b\end{vmatrix}-\overrightarrow{j}\,\begin{vmatrix}x_a&z_a\\x_b&z_b\end{vmatrix}+\overrightarrow{k}\,\begin{vmatrix}x_a&y_a\\x_b&y_b\end{vmatrix},\\ 即\overrightarrow{c}=(\begin{vmatrix}y_a&z_a\\y_b&z_b\end{vmatrix}, -\begin{vmatrix}x_a&z_a\\x_b&z_b\end{vmatrix}, \begin{vmatrix}x_a&y_a\\x_b&y_b\end{vmatrix}),i,j,k，分别为x,y,z轴的方向向量</script></li>
</ul>
</li>
</ul>
<h1 id="交流电"><a href="#交流电" class="headerlink" title="交流电"></a>交流电</h1><h2 id="有效值"><a href="#有效值" class="headerlink" title="有效值"></a>有效值</h2><p>可以考虑交流电在一个周期内产生的发出的热量 $Q:$</p>
<p>即：</p>
<script type="math/tex; mode=display">
Q=\int_t^Ti^2R\;\mathrm dt=I^2RT\\
\begin{aligned}
\Rightarrow\int_0^Ti^2\;\mathrm dt&=I^2T\\
&=\int_0^T({i_m}\sin\omega t)^2\;\mathrm dt\\
&=i_m^2\int_0^T\sin^2\omega t\;\mathrm dt\\
&=i_m^2\int_0^T\frac{1-\cos 2\omega t}2\;\mathrm dt\\
&=\frac{i_m^2}2\int_0^T(1-\cos2\omega t)\;\mathrm dt\\
&=\frac{i_m^2}2\left|t-\frac1{2\omega}\sin2\omega t\right|_0^T\\
&=\frac{i_m^2}2T
\end{aligned}\\
即:\\\frac{i_m^2}2T=I^2T\\
\Rightarrow I=\frac {i_m}{\sqrt 2}
\\
\text{注:}i_m\text{表示交流电中的最大瞬时电流}，U_m\text{表示交流电的最大瞬时电压}\\
\text{同理可得:}U=\frac {U_m}{\sqrt 2}</script><p>有效值一般就是用来计算什么发热功率、电功率之类的问题。</p>
<h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><script type="math/tex; mode=display">
\overline E=Bl\overline v，\quad\overline E=n\frac{\Delta \phi}{\Delta t},\quad\overline I=\frac{\overline E}{R+r}</script><p>这个一般用于计算一定时间内通过的电荷量，于是就可以得到：</p>
<script type="math/tex; mode=display">
q=n\frac{\Delta \phi}{R+r}</script><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Reviwe</title>
    <url>/AlanTuringLi/2020/07/12/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="T1-生物实验"><a href="#T1-生物实验" class="headerlink" title="T1:生物实验"></a>T1:生物实验</h1><ul>
<li><p>你有$n$个瓶子,其中$m$瓶有毒,然后你有$k\left(k\geqslant m\right)$ 只老鼠</p>
</li>
<li><p>每次每个瓶子只会有一只老鼠吃它!</p>
</li>
<li><p>每次有老鼠死后瓶子会被标记,以后不会再有老鼠去吃它了</p>
</li>
<li><p>问期望多少次可以把所有有毒的瓶子全部找到</p>
<p>对于$100\%$的数据有$T \leqslant 1000, N \leqslant 500, M \leqslant 200, M\leqslant K \leqslant N$</p>
</li>
</ul>
<p><strong>输入</strong>:</p>
<p>第一行是一个$T$</p>
<p>接下来$T$行每行三个正整数: $n, m, k$</p>
<p><strong>输出:</strong></p>
<p>一共有$T$行</p>
<p>对于每一组数据输出一行答案</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h1><blockquote>
<p>$DP[i]$表示还剩下$i$瓶有毒的期望步数</p>
<p>那么这个可以构成一张$DAG$</p>
<p>因为$i$ 这个点只能与比$i$小的点建一条有向边</p>
<p>既然已经知道有一张$DAG$了, 那么就可以拓扑逆向跑一边就可以得出答案了</p>
<script type="math/tex; mode=display">
Dp[i] = \frac{\mathrm{C}_n^k}{\mathrm{C}_{n + i}^k}\times\left(Dp[i] + 1\right) + \sum\limits_{k=1}^i\frac{\mathrm{C}_n^{k-j}\cdot\mathrm{C}_m^j}{\mathrm{C}_{n+m}^k}\left(Dp[i-k] + 1\right)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Maxn</span><span class="params">(<span class="number">1e3</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> T, N, M, K;<span class="comment">//N个瓶子, M瓶有毒, K只老鼠</span></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">double</span> Dp[Maxn];<span class="comment">//死了i只老鼠的期望步数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">C</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) Ans *= <span class="built_in">double</span>(N--) / <span class="built_in">double</span>(M - i);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span><span class="comment">//C(k, a)/C(k, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    Ans = <span class="built_in">double</span> (<span class="built_in">C</span>(k, a)) / <span class="built_in">double</span> (<span class="built_in">C</span>(k, b));</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> j, <span class="type">int</span> k)</span><span class="comment">//C(k - j, a) * C(j, b) / C(k, c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    Ans = <span class="built_in">double</span> (<span class="built_in">C</span>(k - j, a)) / <span class="built_in">double</span>(<span class="built_in">C</span>(k, c)) * <span class="built_in">double</span>(<span class="built_in">C</span>(j, b));</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d\n&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;N, &amp;M, &amp;K);</span><br><span class="line">        n = N - M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">min</span>(K - M + i, n + i);</span><br><span class="line">            <span class="type">double</span> P = <span class="built_in">C</span>(n, n + i, k), Temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) Temp += (Dp[i - j] + <span class="number">1.0</span>) * <span class="built_in">C</span>(n, i, n + i, j, k);</span><br><span class="line">            Dp[i] = (Temp + P) / (<span class="number">1.0</span> - P);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%.2lf\n&quot;</span>, Dp[M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>李超线段树</title>
    <url>/AlanTuringLi/2020/08/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="HEOI2013-Segment"><a href="#HEOI2013-Segment" class="headerlink" title="[HEOI2013]Segment"></a><a href="https://www.luogu.com.cn/problem/P4097">[HEOI2013]Segment</a></h1><p>不厚道得借鉴一些$OI\;Wiki$的好东西</p>
<p>此题, 大概就是模板题了</p>
<p>其实, 如果按照常规思路, 想到的东西大概也是一样的</p>
<p>和线段树一样, 我们需要维护$X$轴上的信息</p>
<p>就是说, 我们只需要记录对于每一个$X$, 它对应的答案是啥</p>
<blockquote>
<p>对答案没有贡献的线段, 相当于就被丢弃了</p>
<p>所以此时的线段树中的值, 就是唯一的比较的对象了</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一:"></a>情况一:</h3><p>那么如果这个区间没有被覆盖, 可以直接标记为最值</p>
<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二:"></a>情况二:</h3><p>如果这个被覆盖了, 那么又要分三种情况</p>
<p>我们另绿色为新加入的点</p>
<h4 id="1-New-k-gt-T-X-k"><a href="#1-New-k-gt-T-X-k" class="headerlink" title="(1)$New.k&gt;T_X.k$"></a>(1)$New.k&gt;T_X.k$</h4><ul>
<li><strong>1.中值可以被更新</strong></li>
</ul>
<p><img src="./greater.png" alt=""></p>
<p>我们看见, 此时新的线段可以更新到$mid$的位置, 它也可以继续更新$mid+1$到$r$的位置, 但是$l$到$mid$的部分, 就不一定可以更新了, 但是我们可以看见, 它仍有一部分是可以更新的</p>
<ul>
<li><p><strong>2.中值无法更新</strong></p>
<p><img src="./greater2.png" alt=""></p>
</li>
</ul>
<p>那么对于这种情况, 我们就不需要更新$l$到$mid$的值了, 但是我们也有可能更新$mid+1$到$r$</p>
<h4 id="2-New-k-lt-T-X-k"><a href="#2-New-k-lt-T-X-k" class="headerlink" title="(2)$New.k&lt;T_X.k$"></a>(2)$New.k&lt;T_X.k$</h4><p><img src="./less.png" alt=""></p>
<p><img src="./less2.png" alt=""></p>
<p>同理分析即可</p>
<h4 id="3-斜率相等"><a href="#3-斜率相等" class="headerlink" title="(3)斜率相等"></a>(3)斜率相等</h4><p>显然是要截距大的啊, 是吧</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>这个操作将长度为$n$的线段, 分成了$\log n$段去更新, 复杂度为$O(\log n)$</p>
<p>对于每一个$O(\log n)$的区间, 我们有花费$O(\log n)$的时间往下更新</p>
<p>故插入的时间复杂度大约为$O(\log^2n)$</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>就得到包含$x$的所有区间的中值</p>
<p>那么这样的区间有多少呢?</p>
<blockquote>
<p>口胡开始了, 假设这个点为$P$, 他左边有$X$个节点, 那么右边就有$N-X-1$个节点, 那么左端点的个数就有$X$个, 右端点就有$N-X-1$个</p>
<p>乘法原理, 求和算期望, 就可以了</p>
</blockquote>
<p>!#%!$%!@:%&gt;!”$%!@#%!@$!”@&gt;%3!@#&gt;%#&gt;:&gt;”1”</p>
<p>$Fake$了啊</p>
<p>这棵树一共就才多少节点, 一共就只有多少层 ?</p>
<p>$\log n$?</p>
<p>差不多, $\log n$跑一次就可以出答案了</p>
<p>快乐水过了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> X, Y;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Xf</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">Yf</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> X, Y, G;</span><br><span class="line">&#125;Points[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">0</span>)</span>, Temp</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp = <span class="built_in">sqrt</span>((X - Points[i].X) * (X - Points[i].X) + (Y - Points[i].Y) * (Y - Points[i].Y));</span><br><span class="line">        <span class="keyword">if</span> (!Temp) <span class="keyword">continue</span>;</span><br><span class="line">        x += Points[i].G / Temp * (Points[i].X - X);</span><br><span class="line">        y += Points[i].G / Temp * (Points[i].Y - Y);</span><br><span class="line">    &#125;</span><br><span class="line">    Temp = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    Y += M / Temp * y;</span><br><span class="line">    X += M / Temp * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d&quot;</span>, &amp;Points[i].X, &amp;Points[i].Y, &amp;Points[i].G);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> M = <span class="number">10000</span>, tx, ty;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = X, ty = Y;</span><br><span class="line">        <span class="built_in">Solve</span>(M);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tx - X) &lt; <span class="number">0.00001</span> &amp;&amp; <span class="built_in">abs</span>(ty - Y) &lt; <span class="number">0.00001</span>) <span class="keyword">break</span>;</span><br><span class="line">        M *= <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.3lf %.3lf\n&quot;</span>, X, Y);</span><br><span class="line">    <span class="built_in">system</span> (<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/AlanTuringLi/2020/08/19/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><p>简单的说是用来求数论函数的前缀和，时间复杂度低于线性时间复杂度</p>
<p>如求：$S(n)=\sum_{i=1}^nf(i)$</p>
<p>常规思路，构造类似数论分块的玩意儿$S(\lfloor\frac ni\rfloor)$，就这个</p>
<p>先构造函数$g$，考虑用迪利克雷卷积先乱搞一下</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n\sum_{d|n}g(d)f(\frac id)&=\sum_{i=1}g(i)S(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^ng(i)\sum_{j=1}^{\lfloor\frac ni\rfloor}f(j)\\
&=\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac ni\rfloor\\}g(i)f(j) \\
\text{令:  i * j = d}\\
&=\sum_{d=1}^n\sum_{i|d}^ng(i)f(\frac di)\qquad\text{证毕!!}
\\\Leftrightarrow\sum_{i=1}^n(f*g)(i)&=\sum_{i=1}g(i)S(\lfloor\frac ni\rfloor)\\
\end{align*}</script><p>那么就可以有：</p>
<script type="math/tex; mode=display">
g(1)S(n)=\sum(f*g)(i)-\sum_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)</script><p>嗯嗯，这个就可以数论分块乱搞了</p>
<p>来，看个实例</p>
<h1 id="P4213-【模板】杜教筛（Sum"><a href="#P4213-【模板】杜教筛（Sum" class="headerlink" title="P4213 【模板】杜教筛（Sum)"></a><a href="https://www.luogu.com.cn/problem/P4213">P4213 【模板】杜教筛（Sum)</a></h1><p>求</p>
<script type="math/tex; mode=display">
S_1 = \sum_{i=1}^n\varphi(i)\\
S_2 = \sum_{i=1}^n\mu(i)</script><p>先来看看第一问：</p>
<p>首先，我们知道$\mu*1=id$，这个应该是很好证明的，<del>反正我不会</del></p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\varphi(d)=\sum_{i=1}^nS_1(\lfloor\frac ni\rfloor)\\
\begin{align*}
\therefore S_1&=\sum_{i=1}^n(\varphi*1)(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^ni-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)
\end{align*}</script><p>来，再看看第二问：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\mu(d)=\sum S_2(\lfloor\frac ni\rfloor)\\
\begin{align*}
\therefore S_2&=\sum_{i=1}^n(\mu*1)(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^n\epsilon(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=1-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)
\end{align*}</script><p>这个推出来了，问题就变得十分的简单了</p>
<p>但是我们又发现了一个更大的问题：数组开不下</p>
<p>怎么办？</p>
<p>我们发现问题是离散的，并不是连续的</p>
<p>那么我们就可以用$map$之类的好工具</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; Mu;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>, ll&gt; Phi;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e6</span>;</span><br><span class="line"><span class="type">int</span> T, A, B;</span><br><span class="line"><span class="type">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="type">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line">ll phi[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i], phi[i * P[j]] = phi[i] * phi[P[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * P[j]] = phi[i] * P[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PPhi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span> (Phi[x]) <span class="keyword">return</span> Phi[x];</span><br><span class="line">    ll Ans = <span class="number">1ll</span> * x * (x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">PPhi</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Phi[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MMu</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">MMu</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%lld %d\n&quot;</span>, <span class="built_in">PPhi</span>(A), <span class="built_in">MMu</span>(A));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>前缀和</tag>
        <tag>学习笔记</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/AlanTuringLi/2020/09/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="一维树状数组"><a href="#一维树状数组" class="headerlink" title="一维树状数组"></a>一维树状数组</h1><p>这是一个单次修改、查询都为$O(\log n)$的数据结构，空间复杂度为 $O(n)$</p>
<p>当然有时候还是会用一些辅助数组的</p>
<h2 id="树状数组-1-：单点修改，区间查询"><a href="#树状数组-1-：单点修改，区间查询" class="headerlink" title="树状数组 1 ：单点修改，区间查询"></a><a href="https://loj.ac/problem/130">树状数组 1 ：单点修改，区间查询</a></h2><p>有这样一个区间查询，首先想到的就是用左右端点的前缀和做差去维护</p>
<p>那么对于裸的前缀和，一次修改操作的时间复杂度为$O(n)$</p>
<p>所以想到用数据结构乱搞一下</p>
<p>那么就是用树状数组去维护，具体就不细说了，直接上代码</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll t[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        d[x] += val * temp;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x] * (temp + <span class="number">1</span>) - d[x];</span><br><span class="line">        x ^= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x = __read();</span><br><span class="line">        <span class="built_in">Update</span>(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            ll k = __read();</span><br><span class="line">            <span class="built_in">Update</span>(l, k);</span><br><span class="line">            <span class="built_in">Update</span>(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(r) - <span class="built_in">Query</span>(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组-2-：区间修改，单点查询"><a href="#树状数组-2-：区间修改，单点查询" class="headerlink" title="树状数组 2 ：区间修改，单点查询"></a><a href="https://loj.ac/problem/131">树状数组 2 ：区间修改，单点查询</a></h2><p>考虑维护一个差分序列</p>
<p>那么这个数的差分序列的前缀和就是这个数</p>
<p>如果对区间$[l,r]$整体修改，即$a[l]-a[l-1]$与$a[r+1]-a[r]$的值发生了改变</p>
<p>即我们只需要去修改$cf[l]$和$cf[r+1]$的权值</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read() &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x ^= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = __read();</span><br><span class="line">        <span class="built_in">Update</span>(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt = __read(), l = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> r = __read(), k = __read();</span><br><span class="line">            <span class="built_in">Update</span>(l, k);</span><br><span class="line">            <span class="built_in">Update</span>(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组-3-：区间修改，区间查询"><a href="#树状数组-3-：区间修改，区间查询" class="headerlink" title="树状数组 3 ：区间修改，区间查询"></a><a href="https://loj.ac/problem/132">树状数组 3 ：区间修改，区间查询</a></h2><p>按照上一个操作的思想，现在得到了差分序列${cf}$</p>
<p>此时要求的是区间$[l,r]$的和</p>
<p>按照差分的写法，就应该是</p>
<script type="math/tex; mode=display">
ans=  \sum_{i=l}^r\sum_{j=1}^icf[j]</script><p>为了方便考虑，那么就可以用$r$的前缀和前去$l-1$的前缀和</p>
<p>那么考虑求$[1,r]$的和</p>
<script type="math/tex; mode=display">
\begin{align*}
 ans&=\sum_{i=1}^r\sum_{j=1}^icf[j]\\
 &=\sum_{i=1}^r(r-i+1)cf[i]\\
 &=(r+1)\sum_{i=1}^rcf[i]-\sum_{i=1}^ri\cdot cf[i]
 \end{align*}</script><p>我们发现，这个似乎变成了两个需要维护的序列，那就写两个呗</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll t[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        d[x] += val * temp;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x] * (temp + <span class="number">1</span>) - d[x];</span><br><span class="line">        x ^= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x = __read();</span><br><span class="line">        <span class="built_in">Update</span>(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            ll k = __read();</span><br><span class="line">            <span class="built_in">Update</span>(l, k);</span><br><span class="line">            <span class="built_in">Update</span>(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(r) - <span class="built_in">Query</span>(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h1><p>这个和一维树状数组的思路大致相同，但是每次修改、查询的复杂度都是$O(\log_2n\times\log_2m)$</p>
<h2 id="二维树状数组-1：单点修改，区间查询"><a href="#二维树状数组-1：单点修改，区间查询" class="headerlink" title=" 二维树状数组 1：单点修改，区间查询"></a><a href="https://loj.ac/problem/133"> 二维树状数组 1：单点修改，区间查询</a></h2><p>直接维护二维前缀和，简单容斥一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, opt;</span><br><span class="line">ll t[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">            t[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i ^= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j; j ^= <span class="built_in">lowbit</span>(j))</span><br><span class="line">            ans += t[i][j];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read(), x = __read();</span><br><span class="line">            <span class="built_in">Update</span>(a, b, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read(), c = __read(), d = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(c, d) + <span class="built_in">Query</span>(a - <span class="number">1</span>, b - <span class="number">1</span>) - <span class="built_in">Query</span>(a - <span class="number">1</span>, d) - <span class="built_in">Query</span>(c, b - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维树状数组-2：区间修改，单点查询"><a href="#二维树状数组-2：区间修改，单点查询" class="headerlink" title="二维树状数组 2：区间修改，单点查询"></a><a href="https://loj.ac/problem/134">二维树状数组 2：区间修改，单点查询</a></h2><p>简单地说，维护二维差分序列可以做到区间修改，直接二维前缀和就是一个单点查询</p>
<p>考虑如何去构造差分序列</p>
<p>对于每一维，可以有$cf[i][j]=a[i][j]-a[i][j-1]$或$cf[i][j]=a[i][j]-a[i-1][j]$</p>
<p>确实，这个可以把两维分开，看成$n$个一维的，但是下面还有区间修改区间查询的</p>
<p>所以这里要说的显然不是一维的做法</p>
<p>考虑合并行和列的差分序列后，与二维前缀和的关系</p>
<p>容易发现：</p>
<script type="math/tex; mode=display">
\begin{align*}
a[x][y]&=\sum_{i=1}^x\sum_{j=1}^ycf[i][j]\\
a[x-1][y]&=\sum_{i=1}^{x-1}\sum_{j=1}^ycf[i][j]\\
a[x][y-1]&=\sum_{i=1}^x\sum_{j=1}^{y-1}cf[i][j]\\
a[x-1][y-1]&=\sum_{i=1}^{x-1}\sum_{j=1}^{y-1}cf[i][j]
\end{align*}</script><p>那么就可以轻松的得到$cf[x][y]=a[x][y]-a[x-1][y]-a[x][y-1]+a[x-1][y-1]$了</p>
<p>就是说现在已经构造出了二维前缀和等于该点原本的值的差分序列了</p>
<p>考虑如何区间修改呢</p>
<p>这得画图</p>
<p><a href="https://imgchr.com/i/wXbyct"><img src="https://s1.ax1x.com/2020/09/23/wXbyct.png" alt="wXbyct.png" border="0" /></a></p>
<p>那么蓝色矩形就是需要修改的矩形，按照差分数组的定义，差分序列发生改变了的点就是图中四个绿色的小矩形，就可以直接改了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, opt;</span><br><span class="line">ll t[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">            t[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i ^= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j; j ^= <span class="built_in">lowbit</span>(j))</span><br><span class="line">            ans += t[i][j];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read(), c = __read(), d = __read(), x = __read();</span><br><span class="line">            <span class="built_in">Update</span>(a, b, x);</span><br><span class="line">            <span class="built_in">Update</span>(a, d + <span class="number">1</span>, -x);</span><br><span class="line">            <span class="built_in">Update</span>(c + <span class="number">1</span>, b, -x);</span><br><span class="line">            <span class="built_in">Update</span>(c + <span class="number">1</span>, d + <span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维树状数组-3：区间修改，区间查询"><a href="#二维树状数组-3：区间修改，区间查询" class="headerlink" title="二维树状数组 3：区间修改，区间查询"></a><a href="https://loj.ac/problem/135">二维树状数组 3：区间修改，区间查询</a></h2><p>这个就是继承了<strong>二维树状数组2</strong>和<strong>树状数组3</strong>的思想了</p>
<p>现在得到了二维差分序列，需要求的确实这样一个东西</p>
<script type="math/tex; mode=display">
ans=\sum_{x=xl}^{xr}\sum_{y=yl}^{yr}\sum_{i=1}^x\sum_{j=1}^ycf[i][j]</script><p>丑死了。。。</p>
<p>还是直接考虑简单容斥，那就只剩下一个二维前缀和了</p>
<script type="math/tex; mode=display">
\begin{align*}
ans&=\sum_{x=1}^{xr}\sum_{y=1}^{yr}\sum_{i=1}^x\sum_{j=1}^ycf[i][j]\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x-i+1)*(y-j+1)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(xy-xj+x-iy+ij-i+y-j+1)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*((xy+x+y+1)-(xj-j)-(iy-i)+ij)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*\big((x+1)(y+1)-(x+1)j-(y+1)i+ij\big)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x+y)(y+1)-\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x+1)*j-\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(y+1)*i+\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*ij\\
&=(x+y)(y+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]-(x+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*j-(y+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*i+\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*ij\\
\end{align*}</script><p>所以分别要维护的就是$cf[i][j], cf[i][j]<em>j, cf[i][j]</em>i, cf[i][j]*ij$四个数组了</p>
<p>嗯~ o(<em>￣▽￣</em>)o，就可以愉快的跑路走人了</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, opt;</span><br><span class="line">ll t[<span class="number">4</span>][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">lowbit</span>(j)) &#123;</span><br><span class="line">            t[<span class="number">0</span>][i][j] += val;</span><br><span class="line">            t[<span class="number">1</span>][i][j] += val * y;</span><br><span class="line">            t[<span class="number">2</span>][i][j] += val * x;</span><br><span class="line">            t[<span class="number">3</span>][i][j] += val * x * y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i ^= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j; j ^= <span class="built_in">lowbit</span>(j))</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">k</span>(<span class="number">0</span>); k &lt; <span class="number">4</span>; ++k) </span><br><span class="line">                ans[k] += t[k][i][j];</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">1</span>) * (y + <span class="number">1</span>) * ans[<span class="number">0</span>] - (x + <span class="number">1</span>) * ans[<span class="number">1</span>] - (y + <span class="number">1</span>) * ans[<span class="number">2</span>] + ans[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read(), c = __read(), d = __read(), x = __read();</span><br><span class="line">            <span class="built_in">Update</span>(a, b, x);</span><br><span class="line">            <span class="built_in">Update</span>(a, d + <span class="number">1</span>, -x);</span><br><span class="line">            <span class="built_in">Update</span>(c + <span class="number">1</span>, b, -x);</span><br><span class="line">            <span class="built_in">Update</span>(c + <span class="number">1</span>, d + <span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> a = __read(), b = __read(), c = __read(), d = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(c, d) - <span class="built_in">Query</span>(a - <span class="number">1</span>, d) - <span class="built_in">Query</span>(c, b - <span class="number">1</span>) + <span class="built_in">Query</span>(a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷十月月赛--第二场</title>
    <url>/AlanTuringLi/2020/10/18/%E6%B4%9B%E8%B0%B7%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9B-%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是问你在一个有 $n$ 个点的完全图中，从一个点出发，最多能不重复经过多少条边</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>如果 $n$ 是奇数，那么完全图中的所有边都可以访问一次，个数为 $\dbinom n2$</li>
<li>如果 $n$ 是偶数，那么就有一些访问不了了，先给结论，可以访问的最多有 $\frac {n(n-2)}2+1$</li>
</ul>
<p>如果是奇数个点，所有点的度数均为偶数，显然是可以走完所有的边的，很显然乱走都可以</p>
<p>如果是奇数个点，就没有那么容易了，为了能让尽量多的边被访问到，那它应该尽量多走，直到不能再走了</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>首先，对于一张完全图，它的所有的点是等价的，所以对于个数一定的点集的选法，无论怎么选，它们的拓扑结构都是相同的，即方案唯一</p>
<ul>
<li>对于奇数个点，随机选一个点为起点，那么对于这个点的访问一定是 <code>出、入 。。。。。。 出、入</code> ；那么其他点的访问一定是都是 <code>入、出。。。。。。入、出</code> 。即对于起点，每次离开它，都一定会有一点边等着它回来，那它总有一次就出不去了；对于不是起点的点，每次进入它，都一定会有一条边等着它出去，那总有一次，他就进不去了。</li>
<li>对于偶数个点，先让所有的点度数都为 $n-2$，那它最后一定会回到起点，此时，起点只有一条边可以走了，它最后走的那条边也是这条边对应的点的最后一条边，就真的走不动了</li>
</ul>
<p>虽然题看上去不难，但是个人水平低下，需要复习复习基础，见谅</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n * (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((n - <span class="number">1</span>) * <span class="number">2</span> + (n - <span class="number">2</span>) * (n - <span class="number">2</span>)) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>等杨巨把我讲懂了我再来补</p>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>等题解出来了再来补</p>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\times b$ 的矩形（ 即能够从 $(x,y)$ 到达 $(x\pm a,y\pm b)$ 或 $(x\pm b,y\pm a)$ ）。</p>
<p>若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。</p>
<p>给你 $T$ 组询问，每组给你一个 $n$，让你求：</p>
<script type="math/tex; mode=display">
\left(\sum_{a=1}^n\sum_{b=1}^np(a,b)\right)\mod {2^{64}}</script><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先，本质不同的行走方案有四种，即 $(a,b),(b,a),(-a,b),(-b,a)$，那么设这四种本质不同的分别走了 $x_1,x_2,x_3,x_4$ 次，那么能够走满这个棋盘的充要条件是：</p>
<script type="math/tex; mode=display">
\begin{cases}
ax_1+bx_2-ax_3-bx_4=1\\
bx_1+ax_2+bx_3+ax_4=0
\end{cases}</script><p>只要满足了这个条件，它就可以上下左右移动了，就是说可以走满整张棋盘</p>
<p>那么可以化简一下上式，然后得到：</p>
<script type="math/tex; mode=display">
a((x_1+x_2)-(x_3-x_4))+b((x_1+x_2)+(x_3-x_4))=1\\
\Rightarrow a(x-y)+b(x+y)=1</script><p>那么此时可以得到两条性质：</p>
<ul>
<li>$a\perp b$</li>
<li>$a\not\equiv b\pmod 2$</li>
</ul>
<p>第一条的话，就是因为 $akx+bky=k\gcd(a,b)$；第二个的话，就是说 $x-y$ 和 $x+y$ 一定是奇偶性相同的而且只能是奇数，那么 $a、b$ 一定一奇一偶，正确性显然</p>
<p>所以可以得到 $p(a,b)=[a\perp b \land a、b奇偶性不相同]$</p>
<h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>既然已经知道了 $a、b$ 奇偶性不同，那么就可以限制谁是奇数谁是偶数，最后 $\times2$ 就可以</p>
<p>时间复杂度 $O(n^2)$，期望得分 $20$ </p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j += <span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) ++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>根据算法一，我们知道题目限制了两个数的奇偶性，那么我们先试着表达一下，再看看可以怎么化简</p>
<script type="math/tex; mode=display">
\sum_{a=1}^n\sum_{b=1}^np(a,b)=2\times\sum_{a=1}^n\sum_{b=1}^n[a\perp b且a为偶数b为奇数]\\</script><p>又因为 $a\perp b$ 且 $a$ 是偶数 $b$ 是奇数，那么 $a\rightarrow \frac a2$，也是可以得到 $a\perp b$ 的</p>
<p>所以又得到了</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{a=1}^n\sum_{b=1}^n[a\perp b且a为偶数b为奇数]&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b且b为奇数]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b且b是偶数]
\end{aligned}</script><p>感觉这个容斥还是很好想到的，那么就可以继续往下走，定义记号 $f(n,m)$ </p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b且a为偶数b为奇数]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b且b是偶数]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b且a是奇数b是偶数]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-f(m,\frac n2)
\end{aligned}</script><p>为了方便表述，就令</p>
<script type="math/tex; mode=display">
\begin{aligned}
s(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b]\\
&=\sum_{a=1}^n\sum_{b=1}^m\sum_{d|\gcd(a,b)}\mu(d)\\
&=\sum_{d=1}^{\min(a,b)}\mu(d)\left\lfloor\frac nd\right\rfloor\left\lfloor\frac md\right\rfloor
\end{aligned}</script><p>所以 $f(n,m)=s(\frac n2,m)-f(m,\frac n2)$</p>
<p>然后 $s$ 的计算可以数论分块，$f$ 递归计算，所以时间复杂度为 $O(\log n\sqrt n)$</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, t, cnt;</span><br><span class="line">ll mu[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        sum += (mu[r] - mu[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gc</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m / <span class="number">2</span>;</span><br><span class="line">    ll total = <span class="built_in">solve</span>(n, m / <span class="number">2</span>), cut = <span class="built_in">gc</span>(m / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> total - cut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ll total = <span class="built_in">solve</span>(n / <span class="number">2</span>, n), cut = <span class="built_in">gc</span>(n / <span class="number">2</span>, n);</span><br><span class="line">        ll ans = (total - cut) * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="满分做法"><a href="#满分做法" class="headerlink" title="满分做法"></a>满分做法</h2><p>算法二的瓶颈在于空间，开不了 $10^{11}$ 的数组，所以考虑使用杜教筛或者 $\text{Min_25}$ 筛啥的，就可以过题了</p>
<p>至于这个的时间复杂的的话，个人感觉是 $O(\log n\sqrt n+n^{\frac 32})$，不知道对不对</p>
<p>希望有大佬能告诉我正确的时间复杂的</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line">ll n, t, cnt;</span><br><span class="line">ull mu[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map &lt;ll, ull&gt; Mu;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">MMu</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">MMu</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ll n, ll m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ull <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        sum += (<span class="built_in">MMu</span>(r) - <span class="built_in">MMu</span>(l - <span class="number">1</span>)) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">gc</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ull total = <span class="built_in">solve</span>(n / <span class="number">2</span>, m), cut = <span class="built_in">gc</span>(m, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> total - cut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    t = __read();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        ull ans = <span class="built_in">gc</span>(n, n) * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>分块</tag>
        <tag>鸽~</tag>
        <tag>图论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/AlanTuringLi/2020/06/24/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1> <video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">
      <source id="mp4" src="http://media.w3.org/2010/05/sintel/trailer.mp4" type="video/mp4">
      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">
      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg">
      <p>Your user agent does not support the HTML5 Video element.</p>
    </video>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;http://media.w3.org/2010/05/sintel/poster.png&quot;</span>&gt;</span>//poster是封面</span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">&quot;mp4&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://media.w3.org/2010/05/sintel/trailer.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span>//id为支持的视频的格式</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your user agent does not support the HTML5 Video element.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1374056689&auto=0&height=66"></iframe>

<p><img src="music.png" alt=""></p>
<p><img src="music2.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=1374056689&amp;auto=0&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h1><iframe class="bilibili"src="//player.bilibili.com/player.html?aid=73773499&cid=146795963&page=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">&quot;bilibili&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=73773499&amp;cid=146795963&amp;page=1&amp;high_quality=1&amp;danmaku=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改地址应该就可以了?</p>
<h1 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-pdf --save</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="Problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%pdf Problem.pdf%&#125;</span><br></pre></td></tr></table></figure>
<p>pdf 后面是跟的相对路径</p>
<hr>
<h1 id="文章内容折叠"><a href="#文章内容折叠" class="headerlink" title="文章内容折叠"></a>文章内容折叠</h1><h2 id="hexo-sliding-spoiler插件"><a href="#hexo-sliding-spoiler插件" class="headerlink" title="hexo-sliding-spoiler插件"></a>hexo-sliding-spoiler插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-sliding-spoiler --save</span><br></pre></td></tr></table></figure>
<h2 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h2><p><strong>1.</strong>默认是 <code>Show: .../ Hide: ...</code>，我们可以更改前面的字。</p>
<p><strong>2.</strong>打开文件<code>F:\OI\Blog\hexo\node_modules\_hexo-sliding-spoiler@1.2.1@hexo-sliding-spoiler\assets\spoiler.css</code>，大概25-31行？修改其中的<code>content</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.collapsed</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;Show: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.expanded</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;Hide: &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% spoiler &quot;隐藏内容的标题&quot; %&#125;</span><br><span class="line"></span><br><span class="line">隐藏文字隐藏文字隐藏文字。  </span><br><span class="line">支持 <span class="code">`markdown`</span> 语法</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 支持 <span class="strong">**粗体**</span>、<span class="emphasis">*斜体*</span></span><br><span class="line"><span class="bullet">-</span> 支持列表</span><br><span class="line"><span class="bullet">-</span> 支持md插入图片语法</span><br><span class="line"><span class="bullet">-</span> 支持html插入图片语法</span><br><span class="line"><span class="bullet">-</span> 支持行内代码 <span class="code">`markdown`</span></span><br><span class="line"><span class="bullet">-</span> 支持代码块</span><br><span class="line">  </span><br><span class="line"><span class="code">    ```cpp</span></span><br><span class="line"><span class="code">    #include &lt;initializer_list&gt;</span></span><br><span class="line"><span class="code">    #include &lt;iostream&gt;</span></span><br><span class="line"><span class="code">    struct A &#123;</span></span><br><span class="line"><span class="code">        A() &#123; std::cout &lt;&lt; &quot;1&quot;; &#125;</span></span><br><span class="line"><span class="code">        A(int) &#123; std::cout &lt;&lt; &quot;2&quot;; &#125;</span></span><br><span class="line"><span class="code">        A(std::initializer_list&lt;int&gt;) &#123; std::cout &lt;&lt; &quot;3&quot;; &#125;</span></span><br><span class="line"><span class="code">    &#125;;</span></span><br><span class="line"><span class="code">    int main(int argc, char *argv[]) &#123;</span></span><br><span class="line"><span class="code">        A a1;</span></span><br><span class="line"><span class="code">        A a2&#123;&#125;;</span></span><br><span class="line"><span class="code">        A a3&#123; 1 &#125;;</span></span><br><span class="line"><span class="code">        A a4&#123; 1, 2 &#125;;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    ```// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 支持表格</span><br><span class="line"></span><br><span class="line"><span class="code">    | 文字 | 文字 |</span></span><br><span class="line"><span class="code">    | ----------- | ----------- |</span></span><br><span class="line"><span class="code">    | 文字 | 文字 |</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#123;% endspoiler %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        隐藏内容的标题
    </div>
    <div class='spoiler-content'>
        <p>隐藏文字隐藏文字隐藏文字。<br>支持 <code>markdown</code> 语法</p>
<ul>
<li><p>支持 <strong>粗体</strong>、<em>斜体</em></p>
</li>
<li><p>支持列表</p>
</li>
<li><p>支持md插入图片语法</p>
</li>
<li><p>支持html插入图片语法</p>
</li>
<li><p>支持行内代码 <code>markdown</code></p>
</li>
<li><p>支持代码块</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(std::initializer_list&lt;<span class="type">int</span>&gt;) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">​```<span class="comment">// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>支持表格</p>
<p>  | 文字 | 文字 |<br>  | —— | —— |<br>  | 文字 | 文字 |</p>
<p>  事实证明不支持表格？</p>
</li>
</ul>

    </div>
</div><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>其他板子</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/AlanTuringLi/2020/09/06/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成函数简介"><a href="#生成函数简介" class="headerlink" title="生成函数简介"></a>生成函数简介</h1><p>生成函数（$\text{generating function}$），又称母函数，是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。</p>
<p>生成函数有许多不同的种类，但大多可以表示为单一的形式：</p>
<script type="math/tex; mode=display">
F(x)=\sum_na_nk_n(x)</script><p>其中$k_n(x)$被称为核函数。不同的核函数会导出不同的生成函数，拥有不同的性质。举个例子：</p>
<ul>
<li><p>普通生成函数： $k_n(x)=x^n$</p>
</li>
<li><p>指数生成函数： $k_n(x)=\frac{x^n}{n!}$</p>
</li>
<li><p>狄利克雷生成函数： $k_n(x)=\frac1{n^x}$</p>
</li>
</ul>
<p>另外，对于生成函数$F(x)$，我们用$[k_n(x)]F(x)$来表示它的第$n$项的核函数对应的系数，也就是$a_n$。</p>
<h1 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h1><p>序列$a$的普通生成函数（$\text{ordinary generating function，OGF}$）定义为形式幂级数：</p>
<script type="math/tex; mode=display">
F(x)=\sum_na_nx^n</script><p> $a$既可以是有穷序列，也可以是无穷序列。常见的例子（假设$a$以$0$为起点）：</p>
<ul>
<li>序列$a=\langle1,2,3\rangle$的普通生成函数是$1+2x+3x^2$</li>
<li>序列$a=\langle1,1,1,\cdots\rangle$的普通生成函数是$\sum_{n\ge0}x^n$</li>
<li>序列$a=\langle1,2,4,8,16,\cdots\rangle$的生成函数是$\sum_{n\ge 0}2^nx^n$</li>
<li>序列$a=\langle1,3,5,7,9,\cdots\rangle$的生成函数是$\sum_{n\ge0}(2n+1)x^n$</li>
</ul>
<p>换句话说，如果序列$a$有通项公式，那么它的普通生成函数的系数就是通项公式。</p>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>考虑两个序列$a,b$的普通生成函数，分别为$F(x),G(x)$。那么有：</p>
<script type="math/tex; mode=display">
F(x)\pm G(x)=\sum_n(a_n+b_n)x^n</script><p>因此$F(x)\pm G(x)$是序列$\langle a_n+b_n\rangle$的普通生成函数。</p>
<p>考虑乘法运算，也就是卷积：</p>
<script type="math/tex; mode=display">
F(x)G(x)=\sum_nx^n\sum_{i=0}^na_ib_{n-i}</script><p>因此$F(x)G(x)$是序列</p>
<script type="math/tex; mode=display">
\langle\sum_{i=0}^na_ib_{n-i}\rangle</script><p>的普通生成函数。</p>
<h2 id="封闭形式"><a href="#封闭形式" class="headerlink" title="封闭形式"></a>封闭形式</h2><p>在运用生成函数的过程中，我们不会一直使用形式幂级数的形式，而会适时地转化为封闭形式以更好地化简。</p>
<p>例如：$\langle1,1,1,\cdots\rangle$的普通生成函数$F(x)=\sum_{n\ge0}x^n$，我们可以发现：</p>
<script type="math/tex; mode=display">
F(x)x+1=F(x)</script><p>那么解这个方程得到：</p>
<script type="math/tex; mode=display">
F(x)=\frac1{1-x}</script><p> 这就是$\sum_{n\ge0}x^n$的封闭形式。</p>
<p>证明的话就先鸽着</p>
<p>考虑等比数列$\langle1,p,p^2,p^3,p^4,\cdots\rangle$的生成函数$F(x)=\sum_{n\ge0}p^nx^n$，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
F(x)px+1&=F(x)
\\F(x)&=\frac1{1-px}
\end{align*}</script><p>等比数列的封闭形式与展开形式是常用的变换手段。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        小练习
    </div>
    <div class='spoiler-content'>
        <p>请求出下列数列的普通生成函数（形式幂级数形式和封闭形式）。难度的循序渐进的。</p>
<ol>
<li><p>$a=\langle0,1,1,1,1,\cdots\rangle$</p>
</li>
<li><p>$a=\langle1,0,1,0,1,\cdots\rangle$</p>
</li>
<li><p>$a=\langle1,2,3,4,5,\cdots\rangle$</p>
</li>
<li><p>$a_n=\dbinom{m}{n}\;(m是常数，n\ge0)$</p>
</li>
<li><p>$a_n=\dbinom{m+n}{n}$</p>
</li>
</ol>
<p><a href="https://oi-wiki.org/math/gen-func/ogf/"><strong>答案</strong></a></p>

    </div>
</div>
<h2 id="斐波那契数列的生成函数"><a href="#斐波那契数列的生成函数" class="headerlink" title="斐波那契数列的生成函数"></a>斐波那契数列的生成函数</h2><p>接下来我们来推导斐波那契数列的生成函数。</p>
<p>斐波那契数列定义为:</p>
<script type="math/tex; mode=display">
a_0=0,a_1=1,a_n=a_{n-1}+a_{n-2}(n>1)</script><p>设它的普通生成函数是$F(x)$，那么根据它的递推式，我们可以类似地列出关于$F(x)$的方程：</p>
<script type="math/tex; mode=display">
F(x)=xF(x)+x^2F(x)-a_0x+a_1x+a_0</script><p>那么解的：</p>
<script type="math/tex; mode=display">
F(x)=\frac x{1-x-x^2}</script><p>接下来的问题是，如何求出他的展开形式？</p>
<h3 id="展开方式一"><a href="#展开方式一" class="headerlink" title="展开方式一"></a>展开方式一</h3><p>不妨将$x+x^2$当作为一个整体，那么可以得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
F(x)&=\frac x{1-(x+x^2)}
\\&=\sum_{n\ge0}(x+x^2)^n
\\&=\sum_{n\ge0}\sum_{i=0}^n\dbinom{n}{i}x^{2i}x^{n-i}
\\&=\sum_{n\ge0}\sum_{i=0}^n\dbinom{n}{i}x^{n+i}
\\&=\sum_{n\ge0}x^n\sum_{i=0}^n\dbinom{n-i}{i}
\end{align*}</script><p>我们得到了$a_n$的通项公式，但那并不是我们熟知的有关黄金分割比的形式。</p>
<h3 id="展开方式二"><a href="#展开方式二" class="headerlink" title="展开方式二"></a>展开方式二</h3><p>考虑求解一个待定系数的方程：</p>
<script type="math/tex; mode=display">
\frac A{1-ax}+\frac B{1-bx}=\frac x{1-x-x^2}</script><p>通分得到：</p>
<script type="math/tex; mode=display">
\frac {A-Abx+B-aBx}{(1-ax)(1-bx)}=\frac x{1-x-x^2}</script><p>待定项系数相等，我们得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
A+B=0\\
-Ab-aB=1\\
a+b=1
ab=-1
\end{cases}</script><p>解得：</p>
<script type="math/tex; mode=display">
\begin{cases}
A=\frac1{\sqrt5}\\
B=-\frac1{\sqrt5}\\
a=\frac{1+\sqrt5}2\\
b=\frac{1-\sqrt5}2\\
\end{cases}</script><p>那么我们根据等比数列的展开式，就可以得到斐波那契数列的通项公式：</p>
<script type="math/tex; mode=display">
\frac x{1-x-x^2}=\sum_{n\ge0}x^n\frac 1{\sqrt5}\left(\left(\dfrac{1+\sqrt5}2\right)^n-\left(\dfrac{1-\sqrt5}2\right)^n\right)</script><p>这也被称为斐波那契数列的另一个封闭形式（$\frac x{1-x-x^2}$ 是一个封闭形式）。</p>
<p>对于任意多项式 $P(x), Q(x)$，生成函数$\frac{P(X)}{Q(x)}$的展开式都可以使用上述方法求出。在实际运用的过程中，我们往往先求出$Q(x)$的根，把分母表示为$\prod(1-p_ix)^{d_i}$的形式，然后再求分子。</p>
<h2 id="鸽"><a href="#鸽" class="headerlink" title="鸽~"></a>鸽~</h2><p>牛顿二项式定理、卡特兰数的生成函数先鸽一鸽</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>鸽~</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>电学复习</title>
    <url>/AlanTuringLi/2021/02/04/%E7%94%B5%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="电场部分"><a href="#电场部分" class="headerlink" title="电场部分"></a>电场部分</h2><script type="math/tex; mode=display">
E=\frac Fq\qquad E=k\frac Q{r^2}\qquad矢量\\
\varphi=\frac {E_p}q\qquad\varphi=k\frac Qr\qquad 标量\\
\frac {\mathrm d\varphi}{\mathrm dr}=-k\frac Q{r^2}=-E
\\
k=\frac 1{4\pi\varepsilon_0}\;\;k'=\frac 1{4\pi\varepsilon_0\varepsilon_r}=\frac 1{4\pi\varepsilon}</script><h2 id="闭合电路欧姆定律"><a href="#闭合电路欧姆定律" class="headerlink" title="闭合电路欧姆定律"></a>闭合电路欧姆定律</h2><script type="math/tex; mode=display">
\begin{aligned}
E&=U+Ir=IR+Ir\\
U&=E-Ir
\end{aligned}\\
P_{输出}:R_内=R_外 \Rightarrow P=\frac {E^2}{4r}\\
\text{补充：戴维宁定理，等效一个新电源进行分析}\\
效率\eta=\frac UE=\frac R{R+r}</script><h2 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h2><script type="math/tex; mode=display">
F=BIL\sin\theta\qquad IL:电流元\\
即：\overrightarrow F=\overrightarrow{Il}\times\overrightarrow B\\
\overrightarrow F=q\overrightarrow v\times\overrightarrow B\\
\vec F\perp\vec v\quad \vec F=\vec B\\
qvB=m\frac {v^2}{r}\quad r=\frac {mv}{qB}\\
T=\frac{2\pi m}{qB}</script><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/AlanTuringLi/2022/08/02/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由 $m\times n$  个数 $a_{i,j}(i\in [1,m],j\in[i,n])$ 排成的 $m$ 行 $n$ 列的数表：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
a_{1, 1}&a_{1, 2}&\cdots&a_{1, n}\\
a_{2, 1}&a_{2, 2}&\cdots&a_{2, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m, 1}&a_{m,2}&\cdots&a_{m,n}
\end{pmatrix}</script><p>称为 $m\times n$ 矩阵，记作：</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
a_{1, 1}&a_{1, 2}&\cdots&a_{1, n}\\
a_{2, 1}&a_{2, 2}&\cdots&a_{2, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m, 1}&a_{m,2}&\cdots&a_{m,n}
\end{pmatrix}</script><p>简记为：</p>
<script type="math/tex; mode=display">
A=A_{m\times n}=(a_{ij})_{m\times n}</script><p>通常用大写字母  $A,B, C$ 来表示矩阵。</p>
<blockquote>
<p>元素都是实数的矩阵称为实矩阵；</p>
<p>元素都是复数的矩阵称为复矩阵。</p>
</blockquote>
<h3 id="几种特殊的矩阵"><a href="#几种特殊的矩阵" class="headerlink" title="几种特殊的矩阵"></a>几种特殊的矩阵</h3><h4 id="行矩阵（行向量）"><a href="#行矩阵（行向量）" class="headerlink" title="行矩阵（行向量）"></a>行矩阵（行向量）</h4><p>只有一行的矩阵：</p>
<script type="math/tex; mode=display">
A=(a_1, a_2, \cdots,a_n)</script><h4 id="列矩阵（列向量）"><a href="#列矩阵（列向量）" class="headerlink" title="列矩阵（列向量）"></a>列矩阵（列向量）</h4><p>只有一列的矩阵：</p>
<script type="math/tex; mode=display">
B=
\begin{pmatrix}
a_1\\a_2\\ \vdots \\a_n
\end{pmatrix}</script><h4 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h4><p>元素全为零的矩阵，记作：</p>
<script type="math/tex; mode=display">
0\quad或\quad0_{m\times n}</script><h4 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h4><p>行数与列数都相等的矩阵，记作：</p>
<script type="math/tex; mode=display">
A_n</script><h4 id="上（下）三角形矩阵"><a href="#上（下）三角形矩阵" class="headerlink" title="上（下）三角形矩阵"></a>上（下）三角形矩阵</h4><p>主对角线下（上）方元素全部为零的 $n$ 阶方阵。</p>
<h4 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h4><p>主对角线上不全为零，上下两个三角全为零的矩阵。</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
\lambda_1&0&\cdots&0\\
0&\lambda_2&\cdots&0\\
0&0&\ddots&0\\
0&0&0&\lambda_n
\end{vmatrix}</script><h4 id="单位矩阵（单位阵）"><a href="#单位矩阵（单位阵）" class="headerlink" title="单位矩阵（单位阵）"></a>单位矩阵（单位阵）</h4><script type="math/tex; mode=display">
E=E_n\begin{vmatrix}
1&0&\cdots&0\\
0&1&\cdots&0\\
0&0&\ddots&0\\
0&0&0&1
\end{vmatrix}</script><h4 id="数量矩阵"><a href="#数量矩阵" class="headerlink" title="数量矩阵"></a>数量矩阵</h4><p>主对角线的元素全部相等的对角矩阵：</p>
<script type="math/tex; mode=display">
A=aE=\begin{vmatrix}
a&0&\cdots&0\\
0&a&\cdots&0\\
0&0&\ddots&0\\
0&0&0&a
\end{vmatrix}</script><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>元素关于主对角线对称的方阵，即： </p>
<script type="math/tex; mode=display">
a_{ij}=a_{ji}</script><h4 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h4><p>元素关于主对角线互为相反数的方阵，即：</p>
<script type="math/tex; mode=display">
a_{ij}=-a_{ji}</script><h3 id="同型矩阵与矩阵相等的概念"><a href="#同型矩阵与矩阵相等的概念" class="headerlink" title="同型矩阵与矩阵相等的概念"></a>同型矩阵与矩阵相等的概念</h3><p><strong>同型矩阵</strong> 两个矩阵的行数相等，列数相等。</p>
<p><strong>矩阵相等</strong> 两个矩阵为同型矩阵，并且对应元素相等的两个矩阵。</p>
<h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>设 $A,\;B$ 均为 $m\times n$ 的矩阵，那么：</p>
<script type="math/tex; mode=display">
A=
\begin{pmatrix}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n1}&a_{n2}&\cdots&a_{nn}\\
\end{pmatrix}
\quad
B=
\begin{pmatrix}
b_{11}&b_{12}&\cdots&b_{1n}\\
b_{21}&b_{22}&\cdots&b_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
b_{n1}&b_{n2}&\cdots&b_{nn}\\
\end{pmatrix}\\
A+B=
\begin{pmatrix}
a_{11}+b_{11}&a_{12}+b_{12}&\cdots&a_{1n}+b_{1n}\\
a_{21}+b_{21}&a_{22}+b_{22}&\cdots&a_{2n}+b_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n1}+b_{n1}&a_{n2}+b_{n2}&\cdots&a_{nn}+b_{nn}\\
\end{pmatrix}</script><blockquote>
<p>只有当两个矩阵为同型矩阵时，才能进行加法运算</p>
</blockquote>
<h4 id="运算规律"><a href="#运算规律" class="headerlink" title="运算规律"></a>运算规律</h4><ul>
<li>$A+B=B+A$</li>
<li>$(A+B)+C=A+(B+C)$</li>
<li>$A+0=A$</li>
<li>$A+(-A)=0,A-B=A+(-B)$</li>
</ul>
<blockquote>
<p>其中，若：</p>
<script type="math/tex; mode=display">
A=(a_{ij}),\quad-A=(-a_{ij})</script></blockquote>
<h3 id="矩阵的数乘"><a href="#矩阵的数乘" class="headerlink" title="矩阵的数乘"></a>矩阵的数乘</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">
\lambda A=A\lambda 
=
\begin{pmatrix}
\lambda a_{11}&\lambda a_{12}&\cdots&\lambda a_{1n}\\
\lambda a_{21}&\lambda a_{22}&\cdots&\lambda a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
\lambda a_{n1}&\lambda a_{n2}&\cdots&\lambda a_{nn}\\
\end{pmatrix}</script><h4 id="运算规律-1"><a href="#运算规律-1" class="headerlink" title="运算规律"></a>运算规律</h4><script type="math/tex; mode=display">
1\times A=A\\
(\lambda\mu)A=\lambda(\mu A)\\
(\lambda+\mu)A=\lambda A+\mu A\\
\lambda(A+B)=\lambda A+\lambda B</script><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>设矩阵 $A,\;B$ 的乘积为矩阵 $C$ ，其中 ：</p>
<script type="math/tex; mode=display">
A=(a_{ij})_{m\times s}\quad B=(b_{ij})_{s\times n}\\
C=(c_{ij})_{m\times n}\\
c_{ij} = \sum_{k=1}^sa_{ik}b_{kj}</script><blockquote>
<ul>
<li>可乘条件：前列数 $=$   后行数</li>
<li>乘积类型：前行后列</li>
</ul>
</blockquote>
<h4 id="运算规律-2"><a href="#运算规律-2" class="headerlink" title="运算规律"></a>运算规律</h4><script type="math/tex; mode=display">
(AB)C=A(BC)\\
A(B+C)=AB+AC\\
\lambda(AB)=(\lambda A)B=A(\lambda B)\\
AE=EA=A\\
A0=0,\;0A=0</script><blockquote>
<p>矩阵乘法不满足交换律，即一般情况下 $AB\not= BA$。</p>
<p>两个非零矩阵的乘积可为零矩阵（即矩阵乘法有零因子）。</p>
<p>矩阵乘法不满足消去律。</p>
</blockquote>
<p><strong>结论</strong>：</p>
<ul>
<li>单位矩阵与同阶方阵相乘可换。</li>
<li>数量矩阵与同阶方阵相乘可换。</li>
<li>同阶对角矩阵相乘可换。</li>
</ul>
<h2 id="方阵的幂"><a href="#方阵的幂" class="headerlink" title="方阵的幂"></a>方阵的幂</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>若 $A$ 是 $n$ 阶矩阵：$A^k=\underbrace{AA\cdots A}_k,\quad A^0=E$</p>
<h3 id="运算规律-3"><a href="#运算规律-3" class="headerlink" title="运算规律"></a>运算规律</h3><script type="math/tex; mode=display">
A^mA^k=A^{m+k}\\
{(A^m)}^k=A^{mk}</script><blockquote>
<p>其中 $m,k$ 均为非负整数</p>
</blockquote>
<h3 id="方阵的多项式"><a href="#方阵的多项式" class="headerlink" title="方阵的多项式"></a>方阵的多项式</h3><p>设多项式函数：$f(x)=a_nx^n+\cdots+a_1x+a_0$ ，则有：</p>
<p>$f(A)=a_nA^n+\cdots+a_1A+a_0$</p>
<blockquote>
<p>若 $A,B$  在乘法运算中可以交换，那么：</p>
<script type="math/tex; mode=display">
(AB)^k=A^kB^k\\
(A+B)^2=A^2+2AB+B^2\\
(A+B)(A-B)=A^2-B^2</script></blockquote>
<h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">
A=\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
a_{2, 1}&a_{2, 2}&\dots&a_{2, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m, 1}&a_{m, 2}&\dots&a_{m, n}\\
\end{vmatrix}\quad

A^\tau=\begin{vmatrix}
a_{1, 1}&a_{2, 1}&\dots&a_{m, 1}\\
a_{1, 2}&a_{2, 2}&\dots&a_{m, 2}\\
\vdots&\vdots&\ddots&\vdots\\
a_{1, n}&a_{2, n}&\dots&a_{m, n}\\
\end{vmatrix}\\

A^\tau表示A的转置行列式</script><h3 id="转置矩阵的运算性质"><a href="#转置矩阵的运算性质" class="headerlink" title="转置矩阵的运算性质"></a>转置矩阵的运算性质</h3><script type="math/tex; mode=display">
\begin{align}
&{(A^{\tau})}^\tau=A\\
&(A^\tau+B^\tau)=A^\tau+B^\tau\\
&(\lambda A)^\tau=\lambda A^\tau\\
&(AB)^\tau=A^\tau B^\tau\\
&A为对称矩阵：A^\tau=A\\
&A为反对称矩阵：A^\tau=-A
\end{align}</script><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>设 $A_n$ 为 $n$ 阶方阵，称 $|A_n|$ 为方阵 $A$ 的行列式。记作 $|A|$ 或 $\det(A)$ 。</p>
<h3 id="运算性质"><a href="#运算性质" class="headerlink" title="运算性质"></a>运算性质</h3><script type="math/tex; mode=display">
\begin{align}
&|kA|=k^nA\\
&|AB|=|A||B|\\
&|A^m|=|A|^m\\
&|-A|=(-1)^n|A|\\
&|A^T|=|A|
\end{align}</script><h2 id="方阵的迹"><a href="#方阵的迹" class="headerlink" title="方阵的迹"></a>方阵的迹</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>设 $A$ 为方阵，</p>
<script type="math/tex; mode=display">
A=
\begin{bmatrix}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n1}&a_{n2}&\cdots&a_{nn}
\end{bmatrix}\\
其中\sum_{i=1}^na_{ii} 称为方阵的迹，记作：\\
tr(A)=\sum_{i=1}^na_{ii}</script><h3 id="运算性质-1"><a href="#运算性质-1" class="headerlink" title="运算性质"></a>运算性质</h3><script type="math/tex; mode=display">
\begin{align}
&tr(A^\tau)=tr(A)\\
&tr(A+B)=tr(A)+tr(B)\\
&tr(\lambda A)=\lambda tr(A)\\
&tr(AB)=tr(BA)
\end{align}</script><h2 id="矩阵的共轭"><a href="#矩阵的共轭" class="headerlink" title="矩阵的共轭"></a>矩阵的共轭</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>设 $A$ 为 $m\times n$ 的矩阵，称：</p>
<script type="math/tex; mode=display">
\overline{A}=(\overline{a_{ij}})_{m\times n}</script><p>为矩阵 $A$ 的共轭矩阵。</p>
<h3 id="运算性质-2"><a href="#运算性质-2" class="headerlink" title="运算性质"></a>运算性质</h3><script type="math/tex; mode=display">
\begin{align}
&(\overline{A+B})=\overline{A}+\overline{B}\\
&\overline{\lambda A}=\overline{\lambda}\;\overline{A}\\
&\overline{AB}=\overline{A}\;\overline{B}
\end{align}</script><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数</title>
    <url>/AlanTuringLi/2020/11/14/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="test.pdf" width="100%" height="550" type="application/pdf">
	</div>



<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>联赛Day1</title>
    <url>/AlanTuringLi/2020/10/12/%E8%81%94%E8%B5%9BDay1/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>应该是水的，所有前后缀减重复的应该就可以了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[maxn], t[maxn];</span><br><span class="line"><span class="type">int</span> cnts[<span class="number">26</span>], cntt[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%s %s&quot;</span>, s, t);</span><br><span class="line">	<span class="type">int</span> strs = <span class="built_in">strlen</span>(s), strt = <span class="built_in">strlen</span>(t);</span><br><span class="line">	ll ans = <span class="number">1ll</span> * (strs + <span class="number">1</span>) * (strt + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs; ++i) cnts[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strt; ++i) cntt[t[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) ans -= <span class="number">1ll</span> * cntt[i] * cnts[i];</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>好像还是不太好搞，先跳</p>
<p>可以十分暴力的。。。</p>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>首先贪心的考虑，最后的答案可以写成这样的形式：$r-l+1+len-s$：</p>
<ul>
<li>其中 $r-l+1+len$ 表示把所有的数先删除，再把目标串插回序列</li>
<li>$s$ 表示被重复计算的部分<ul>
<li>可以被替换的数，多计算了一次</li>
<li>原本就相等的数，多计算了两次</li>
</ul>
</li>
</ul>
<p>那么可以定义 $d(i,j)$ 表示从 $S_l$ 开始匹配到 $T_i$ 时，被重复计算的次数为 $j$ 的最小的 $r$ </p>
<p>那么就有转移如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
d(i+1, j)&=\min(d(i+1, j), d(i,j))\\
d(i+1, j+1)&=\min(d(i+1,j+1), d(i,j)+1)\\
d(i+1, j+2)&=\min(d(i+1,j+2), next(i+1,t_{i+1}))\\
\end{aligned}</script><p>怎么理解？</p>
<h4 id="d-i-1-j-min-d-i-1-j-d-i-j"><a href="#d-i-1-j-min-d-i-1-j-d-i-j" class="headerlink" title="$d(i+1,j)=\min(d(i+1,j),d(i,j))$"></a>$d(i+1,j)=\min(d(i+1,j),d(i,j))$</h4><p>就是说没有多的重复计算的部分，那么就是可以没有多的字符来进行有效匹配，就可以直接继承</p>
<h4 id="d-i-1-j-1-min-d-i-1-j-1-d-i-j-1"><a href="#d-i-1-j-1-min-d-i-1-j-1-d-i-j-1" class="headerlink" title="$d(i+1, j+1)=\min(d(i+1,j+1), d(i,j)+1)$"></a>$d(i+1, j+1)=\min(d(i+1,j+1), d(i,j)+1)$</h4><p>多了一次重复计算，那么就是有一个可以被替换的，你用了一次删除和一次插入</p>
<p>那么随便加一个数进去就可以实现</p>
<h4 id="d-i-1-j-2-min-d-i-1-j-2-next-r-t-i-1"><a href="#d-i-1-j-2-min-d-i-1-j-2-next-r-t-i-1" class="headerlink" title="d(i+1, j+2)=\min(d(i+1,j+2), next(r,t_{i+1}))\\"></a><script type="math/tex">d(i+1, j+2)=\min(d(i+1,j+2), next(r,t_{i+1}))\\</script></h4><p>多了两次重复计算，既原本这两个数时匹配的，那么右端点可以直接跳到这个字符的下一个位置</p>
<p>那么最后一定是找到最大的 $s$ 剪掉，得到的答案最小</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> S[maxn], T[maxn];</span><br><span class="line"><span class="type">int</span> nxt[maxn][<span class="number">26</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">26</span>][<span class="number">26</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s %s&quot;</span>, S + <span class="number">1</span>, T + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> lens = <span class="built_in">strlen</span> (S + <span class="number">1</span>), lent = <span class="built_in">strlen</span> (T + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        nxt[lens][i] = lens + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lens; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            nxt[i - <span class="number">1</span>][j] = nxt[i][j];</span><br><span class="line">        nxt[i - <span class="number">1</span>][S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = __read();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> l = __read(), r = __read(), len = r - l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span> (d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>] = l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lent; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= (lent &lt;&lt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">                d[i + <span class="number">1</span>][j] = <span class="built_in">min</span>(d[i + <span class="number">1</span>][j], d[i][j]);</span><br><span class="line">                d[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(d[i + <span class="number">1</span>][j + <span class="number">1</span>], d[i][j] + <span class="number">1</span>);</span><br><span class="line">                d[i + <span class="number">1</span>][j + <span class="number">2</span>] = <span class="built_in">min</span>(d[i + <span class="number">1</span>][j + <span class="number">2</span>], nxt[d[i][j]][T[i + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = lent &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (d[lent][s] &gt; r) s--;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, len + lent - s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>十分阶乘暴力，不管那么多了</p>
<p>然后对于所有点的父节点都是 $1$ 的数据，就可以用康托展开：</p>
<ul>
<li>如果给定的 $a_i=1$，那么就求这个序列的康托展开即可</li>
<li>否则呢就直接是 $(n-1)!$，这个应该还是很好证明的</li>
</ul>
<h2 id="Code-30"><a href="#Code-30" class="headerlink" title="Code(30)"></a>Code(30)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt, <span class="built_in">tot</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> f[maxn], a[maxn], b[maxn], fm;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Tree[maxn], Fac[maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (X &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[X] += Val;</span><br><span class="line">        X += <span class="built_in">lowbit</span>(X);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (X)</span><br><span class="line">    &#123;</span><br><span class="line">        Ans = (Ans + Tree[X]) % Mod;</span><br><span class="line">        X -= <span class="built_in">lowbit</span>(X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Getans</span><span class="params">(<span class="type">int</span> Arr[], <span class="type">int</span> Tmp[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(Tmp + <span class="number">1</span>, Tmp + <span class="number">1</span> + N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Arr[i] = <span class="built_in">lower_bound</span>(Tmp + <span class="number">1</span>, Tmp + <span class="number">1</span> + N, Arr[i]) - Tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Fac[i] = <span class="number">1ll</span> * Fac[i - <span class="number">1</span>] * i % Mod, <span class="built_in">Add</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Ans = (Ans + ((<span class="number">1ll</span> * <span class="built_in">Query</span>(Arr[i]) - <span class="number">1</span>) * Fac[N - i]) % Mod) % Mod;</span><br><span class="line">        <span class="built_in">Add</span>(Arr[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equ</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equ &amp;&amp; b[i] &gt; a[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &lt; a[i]) equ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[u][i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Check</span>(v) || b[v] &lt; b[u]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Check</span>(<span class="number">1</span>) &amp;&amp; (++cnt) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        b[step + <span class="number">1</span>] = i;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        tot = <span class="number">1ll</span> * tot * i % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> f = __read();</span><br><span class="line">        fm = <span class="built_in">max</span>(fm, f);</span><br><span class="line">        edge[f].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        a[i] = b[i] = __read();</span><br><span class="line">    <span class="keyword">if</span> (fm &gt; <span class="number">1</span>) <span class="built_in">dfs</span>(<span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Getans</span>(a, b, n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, n - i + <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, tot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>鸽~</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>联赛Day2</title>
    <url>/AlanTuringLi/2020/10/13/%E8%81%94%E8%B5%9BDay2/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>对所有的边建一张新图，可以发现，图中所有的环一定都是长度为偶数的，那么对于每个环的方案数就是 $2$，用并查集就可以了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn &lt;&lt; <span class="number">1</span>], in[maxn], out[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = __read() &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> u = __read(), v = __read();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (in[v]) <span class="built_in">merge</span>(in[v], i);</span><br><span class="line">		<span class="keyword">else</span> in[v] = i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (out[u]) <span class="built_in">merge</span>(out[u], i);</span><br><span class="line">		<span class="keyword">else</span> out[u] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="keyword">if</span> (f[i] == i) ans = ans * <span class="number">2</span> % mod;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>题目可以转化一下，因为对于一个 $a[i]!=i$ 的东西来说，这个点可以是左移，也可以是右移那么就可以得到一系列 $p_i$ 的关系，那么就可以根据建立的 $p_i$ 的关系来做一个 $n^2$ 的 $dp$</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], d[maxn], f[maxn];</span><br><span class="line"><span class="type">int</span> pre[maxn], suf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) <span class="keyword">return</span> x - mod;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = __read() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == i) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; a[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[a[i] - <span class="number">1</span>] == <span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[a[i] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i - <span class="number">1</span>] == <span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt; i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[a[i] - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[a[i] - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[i - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; a[i] - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[j] == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> d[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = pre[<span class="number">1</span>] = suf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; ++j)</span><br><span class="line">                f[j] = pre[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j; --j)</span><br><span class="line">                f[j] = suf[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; ++j) pre[j] = <span class="built_in">add</span>(pre[j - <span class="number">1</span>], f[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) suf[j] = <span class="built_in">add</span>(suf[j + <span class="number">1</span>], f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        ans = <span class="built_in">add</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>就是一个构造，显然对于 $n=2\land m=2$ 的情况一定是有解的</p>
<p>那么对于所有的情况，都可以先把最外面的两层清空（一个角的就可以了），如果此时矩阵空了那就是其中一个解，否则无解，为什么呢？</p>
<p><a href="https://imgchr.com/i/0h4sfO"><img src="https://s1.ax1x.com/2020/10/13/0h4sfO.png" alt="0h4sfO.png"></a></p>
<p>这是个什么意思呢？</p>
<p>就是三个 $+$ 的和应该与三个 $-$ 的和相等才有解（行列消一下就可以了），所以对于所有的操作，这个值都是不会发生改变的，既三个 $+$ 减去三个 $-$ 的值恒为 $0$ </p>
<p>然后可以暴力构造出这样的零</p>
<p><a href="https://imgchr.com/i/0hT8b9"><img src="https://s1.ax1x.com/2020/10/13/0hT8b9.png" alt="0hT8b9.png"></a></p>
<p>既被红色部分框起来的都是 $0$，那么右下角的那一个一定是 $0$，同理可以退出整张表都是零，证毕</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dlta = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">10</span>) <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, top;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line">ll dx[maxn], dy[maxn], dk[maxn];</span><br><span class="line"><span class="comment">//to get the change in O(1)</span></span><br><span class="line">ll opt[maxn &lt;&lt; <span class="number">2</span>], pos[maxn &lt;&lt; <span class="number">2</span>], del[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">//handicraft stack，to store answers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dx[x] + dy[y] + dk[y - x + dlta] + a[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> Opt, <span class="type">int</span> Pos, ll delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    opt[++top] = Opt, pos[top] = Pos, del[top] = delta;</span><br><span class="line">    <span class="keyword">if</span> (Opt == <span class="number">1</span>) dx[Pos] += delta;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Opt == <span class="number">2</span>) dy[Pos] += delta;</span><br><span class="line">    <span class="keyword">else</span> dk[Pos + dlta] += delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">g</span>(i, j)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            a[i][j] = __read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">g</span>(i, <span class="number">1</span>)) <span class="built_in">Push</span> (<span class="number">1</span>, i, -<span class="built_in">g</span>(i, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">g</span>(i, <span class="number">2</span>)) <span class="built_in">Push</span> (<span class="number">3</span>, <span class="number">2</span> - i, -<span class="built_in">g</span>(i, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">g</span>(<span class="number">2</span>, i)) <span class="built_in">Push</span> (<span class="number">2</span>, i, -<span class="built_in">g</span>(<span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">g</span>(<span class="number">1</span>, i)) <span class="built_in">Push</span> (<span class="number">3</span>, i - <span class="number">1</span>, -<span class="built_in">g</span>(<span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%lld %lld %lld\n&quot;</span>, opt[i], pos[i], del[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>求： </p>
<script type="math/tex; mode=display">
ans = \max{s_1s_2+s_2s_3+\cdots+s_ks_{k+1}}</script><p>这个很容易能发现是一个斜率 $dp$, 但是对于有负数的点，会出一点小问题</p>
<p>于是考场写了一个 $O(n^3)$ 的 $dp$，结果因为点可以是负的，但是我全部初始化为 $0$，显然这是错误的</p>
<p>应该全初始化为 $-inf$ 才对，害，愉快挂掉</p>
<h2 id="Code-30"><a href="#Code-30" class="headerlink" title="Code(30)"></a>Code(30)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll s[maxn], <span class="built_in">ans</span>(<span class="number">-0x6fffffffffffffff</span>);</span><br><span class="line">ll f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;  i &lt;= n; ++i) </span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + __read();</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">128</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; ++k)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[j][k] + (s[i] - s[j]) * (s[j] - s[k]));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看看正解：</p>
<p>考虑 $f(i,j)$ 表示当前 $dp$ 到了 $i$，上一个区间右端点为 $j$ 时的最优答案。则显然有：</p>
<script type="math/tex; mode=display">
f(i,j)=\max_{0\le k<j}f(j,k)+(s_i-s_j)(s_j-s_k)</script><p>显然这是一个斜率优化的式子，扔掉只和 $i,j$ 有关的常数项，则可以写作：</p>
<script type="math/tex; mode=display">
f(i,j)=p+\max_{0\le k<j}f(j,k)-t\times s_k</script><p>若对于 $s_a&lt;s_b$ 有 $f(j,a)-t\times s_a&lt;f(j,b)-t\times s_b$，那么显然：</p>
<script type="math/tex; mode=display">
\frac{f(j,a)-f(j,b)}{s_a-s_b}>t</script><p>于是我们枚举 $j$，按照 $s$ 排序后暴力维护出一个斜率递减的上凸壳。注意到 $t = s_i − s_j$ ，我们再按照 $s_i$ 从大到小枚举 $i$，就可以贪心地从凸包前面删点了。</p>
<h2 id="Code-100"><a href="#Code-100" class="headerlink" title="Code(100)"></a>Code(100)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id[maxn];</span><br><span class="line">ll f[maxn][maxn];</span><br><span class="line">ll s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x] &lt; s[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(Node a, Node b, Node c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.y - a.y) * (c.x - a.x) &gt; (c.y - a.y) * (b.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;  i &lt;= n; ++i) </span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + __read(), id[i] = i;</span><br><span class="line">    <span class="built_in">sort</span> (id, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">head</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">tail</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[j] &lt; i) &#123;</span><br><span class="line">                Node now = (Node)&#123;s[id[j]], f[i][id[j]]&#125;;</span><br><span class="line">                <span class="keyword">while</span> (head &lt; tail &amp;&amp; !<span class="built_in">check</span>(t[tail - <span class="number">1</span>], t[tail], now)) tail--;</span><br><span class="line">                t[++tail] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[j] &gt; i) &#123;</span><br><span class="line">                ll st = (s[id[j]] - s[i]);</span><br><span class="line">                <span class="keyword">while</span> (head &lt; tail &amp;&amp; (t[head].y - t[head + <span class="number">1</span>].y) &lt;= st * (t[head].x - t[head + <span class="number">1</span>].x)) ++head;</span><br><span class="line">                f[id[j]][i] = t[head].y + (s[id[j]] - s[i]) * (s[i] - t[head].x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>



<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>联赛day3</title>
    <url>/AlanTuringLi/2020/10/14/%E8%81%94%E8%B5%9BDay3/</url>
    <content><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>直接异或 $HASH$ 判断集合是否正确</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[maxn], dfn[maxn], size[maxn], f[maxn][<span class="number">25</span>], depth[maxn];</span><br><span class="line"><span class="type">int</span> id, cur, head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], Prev[maxn &lt;&lt; <span class="number">1</span>]; </span><br><span class="line">ll reflect[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Prev[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] ^= d;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans ^= t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() * <span class="number">114514ll</span> * <span class="number">233ll</span> % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++id, depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    size[u] = <span class="number">1</span>, f[u][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = Prev[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(edge[i], u);</span><br><span class="line">        size[u] += size[edge[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">18</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (depth[f[x][i]] &gt;= depth[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">18</span>; ~i; --i) </span><br><span class="line">        <span class="keyword">if</span> (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id = cur = <span class="number">0</span>;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; ++j) f[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = __read(), t[i] = head[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        reflect[i] = <span class="built_in">rnd</span>(), pre[i] = pre[i - <span class="number">1</span>]  ^ reflect[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = __read(), v = __read();</span><br><span class="line">        <span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(dfn[i], reflect[a[i]]), <span class="built_in">add</span>(dfn[i] + size[i], reflect[a[i]]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> o, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        o = __read(), x = __read(), y = __read();</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">            ll tmp = <span class="built_in">query</span>(dfn[x]) ^ <span class="built_in">query</span>(dfn[y]);</span><br><span class="line">            <span class="type">int</span> rca = <span class="built_in">lca</span>(x, y), len = depth[x] + depth[y] - <span class="number">2</span> * depth[rca] + <span class="number">1</span>;</span><br><span class="line">            tmp ^= reflect[a[rca]];</span><br><span class="line">            <span class="keyword">if</span> (tmp == pre[len]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">add</span>(dfn[x], reflect[a[x]] ^ reflect[y]);</span><br><span class="line">            <span class="built_in">add</span>(dfn[x] + size[x], reflect[a[x]] ^ reflect[y]);</span><br><span class="line">            a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> t = __read();</span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>鸽~</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/AlanTuringLi/2020/06/14/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h3 id="P3911-最小公倍数之和"><a href="#P3911-最小公倍数之和" class="headerlink" title="P3911 最小公倍数之和"></a><a href="https://www.luogu.com.cn/problem/P3911">P3911 最小公倍数之和</a></h3><script type="math/tex; mode=display">
求\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(a_i,a_j)}\\
\forall a_i \in \left[ 1, \;Maxn\right]</script><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(a_i,a_j)}\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(i,j)}\cdot c_i \cdot c_j\\
{PS： c_i,\; c_j分别别表示i，j出现的次数}</script><h5 id="化简："><a href="#化简：" class="headerlink" title="化简："></a>化简：</h5><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^nlcm(i,\;j)\cdot i \cdot j\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{i \cdot j \cdot c_i \cdot c_j}{\gcd(i,\;j)}\\
\Leftrightarrow\sum\limits_{d=1}^n\;d\;\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{n}{d}\right]\left[ \gcd(i,\;j) = 1\right]\cdot i \cdot j \cdot c_{id} \cdot c_{jd} \\
\Leftrightarrow\sum\limits_{d=1}^n\;d\;\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{n}{d}\right]\sum\limits_{k\mid \gcd (i,j)}\mu(k)\cdot i\cdot j\cdot c_{id}\cdot c_{jd}\\
\Leftrightarrow\sum\limits_{d=1}^n\sum\limits_{k=1}^\left[\frac{n}{d}\right]\;d\cdot \mu(k)\sum\limits_{i=1}^\left[\frac{n}{kd}\right]\sum\limits_{j=1}^\left[\frac{n}{kd}\right] i\cdot j\cdot c_{idk}\cdot c_{jdk}\cdot k^2\\
\Leftrightarrow\sum\limits_{T=1}^nT\cdot\;(\sum\limits_{i=1}^\left[ \frac{n}{T} \right]i\cdot c_{iT})^2 \cdot \sum\limits_{k \mid T}\mu(k) \cdot k</script><p>然后有：</p>
<script type="math/tex; mode=display">
\sum\limits_{k \mid T}\mu(k) \cdot k</script><p>这个可以预处理的</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line">ll N, Temp, MaxNum, Ans;</span><br><span class="line">ll Cnt[Maxn + <span class="number">5</span>], Mu[Maxn + <span class="number">5</span>], Pri[Maxn + <span class="number">5</span>], S[Maxn + <span class="number">5</span>], Tot;</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Tot] = i, Mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Tot &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Mu[i * Pri[j]] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Mu[i * Pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= Maxn; j += i) S[j] += Mu[i] * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Max</span><span class="params">(ll &amp;X, ll Y)</span> </span>&#123;X = (X &gt; Y ? X : Y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;Temp);</span><br><span class="line">        Cnt[Temp]++;</span><br><span class="line">        <span class="built_in">Max</span>(MaxNum, Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Init</span>(MaxNum);</span><br><span class="line">    <span class="keyword">for</span> (ll T = <span class="number">1</span>; T &lt;= MaxNum; ++T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= MaxNum / T; ++i) Temp += i * Cnt[i * T];</span><br><span class="line">        Ans += T * Temp * Temp * S[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ps-双倍经验AT2500"><a href="#Ps-双倍经验AT2500" class="headerlink" title="Ps : 双倍经验AT2500"></a>Ps : 双倍经验<a href="https://www.luogu.com.cn/problem/AT5200">AT2500</a></h5><p>只需要在这道题的基础上减去自己的贡献再乘上2的逆元，注意<strong>取模</strong>啊！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll Maxn = <span class="number">1e6</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll N, Temp, MaxNum, Ans, TempA;</span><br><span class="line">ll Cnt[Maxn + <span class="number">5</span>], Mu[Maxn + <span class="number">5</span>], Pri[Maxn + <span class="number">5</span>], S[Maxn + <span class="number">5</span>], Tot;</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Tot] = i, Mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Tot &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Mu[i * Pri[j]] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Mu[i * Pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Mu[i] &lt; <span class="number">0</span>) Mu[i] += Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= Maxn; j += i) S[j] = (S[j] + Mu[i] * i % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Max</span><span class="params">(ll &amp;X, ll Y)</span> </span>&#123;X = (X &gt; Y ? X : Y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll Y, ll X = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">        X = X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;Temp);</span><br><span class="line">        TempA = (TempA + Temp) % Mod;</span><br><span class="line">        Cnt[Temp]++;</span><br><span class="line">        <span class="built_in">Max</span>(MaxNum, Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Init</span>(MaxNum);</span><br><span class="line">    <span class="keyword">for</span> (ll T = <span class="number">1</span>; T &lt;= MaxNum; ++T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= MaxNum / T; ++i) Temp = (Temp + i * Cnt[i * T] % Mod) % Mod;</span><br><span class="line">        Ans = (Ans + T * Temp % Mod * Temp % Mod * S[T] % Mod) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (Ans - TempA + Mod) % Mod * <span class="built_in">Pow</span>(Mod - <span class="number">2</span>) % Mod);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1447-NOI2010-能量采集"><a href="#P1447-NOI2010-能量采集" class="headerlink" title="P1447 [NOI2010]能量采集"></a><a href="https://www.luogu.com.cn/problem/1447">P1447 [NOI2010]能量采集</a></h3><script type="math/tex; mode=display">
求\sum\limits_{i=1}^n\sum\limits_{j=1}^m\left[(2\cdot\gcd(i,j))-1\right]</script><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^m\left[(2\cdot\gcd(i,j))-1\right]\\\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^m 2 \cdot\gcd(i,j) - m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\;\cdot\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{m}{d}\right]\left[\gcd(i,j)=1\right]-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\;\cdot\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{m}{d}\right]\sum\limits_{k\mid\gcd(i,j)}\mu(k)-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\cdot\sum\limits_{k=1}^\left[\frac{n}{d}\right]\mu(k)\cdot\left[\frac{n}{dk}\right]\cdot\left[\frac{m}{dk}\right]-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{T=1}^n\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]\sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})-m\cdot n\\\\</script><h5 id="化简：-1"><a href="#化简：-1" class="headerlink" title="化简："></a>化简：</h5><script type="math/tex; mode=display">
令：h(n) = \sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})\\\\
h=id*\mu\\\\
\because \mu * 1=\epsilon\\\\
\therefore h*1=id* (\mu * 1)\\\\
\therefore h*1=id*\epsilon\\\\
\therefore h*1=id\\\\
又\because id = \varphi * 1\\\\
\therefore h = \varphi\\\\
即：2\cdot\sum\limits_{T=1}^n\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]\sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{T=1}^n\varphi(T)\cdot\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]-m\cdot n</script><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e5</span>;</span><br><span class="line">ll N, M, Ans, Cnt;</span><br><span class="line">ll Phi[Maxn + <span class="number">10</span>], Pri[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Phi[i] = i - <span class="number">1</span>, Pri[++Cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Phi[i * Pri[j]] = Phi[i] * Phi[Pri[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Phi[i * Pri[j]] = Phi[i] * Pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) Phi[i] += Phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">if</span> (N &gt; M) <span class="built_in">swap</span>(N, M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(N / (N / l), M / (M / l));</span><br><span class="line">        Ans += <span class="number">2</span> * (Phi[r] - Phi[l - <span class="number">1</span>]) * (N / l) * (M / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, Ans - N * M);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5221-Product"><a href="#P5221-Product" class="headerlink" title="P5221 Product"></a><a href="https://www.luogu.com.cn/problem/P5221">P5221 Product</a></h3><script type="math/tex; mode=display">
求:\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{lcm(i,j)}{\gcd(i,j)}(mod\;104857601)</script><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><script type="math/tex; mode=display">
\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\\
\Leftrightarrow\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{i\cdot j}{\gcd(i,j)^2}\\
\Leftrightarrow\prod\limits_{i=1}^N\prod\limits_{j=1}^Ni\cdot j\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{\gcd(i,j)^2}\\</script><h5 id="化简"><a href="#化简" class="headerlink" title="化简:"></a>化简:</h5><script type="math/tex; mode=display">
其中:\prod\limits_{i=1}^N\prod\limits_{j=1}^Ni\cdot j
\\=\prod\limits_{i=1}^N\left(i^N\cdot N!\right)\\
=\left(N!\right)^N\prod\limits_{i=1}^Ni^N\\
=\left(N!\right)^N\cdot\left(N!\right)^N\\
=\left(N!\right)^{2N}</script><script type="math/tex; mode=display">
其中还有:\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{\gcd(i,j)^2}\\
=\prod\limits_{d=1}^N\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{d^2\cdot\left[\gcd(i,j)=d\right]}\\
若:gcd(i,j)\ne d\;则整体贡献为1\\
=\left(\prod\limits_{d=1}^Nd^{\sum\limits_{i=1}^N\sum\limits_{j=1}^N\left[\gcd(i, j)=d\right]}\right)^{-2}\\
=\left(\prod\limits_{d=1}^Nd^{\sum\limits_{i=1}^\frac{N}{d}\sum\limits_{j=1}^\frac{N}{d}\left[\gcd(i, j)=1\right]}\right)^{-2}\\
令:sum(x) = \sum\limits_{i=1}^x\varphi(i)\\
=\left(\prod\limits_{d=1}^Nd^{2sum(\frac{N}{d}) - 1}\right)^{-2}\\
\therefore Ans = (N!)^{2N}\left(\prod\limits_{d=1}^Nd^{2sum(\frac{N}{d}) - 1}\right)^{-2}</script><h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn = <span class="number">1e6</span>, Mod = <span class="number">104857601</span>;</span><br><span class="line"><span class="type">int</span> N, Cnt, Phi[Maxn + <span class="number">5</span>], <span class="built_in">Fac</span>(<span class="number">1</span>), <span class="built_in">Tmp</span>(<span class="number">1</span>), Pri[Maxn/<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> Vis[Maxn + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Y %= (Mod - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = <span class="number">1ll</span> * Ans * X % Mod;</span><br><span class="line">        X = <span class="number">1ll</span> * X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans % Mod;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Fac = <span class="number">1ll</span> * Fac * i % Mod;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Cnt] = i, Phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Phi[i * Pri[j]] = Phi[i] * (Pri[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Phi[i * Pri[j]] = Phi[i] * Pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) Phi[i] = ( Phi[i - <span class="number">1</span>] + <span class="number">2ll</span> * Phi[i]) % (Mod - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i) Tmp = <span class="number">1ll</span> * Tmp * <span class="built_in">Pow</span>(i, Phi[Maxn / i] - <span class="number">1</span>) % Mod;</span><br><span class="line">    Fac = <span class="built_in">Pow</span>(Fac, Maxn * <span class="number">2</span>);</span><br><span class="line">    Tmp = <span class="number">1ll</span> * <span class="built_in">Pow</span>(<span class="number">1ll</span> * Tmp * Tmp % Mod, Mod - <span class="number">2</span>) * Fac % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">Init</span>(N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Tmp);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式($Determinant$)入门</title>
    <url>/AlanTuringLi/2022/07/24/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="行列式的概念"><a href="#行列式的概念" class="headerlink" title="行列式的概念"></a>行列式的概念</h1><h2 id="n-阶行列式"><a href="#n-阶行列式" class="headerlink" title="$n$ 阶行列式"></a>$n$ 阶行列式</h2><h3 id="二阶行列式"><a href="#二阶行列式" class="headerlink" title="二阶行列式"></a>二阶行列式</h3><p>由 $2^2$ 个数排列成的两行两列，记作：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
a_1 & a_2\\
b_1 & b_2
\end{vmatrix} = a_1b_2-a_2b_1</script><p>其几何意义是平面直角坐标系 $xoy$ 上以 $a=(a_1, a_2) \quad b=(b_1, b_2)$ 为邻边的平行四边形的有向面积。</p>
<h3 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h3><p>由 $3^3$ 个数排列成的三行三列，其几何意义为其行向量（列向量）所张成的平行六面体的有向体积。</p>
<h3 id="n-阶行列式-1"><a href="#n-阶行列式-1" class="headerlink" title="$n$ 阶行列式"></a>$n$ 阶行列式</h3><p>由 $n^n$ 个数排列成的 $n$ 行 $n$ 列，记作：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
a_{2, 1}&a_{2, 2}&\dots&a_{2, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}\\
常记作\quad D\quad或\quad D=\det(a_{ij})</script><p>它的值为所有不同行列 $n$ 个元素的代数和，即： </p>
<script type="math/tex; mode=display">
\sum_P=[(-1)^{\tau(P)}\prod_{i=1}^na_{i,p_i}]</script><p>其中 $P$ 表示 $1$ 到 $n$ 的全排列。</p>
<h1 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h1><blockquote>
<p>所有性质均可以通过定义证明其正确性。</p>
</blockquote>
<h2 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h2><p>行列式与其转置行列式相等：</p>
<script type="math/tex; mode=display">
D=\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
a_{2, 1}&a_{2, 2}&\dots&a_{2, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}\quad

D^T=\begin{vmatrix}
a_{1, 1}&a_{2, 1}&\dots&a_{n, 1}\\
a_{1, 2}&a_{2, 2}&\dots&a_{n, 2}\\
\vdots&\vdots&\ddots&\vdots\\
a_{1, n}&a_{2, n}&\dots&a_{n, n}\\
\end{vmatrix}\\
D=D^T\\
D^T表示D的转置行列式</script><h2 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h2><script type="math/tex; mode=display">
\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
b_1+c_1&b_2+c_2&\dots&b_n+c_n\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}=\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
b_1&b_2&\dots&b_n\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}+\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
c_1&c_2&\dots&c_n\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}</script><h2 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h2><script type="math/tex; mode=display">
\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
ka_{i, 1}&ka_{i, 2}&\dots&ka_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}=k\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}</script><blockquote>
<p>特别地，当$k = 0$ 可知如果该行列式中有一行或一列全为零，那么该行列式为零。</p>
</blockquote>
<h2 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h2><p>如果行列式中有两行（两列）完全相同，那么该行列式为零。</p>
<blockquote>
<p>可以看作一个 $n$ 维的空间少一个维度，那么它在 $n$ 维空间中是没有体积的。</p>
<p>用定义来证明：</p>
<p>必定存在两个不同的排列 $P$ 使得 $\prod a_{p_i,i}$ 是相同的，只用证明 $\tau(P)$ 的奇偶性不同即可。</p>
<p>对于排列$(i&lt;j)$：</p>
<script type="math/tex; mode=display">
P_1\ =\ \dots\quad i \quad \dots\quad j\quad \dots\\
P_2\ =\ \dots\quad j \quad \dots\quad i\quad \dots\\</script><p>显然首位两端对逆序数没有影响，令中间一段有 $a$ 个数小于 $i$， $b$ 个数 大于 $i$ 小于 $j$，  $c$ 个数大于 $j$ ，那么 有：</p>
<script type="math/tex; mode=display">
\tau_{P_2}=\tau_{P_1}+((-a)+b+c)+(a+b+(-c))+1=\tau_{P_1}+2b+1</script><p>所以 $\tau_P$ 的奇偶性不同。</p>
<p>又因为所有的排列都可以均分为 $\tau_p\ \&amp; \ 1 \ =\ 1$ 和 $\tau_P \ \&amp; \ 1\ =\ 0$，两组，所以行列式代数和为零。</p>
</blockquote>
<h2 id="性质五"><a href="#性质五" class="headerlink" title="性质五"></a>性质五</h2><p>如果行列式中有两行或两列成等比数列那么行列式为零。</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
ka_{i, 1}&ka_{i, 2}&\dots&ka_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix} = 
k\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix} = 0</script><h2 id="性质六"><a href="#性质六" class="headerlink" title="性质六"></a>性质六</h2><p>把一行的倍数加到另一行，行列式不变：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
ka_{i, 1}+a_{j, 1}&ka_{i, 2}+a_{j,2}&\dots&ka_{i, n}+a_{j,n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}=\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
ka_{i, 1}&ka_{i, 2}&\dots&ka_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}+\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{j, 1}&a_{j, 2}&\dots&a_{j, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}=\begin{vmatrix}
a_{1, 1}&a_{1, 2}&\dots&a_{1, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{i, 1}&a_{i, 2}&\dots&a_{i, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{j, 1}&a_{j, 2}&\dots&a_{j, n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n, 1}&a_{n, 2}&\dots&a_{n, n}\\
\end{vmatrix}</script><h2 id="性质七"><a href="#性质七" class="headerlink" title="性质七"></a>性质七</h2><p>对换行列式中两行的位置，行列式反号。</p>
<blockquote>
<p>可以根据性质六将两行不断加减得到结果。</p>
<p>也可以看作交换了行的编号，即逆序数的奇偶性发生改变。</p>
</blockquote>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>可以通过高斯消元的方法将一个行列式转化为上三角或者下三角行列式，进而计算行列式的值。</p>
<p>为了保留精度，可以在消元的时候采用辗转相除法逐步消元，直到出现零为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">600</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) </span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll N, Mod;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ll D[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    N = __read(), Mod = __read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            D[i][j] = __read() % Mod;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">k</span><span class="params">(i)</span>, <span class="title">j</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!D[j][i] &amp;&amp; j &lt; N) ++k, ++j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!D[k][i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i ^ k) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span> (D[i], D[k]);</span><br><span class="line">            flag ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (D[i][i] &lt; D[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(D[i], D[j]);</span><br><span class="line">                flag ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (D[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> times = D[i][i] / D[j][i];</span><br><span class="line">                <span class="keyword">for</span> (k = i; k &lt;= N; ++k) D[i][k] = (D[i][k] + (Mod - times) * D[j][k] % Mod) % Mod;</span><br><span class="line">                <span class="built_in">swap</span>(D[i], D[j]);</span><br><span class="line">                flag ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Ans = (Ans * D[i][i]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) cout &lt;&lt; (Mod - (Ans % Mod)) % Mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; Ans % Mod &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system (&quot;pause&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>象棋与马</title>
    <url>/AlanTuringLi/2022/02/06/%E8%B1%A1%E6%A3%8B%E4%B8%8E%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\times b$ 的矩形（ 即能够从 $(x,y)$ 到达 $(x\pm a,y\pm b)$ 或 $(x\pm b,y\pm a)$ ）。</p>
<p>若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。</p>
<p>给你 $T$ 组询问，每组给你一个 $n$，让你求：</p>
<script type="math/tex; mode=display">
\left(\sum_{a=1}^n\sum_{b=1}^np(a,b)\right)\mod {2^{64}}</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，本质不同的行走方案有四种，即 $(a,b),(b,a),(-a,b),(-b,a)$，那么设这四种本质不同的分别走了 $x_1,x_2,x_3,x_4$ 次，那么能够走满这个棋盘的充要条件是：</p>
<script type="math/tex; mode=display">
\begin{cases}
ax_1+bx_2-ax_3-bx_4=1\\
bx_1+ax_2+bx_3+ax_4=0
\end{cases}</script><p>只要满足了这个条件，它就可以上下左右移动了，就是说可以走满整张棋盘</p>
<p>那么可以化简一下上式，然后得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&a((x_1+x_2)-(x_3-x_4))+b((x_1+x_2)+(x_3-x_4))=1\\
\therefore &a(x-y)+b(x+y)=1
\end{aligned}</script><p>那么此时可以得到两条性质：</p>
<ul>
<li>$a\perp b$</li>
<li>$a\not\equiv b\pmod 2$</li>
</ul>
<p>第一条的话，就是因为 $akx+bky=k\gcd(a,b)$；第二个的话，就是说 $x-y$ 和 $x+y$ 一定是奇偶性相同的而且只能是奇数，那么 $a、b$ 一定一奇一偶，正确性显然</p>
<p>所以可以得到 $p(a,b)=[a\perp b]\land a,b$奇偶性不相同</p>
<h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>既然已经知道了 $a、b$ 奇偶性不同，那么就可以限制谁是奇数谁是偶数，最后 $\times2$ 就可以</p>
<p>时间复杂度 $O(n^2)$，期望得分 $20$ </p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j += <span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) ++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>根据算法一，我们知道题目限制了两个数的奇偶性，那么我们先试着表达一下，再看看可以怎么化简</p>
<script type="math/tex; mode=display">
\sum_{a=1}^n\sum_{b=1}^np(a,b)=2\times\sum_{a=1}^n\sum_{b=1}^n[a\perp b\text{且a为偶数b为奇数}]</script><p>又因为 $a\perp b$ 且 $a$ 是偶数 $b$ 是奇数，那么 $a\rightarrow \frac a2$，也是可以得到 $a\perp b$ 的</p>
<p>所以又得到了</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{a=1}^n\sum_{b=1}^n[a\perp b\text{且a为偶数b为奇数}]&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b\text{且b为奇数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^n[a\perp b\text{且b是偶数}]
\end{aligned}</script><p>感觉这个容斥还是很好想到的，那么就可以继续往下走，定义记号 $f(n,m)$ </p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b\text{且a为偶数b为奇数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b\text{且b是偶数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b\text{且a是奇数b是偶数}]\\
&=\sum_{a=1}^{\frac n2}\sum_{b=1}^m[a\perp b]-f(m,\frac n2)
\end{aligned}</script><p>为了方便表述，就令</p>
<script type="math/tex; mode=display">
\begin{aligned}
s(n,m)&=\sum_{a=1}^n\sum_{b=1}^m[a\perp b]\\
&=\sum_{a=1}^n\sum_{b=1}^m\sum_{d|\gcd(a,b)}\mu(d)\\
&=\sum_{d=1}^{\min(a,b)}\mu(d)\left\lfloor\frac nd\right\rfloor\left\lfloor\frac md\right\rfloor
\end{aligned}</script><p>所以 $f(n,m)=s(\frac n2,m)-f(m,\frac n2)$</p>
<p>然后 $s$ 的计算可以数论分块，$f$ 递归计算，所以时间复杂度为 $O(\log n\sqrt n)$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, t, cnt;</span><br><span class="line">ll mu[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        sum += (mu[r] - mu[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gc</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m / <span class="number">2</span>;</span><br><span class="line">    ll total = <span class="built_in">solve</span>(n, m / <span class="number">2</span>), cut = <span class="built_in">gc</span>(m / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> total - cut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ll total = <span class="built_in">solve</span>(n / <span class="number">2</span>, n), cut = <span class="built_in">gc</span>(n / <span class="number">2</span>, n);</span><br><span class="line">        ll ans = (total - cut) * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="满分做法"><a href="#满分做法" class="headerlink" title="满分做法"></a>满分做法</h2><p>算法二的瓶颈在于空间，开不了 $10^{11}$ 的数组，所以考虑使用杜教筛，就可以过题了</p>
<p>至于这个的时间复杂的的话，个人感觉是 $O(\log n\sqrt n+n^{\frac 32})$，不知道对不对</p>
<p>希望有大佬能告诉我正确的时间复杂度</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line">ll n, t, cnt;</span><br><span class="line">ull mu[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map &lt;ll, ull&gt; Mu;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">MMu</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * <span class="built_in">MMu</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ll n, ll m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ull <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        sum += (<span class="built_in">MMu</span>(r) - <span class="built_in">MMu</span>(l - <span class="number">1</span>)) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">gc</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ull total = <span class="built_in">solve</span>(n / <span class="number">2</span>, m), cut = <span class="built_in">gc</span>(m, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> total - cut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    t = __read();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        ull ans = <span class="built_in">gc</span>(n, n) * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶数据结构1</title>
    <url>/AlanTuringLi/2020/07/27/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法:"></a>基本方法:</h2><ul>
<li>前缀和</li>
<li>差分</li>
<li>离散化</li>
<li>离线</li>
<li>二分</li>
<li>倍增</li>
<li>双指针</li>
<li>永久记忆化</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构:"></a>基本数据结构:</h2><ul>
<li><p>线段树</p>
</li>
<li><p>树状数组</p>
</li>
<li><p>$ST$表</p>
</li>
<li><p>单调队列</p>
</li>
<li><p>单调栈</p>
</li>
<li><p>并查集</p>
</li>
</ul>
<h2 id="树上问题基本方法"><a href="#树上问题基本方法" class="headerlink" title="树上问题基本方法"></a>树上问题基本方法</h2><ul>
<li>求$LCA$<ul>
<li>$O(n)-O(\log n)$</li>
<li>$O(n\log n)-O(1)$</li>
</ul>
</li>
<li>$DFS$序</li>
<li>链差分</li>
</ul>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树就是对一个序列递归地取中点分成两部分形成的分治树。任何以单点为基本单位的分治树都可以适配任意区间，而取中点分治保证了树高为$O(\log n)$。合并所有被完整包含的极大区间即可得到目标区间。</p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>将序列长度扩充成$2$的幂，建线段树，自底向上将每个节点的右儿子删除，这样会剩下$n$个节点。可以用一个数组来存储，其中下标$i$存储包含 $i$的最小节点，这个数组就称为树状数组。 </p>
<p>树状数组的英文名为 $Fenwick\;tree$ 或 $Binary\;Indexed \;Tree$， 可以缩写为 $BIT$。</p>
<p>对于一个线段树支持的操作，如果可以不用任何作为右儿子的节点，就可以用树状数组实现。 </p>
<p>大多数情况下，无论是代码实现难度还是运行效率，树状数组都有碾压性的优势。</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><ul>
<li><p>区间加一个数, 查询单点</p>
</li>
<li><p>区间加一个数, 查询单点和</p>
</li>
<li><p>区间加等差数列, 查询单点</p>
</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>用两个指针扫描, 扫描过程中保持两个指针的距离不超过一个定值</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>维护一个序列，支持以下操作：</p>
<ul>
<li><p>在后面插入元素； </p>
</li>
<li><p>删除最前面的元素； </p>
</li>
<li><p>求序列中元素的最小值。<br>插入元素时，队尾的更大的元素不会再产生贡献，可以直接删去。这样队列中实际存在的元素单调递减。 </p>
</li>
</ul>
<p>常结合双指针使用。</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>将序列中的元素依次插入一个栈，若栈顶元素更小，则它的答案已经可以确定，从而可以弹出。这样栈中的元素单调递减。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用来维护不相交集合。可以缩写为$DSU$。 </p>
<p>通常只使用路径压缩策略。即使只压缩一半的路径，均摊复杂度仍然是$O(\log n)$。 </p>
<p>另有带权并查集，维护点权差的传递。可以利用取模后的权值差来分类。</p>
<p>注：所谓的 $DSU\;on\;tree$ 实际上是树的链分治，和 $DSU$ 并 没有任何关系，因此这个称呼并不合理。</p>
<hr>
<h1 id="平衡树相关"><a href="#平衡树相关" class="headerlink" title="平衡树相关"></a>平衡树相关</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>每个节点有一个关键字，每个节点的关键字均不小于左子树中任何节点的关键字，且均不大于右子树中任何节点的关键字，或者说按树的中序遍历排列这些关键字得到的数列单调不降。 </p>
<p>二叉搜索树的英文为 $Binary\;Search \;Tree$，可缩写为 $BST$。</p>
<p><img src="./BST.png" alt=""></p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树全称平衡二叉搜索树，是深度为 $O(log\;n)$ 的二叉搜 索树。 </p>
<p>平衡树有很多种，学会 $Splay$ 和 $Treap$ 就够用了，当然有兴趣可以多学，虽然没啥用。</p>
<p>在普通 $BST$ 的基础上，每个节点随机分配一个权值，调整树的形态使得这些权值满足堆性质。</p>
<p> 可以证明任何时候树的期望深度为 $O(\log \;n)$。 </p>
<p>名称来自 $Tree + Heap$，故又称树堆。</p>
<h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>设 $C_x$ 为 $x$ 的出现次数，建线段树维护 $C$ 的前缀和。由于 $C$ 的下标是权值，这样的线段树常称为权值线段树。</p>
<h2 id="线段树上二分"><a href="#线段树上二分" class="headerlink" title="线段树上二分"></a>线段树上二分</h2><p>二分的过程可以视为在分治树上自顶向下移动，既然线段树是分治树，那么自然可以直接在线段树上移动。</p>
<h2 id="动态开店线段树"><a href="#动态开店线段树" class="headerlink" title="动态开店线段树"></a>动态开店线段树</h2><p>最开始没有点，不建树，当修改操作用到了不存在的点时 再创建这个点。如果查询操作用到了不存在的点，可以直 接算出相应的答案。 </p>
<p>适用于无法离散化的情况。</p>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="$Splay$"></a>$Splay$</h2><p>每次操作后都通过某种方法旋转，使最后一个被访问的节点成为根节点。 </p>
<p>可以证明 $n$ 次操作的总复杂度为 $O(n \log n)$，即一次操作 的均摊复杂度为 $O(log n)$，但某一次操作的复杂度可能达到 $O(n)$。 </p>
<p>可直译为伸展树。</p>
<h2 id="FHQ-quad-Treap"><a href="#FHQ-quad-Treap" class="headerlink" title="$FHQ\quad Treap$"></a>$FHQ\quad Treap$</h2><p>$Treap$ 可以实现分裂与合并，只要在过程中维护堆性质，复杂度并不会改变。插入和删除都可以通过分裂与合并来实 现，这样就不再需要旋转过程。</p>
<h2 id="反转操作"><a href="#反转操作" class="headerlink" title="反转操作"></a>反转操作</h2><p>把对应的区间分裂出来, 反转左右子树即可</p>
<h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>合并两个区间的最值区间信息时，只有两种情况： </p>
<blockquote>
<ol>
<li><p>最值区间位于某一个区间； </p>
</li>
<li><p>最值区间横跨两个区间。 </p>
</li>
</ol>
</blockquote>
<p>只需要维护前后缀信息，就可以计算第二种情况。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>通常情况下，常数：$Treap &lt; Splay &lt; 无旋 Treap$。 </p>
<ul>
<li>$Treap$ 常用于维护有序表； </li>
<li>$Splay$ 维护有序表效率低，而且实现不方便； </li>
<li>$Splay$ 常用于 $LCT$ 或维护序列； </li>
<li>无旋 $Treap$ 也可以维护序列，便于实现可持久化，但效率较低。</li>
</ul>
<hr>
<h1 id="高维问题"><a href="#高维问题" class="headerlink" title="高维问题"></a>高维问题</h1><h2 id="维度组成"><a href="#维度组成" class="headerlink" title="维度组成"></a>维度组成</h2><ul>
<li><p>如果对操作的位置有限制，问题就有位置轴。 </p>
</li>
<li><p>如果对操作的权值有限制，问题就有权值轴。 </p>
</li>
<li><p>如果对操作的顺序有要求，问题就有时间轴。</p>
</li>
</ul>
<p>位置轴和权值轴并没有本质区别。 </p>
<p>权值线段树只是指明了维护的是权值轴，和维护位置轴的线段树并没有本质区别。</p>
<h2 id="时间轴变换"><a href="#时间轴变换" class="headerlink" title="时间轴变换"></a>时间轴变换</h2><p>将某一轴视为时间轴，按时间顺序插入，从而将前缀查询转化为某个时间点的查询。</p>
<h2 id="离线扫描"><a href="#离线扫描" class="headerlink" title="离线扫描"></a>离线扫描</h2><p>将所有询问和数据集合一起按新的时间轴排序。</p>
<h2 id="分治树"><a href="#分治树" class="headerlink" title="分治树"></a>分治树</h2><p>维护某一维数据的基本方法是使用分治树。 </p>
<p>通常所说的数据结构是显式的分治树，包括线段树和平衡 树；通常所说的分治使用隐式的分治树。</p>
<h2 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h2><p>通过分治维护时间维。 </p>
<p>通常的 CDQ 分治只查询时间前缀，也可以做到查询时间区间，实现比较繁琐。</p>
<h2 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h2><p>用分治维护需要二分的维度，在分治树上二分。</p>
<h2 id="分治树的组合"><a href="#分治树的组合" class="headerlink" title="分治树的组合"></a>分治树的组合</h2><ul>
<li>树状数组套平衡树：空间 $O(n log n)$，效率一般 </li>
<li>树状数组套线段树：空间 $O(n \log_2 n)$，效率一般，各线段树可以同时二分</li>
<li>线段树套树：支持不可减外层信息分治套树状数组：离线，空间 $O(n)$，效率很高，可以在隐式分治树上二分 </li>
<li>分治套线段树：离线，空间 $O(n)$，效率较高，支持较复杂的操作 </li>
<li>树状数组套压缩 $trie$：空间 $O(n \log n)$，实现难度较大 </li>
<li>“重量”平衡树套树：支持外层插入，实现难度较大</li>
</ul>
<h2 id="KDT"><a href="#KDT" class="headerlink" title="$KDT$"></a>$KDT$</h2><p>维护 $k$ 维空间矩形信息的复杂度为 $O(n^{1−\frac1k} )$，空间 $O(n)$， 且支持高维标记，但是不能剪枝时常数巨大。</p>
<hr>
<h1 id="根号大法好"><a href="#根号大法好" class="headerlink" title="根号大法好"></a>根号大法好</h1><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>将序列分块，将询问按左端点所在块为第一关键字、右端点为第二关键字排序。依次处理询问，维护一个初始为空的区间，每次将维护的区间按需插入或删除若干元素，得到当前的询问区间。</p>
<p>设块大小为 $l$。维护的区间的左端点的移动不超过 $ml + 2n$， 右端点的移动不超过 $2n \left \lceil nl \right \rceil$ ，取 $l=\left\lceil n\sqrt m\right\rceil$ 得最优复杂度 $O(n\sqrt m)$。</p>
<p>有时无法进行删除操作，这时可以只从某个块的左端点开 始维护区间，移动右端点并在右端插入相应的元素。移动到每个询问的右端点时，将左端未插入的元素插入，得到答案后再撤销左端的插入。 </p>
<p>这样就不用进行删除操作，但是至少要支持从两端插入。</p>
<h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><p>$O(\sqrt n)-O(1)$或$O(1)-O(\sqrt n)$</p>
<ul>
<li>序列单点修改，区间和 </li>
<li>序列区间加，查询单点 </li>
<li>集合插入，查询 $k$ 小</li>
</ul>
<center> <a href="./download.zip">附件下载 </center>

<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>道路和航线</title>
    <url>/AlanTuringLi/2020/09/15/%E9%81%93%E8%B7%AF%E5%92%8C%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="道路和航线"><a href="#道路和航线" class="headerlink" title="道路和航线"></a><a href="https://ac.nowcoder.com/acm/problem/50381">道路和航线</a></h1><p>本质就是一个最短路，有负边，题目保证无环</p>
<p>$SPFA$直接跑的正确性就不用证明了</p>
<p>这道题卡掉了朴素的$SPFA$，用双端队列优化即可？</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">&#x27;0&#x27;</span> || o &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">&#x27;-&#x27;</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; o &lt;= <span class="string">&#x27;9&#x27;</span>; o = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, P, R, S, cur, dis[maxn];</span><br><span class="line"><span class="type">int</span> hed[maxn], edg[maxn], nxt[maxn], cst[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cur] = hed[u];</span><br><span class="line">    hed[u] = cur;</span><br><span class="line">    edg[cur] = v;</span><br><span class="line">    cst[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push_front</span>(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop_front</span>();</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = hed[now]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edg[i]] &lt;= cst[i] + dis[now]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[edg[i]] = cst[i] + dis[now];</span><br><span class="line">            <span class="keyword">if</span> (vis[edg[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[edg[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">empty</span>() || dis[edg[i]] &lt;= dis[Q.<span class="built_in">front</span>()]) Q.<span class="built_in">push_front</span>(edg[i]);</span><br><span class="line">            <span class="keyword">else</span> Q.<span class="built_in">push_back</span>(edg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = __read(), R = __read(), P = __read(), S = __read();</span><br><span class="line">    <span class="keyword">while</span> (R--) &#123;</span><br><span class="line">        <span class="type">int</span> a = __read(), b = __read(), c = __read();</span><br><span class="line">        <span class="built_in">AddEdge</span>(a, b, c), <span class="built_in">AddEdge</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (P--) &#123;</span><br><span class="line">        <span class="type">int</span> a = __read(), b = __read(), c = __read();</span><br><span class="line">        <span class="built_in">AddEdge</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">SPFA</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == inf) <span class="built_in">puts</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS入门-波导优化设计</title>
    <url>/AlanTuringLi/2023/11/06/HFSS%E5%85%A5%E9%97%A8-%E6%B3%A2%E5%AF%BC%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749447813&p=3&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<ul>
<li>定义输出变量 $Power31、Power21、Power11$，分别表示 $Port\;3\;2\;1$ 的输出功率。<ul>
<li>$Power11 = mag(S(P1, P1))*mag(S(P1, P1))$</li>
<li>$Power21=mag(S(P2, P1))*mag(S(P2, P1))$</li>
<li>$Power31=mag(S(P3, P1))*mag(S(P3,P1))$</li>
</ul>
</li>
<li>参数扫描分析。<ul>
<li>分析 $10GHz$ 时端口输出功率随隔片位置的变化曲线。</li>
</ul>
</li>
<li>优化设计，找出隔片位置使得 $10GHz$ 时 $Port\;3$ 的输出功率时 $Port \;2$ 功率的两倍。<ul>
<li>目标函数：$Power31-2Power21=0$</li>
</ul>
</li>
</ul>
<h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><blockquote>
<p>Optimetrics -&gt; Add -&gt; Parametric </p>
<p><img src="./扫描变量声明.png" alt="扫描变量声明"></p>
</blockquote>
<p><img src="./输出变量声明.png" alt="输出变量声明"></p>
<p><img src="./扫描变量内容.png" alt="扫描变量内容"></p>
<h1 id="参数扫描分析"><a href="#参数扫描分析" class="headerlink" title="参数扫描分析"></a>参数扫描分析</h1><blockquote>
<p>在 $Offset$ 变量条件下分析即可</p>
</blockquote>
<p><img src="./变量结果输出.png" alt="变量结果输出"></p>
<p><img src="./随Offset的变化图.gif" alt="随Offset的变化图"></p>
<h1 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h1><p><img src="./优化函数设计.png" alt="优化函数设计"></p>
<blockquote>
<p>设置完优化函数后，在优化函数选项下分析即可</p>
</blockquote>
<p><img src="./优化结果列表.png" alt="优化结果列表"></p>
<h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><img src="./最终结果.png" alt="最终结果"></p>
<p><img src="./表面磁场分布.png" alt="最终表面磁场分布"></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS功能概述</title>
    <url>/AlanTuringLi/2023/11/06/HFSS%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>截止到目前，这篇博客的主要内容来自《HFSS 射频仿真设计 实例大全》。</p>
</blockquote>
<h1 id="text-HFSS-功能概述"><a href="#text-HFSS-功能概述" class="headerlink" title="$\text{HFSS}$ 功能概述"></a>$\text{HFSS}$ 功能概述</h1><ul>
<li>$\text{HFSS}$ 基础知识</li>
<li>$\text{HFSS}$  的边界条件</li>
<li>$\text{HFSS}$ 中的激励源</li>
<li>$\text{HFSS}$ 仿真常用设置</li>
</ul>
<h2 id="text-HFSS-基础知识"><a href="#text-HFSS-基础知识" class="headerlink" title="$\text{HFSS}$ 基础知识"></a>$\text{HFSS}$ 基础知识</h2><ul>
<li><p>数值求解方法：$\text{HFSS}$ 利用有限元的方法（$\text{FEM}$）的数值求解方式进行求解。</p>
</li>
<li><p>自适应求解过程：<img src="./求解过程.png" alt="求解过程"></p>
</li>
<li><p>$\text{HFSS}$ 求解步骤：<img src="./求解步骤.png" alt="求解步骤"></p>
</li>
<li><p>$\text{HFSS}$ 三种求解方式：<strong>驱动模式</strong>、<strong>终端模式</strong>、<strong>本征模式</strong></p>
<ul>
<li><p>驱动模式：能够应对一般 $\text{HFSS}$ 的求解，尤其对包含微带、波导等传输线的模型适用。</p>
</li>
<li><p>终端模式：一般用于处理包含多种传输线、如求解处理信号完整性问题。</p>
</li>
<li><p>本征模式：一般用于用于求解给定结构模型的谐振频率。</p>
<blockquote>
<p>驱动模式和终端驱动模式很相似，两者的区别在于给出的结果类型。用驱动模型求解的S参数是用入射波和反射波的功率计算得到的，而用终端驱动模式求解的S参数是根据终端的电压和电流得到的。例如，在仿真共面波导或者平行微带传输线时，用驱动模型求解得到的是沿着结构传输的奇偶模，而终端驱动模式求解得到的是共模和差模。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="text-HFSS-的边界条件"><a href="#text-HFSS-的边界条件" class="headerlink" title="$\text{HFSS}$ 的边界条件"></a>$\text{HFSS}$ 的边界条件</h2><p> $\text{HFSS}$ 的边界条件处与两种目的：</p>
<ul>
<li>建立的模型为开放或者封闭的电磁模型，如天线需要建立开放的模型，而为波导建立封闭的模型 ；</li>
<li>简化电磁仿真模型，提高仿真速度。</li>
</ul>
<h3 id="提供的边界条件"><a href="#提供的边界条件" class="headerlink" title="提供的边界条件"></a>提供的边界条件</h3><ul>
<li>理想电（$\text{PEC}$）条件： $\text{HFSS}$ 的默认边界条件，可以应用在模型内部，电场方向在指定平面上与该平面垂直。 $\text{PEC}$ 条件可以指定给 $\text{2D}$ 的平面物体，代表该传输线是理想的无耗物体。</li>
<li>辐射边界条件：辐射边界条件在 $\text{HFSS}$ 里通常用来设置开放的模型，即允许电磁波传输到无穷远处，$\text{HFSS}$ 在边界条件处吸收电磁波。应注意的是，如果仿真天线，辐射边界条件必须放在辐射表面的四分之一波长之外。</li>
<li>理想匹配层（$\text{PML}$）边界条件：理想匹配层边界条件在 $\text{HFSS}$ 同样用来创建一个开放模型，仿真天线时同样可以选用它。</li>
<li>有限电导率边界条件：当创建的 $\text{2D}$ 平面模型需要模拟导体时可以使用有限导电率边界条件，在模拟薄带线时很有用。但有限电导率边界条件仅仅在模拟薄导带的厚度比趋肤深度厚的情况下才有效。</li>
<li>分层阻抗边界条件：分层阻抗边界条件用来指定具有不同层材料的导体为一层等效阻抗，它同时可以考虑导体表面的平整度。</li>
<li>阻抗边界条件：阻抗边界条件用于仿真具有方阻特性表面薄材料，如薄膜电阻等。</li>
<li>集成 $\text{RLC}$ 边界条件：集成 $\text{RLC}$ 边界条件主要模拟理想电阻、电感或者电容等集总元器件，可以模拟单个元件或者 $\text{RLC}$ 的并联电路。集成 $\text{RLC}$ 边界条件可以看成更近的电阻边界条件，可以直接指定电阻、电感、电容的值。无源的并联元器件可以直接指定边界条件的值，而串联的元器件则需在两个串联的 $\text{2D}$ 平面上指定两个独立 $\text{RLC}$ 边界条件。</li>
<li>对称边界条件：使用对称边界条件可以减小整个电路的仿真尺寸和仿真时间。 $\text{HFSS}$ 里有两种对称边界条件：<strong>电对称</strong> 和 <strong>磁对称</strong>。值得注意的是，使用终端驱动模式时不能使用该边界条件。在 $\text{HFSS}$ 里，对称边界条件代表理想电平面或者理想磁平面对称。使用对称边界条件可以只建立部分仿真电路，降低了设计的复杂度，从而缩短了仿真时间。当使用对称边界条件时，电场被迫平行于或者垂直于对称平面。当电对称平面时，电场垂直于该平面；当磁对称平面时，电场平行于该平面。</li>
<li>主从边界条件：当仿真模型包含有大量重复或者周期性的阵列结构时，主从边界条件在这种情况下将十分有用。通常主从边界条件用在无限天线阵列或者频率选择表面上。</li>
<li>理想磁边界条件：理想磁边界条件可以用来创建一个自然边界或者模拟一个理想磁导体，该边界条件可以应用在物体内部或者模型外边界。如果应用在内部，$\text{HFSS}$ 将迫使在该平面两边的磁场切向分量相等；如果应用在模型边界，磁边界条件等效于一个理想磁导体，磁场的切向分量为零。</li>
<li>从边界条件：通常在大的重复阵列结构中和主边界条件配合使用。</li>
</ul>
<h2 id="text-HFSS-中的激励源"><a href="#text-HFSS-中的激励源" class="headerlink" title="$\text{HFSS}$ 中的激励源"></a>$\text{HFSS}$ 中的激励源</h2><p>$\text{HFSS}$ 中有七中激励源：$Wave\;Port$、 $Lumped\;Port$ 、 $Floquet\;Port$ 、 $Incident \;Wave$ 、 $Current\;Sources$ 、 $Voltage\;Sources$ 和 $Magnetic\;Bias\;Sources$ 。</p>
<p>其中仅有 $Wave\;Port$、 $Lumped\;Port$、 $Floquet\;Port$、提供  $S$ 参数求解。其中 $Wave\;Port$  和 $Lumped\;Port$ 还提供完整的  $S\;,Y\;,Z$ 参数的求解。$Wave\;Port$ 还可以提供波阻抗、$\gamma$ 常数、传播常数等。</p>
<blockquote>
<p>当仿真环形器等铁氧体材料元器件时，Magnetic Bias Source将与Wave Port或者Lumped Port联合使用。仿真大的平面结构或者周期结构的模型，如无限大天线阵列、频率选择表面或者光子隙结构，Floquet Ports有很大的用处。Current Sources和Voltage Sources 能够提供理想的电流源和电压源，但是这两种激励模式只提供场信息，所以在一些RF设计场合使用有限制。</p>
<p>以下对常用的Wave Port和Lumped Port进行说明：</p>
<ul>
<li><p>Wave Port在HFSS里是最常用的激励方式，广泛应用在微带、带状线、同轴或波导传输线中，它必须位于求解模型的外边界面上。Wave Port 代表能量进入的区域。HFSS 在求解过程中计算γ常数，所以结果可以去嵌入进或者去嵌入出端口，S参数根据去嵌入化的长度自动计算得到。HFSS假想Wave Port连接一个半无限长的波导，该半无限长的波导与端口具有同样性质。HFSS首先计算Wave Port的二维解，然后把该解作为三维模型的源。同时，由于Wave Port是能量进入模型的区域，所以Wave Port尺寸的设置至关重要。</p>
</li>
<li><p>Lumped Port 是 HFSS 中另外一个常用的端口类型。类似于面电流源，可以激励常见的各种传输线。Lumped Port 应用在激励电压隙和其他 Wave Port 不方便的场合，它仅仅能应用在模型内部。Lumped Port仿真结果的信息没有Wave Port多，仿真结果包含S、Y和Z参数，没有γ参数或者波阻抗的信息，所以Lumped Port不能去嵌入化，但可以归一化。不像Wave Port，Lumped Port 能够支持单一模式的仿真。Lumped Port 只能定义在二维的平面上，且该二维平面要和两个导体的边缘相连。如图1.13所示，Lumped Port施加在连接微带线和地平面的矩形的上下中点上。当创建Lumped Port时，需要在端口上画一根积分线，且积分线必须在连接两个导体边缘线的中点上。同时需要指定该端口的阻抗，作为生成的S参数的参考阻抗。端口阻抗的值也决定了源的电压或者电流的大小。值得注意的是，当阻抗是个复数时，无源器件的S参数值不一定小于等于1。</p>
</li>
<li><img src="./WavePort和LumpedPort比较.png" alt="WavePort和LumpedPort比较">从表中可以看出，Wave Port和Lumped Port的几个重要区别为：① 位置不同，一个在外部，而一个在内部；② Wave Port 特别适合规格传输线端口，而 Lumped Port 对于BGA、bond-wire等不规则的结构很适合。</li>
</ul>
</blockquote>
<h2 id="text-HFSS-仿真常用设置"><a href="#text-HFSS-仿真常用设置" class="headerlink" title="$\text{HFSS}$ 仿真常用设置"></a>$\text{HFSS}$ 仿真常用设置</h2><h3 id="text-HFSS-求解频率和-text-delta-S-的设置"><a href="#text-HFSS-求解频率和-text-delta-S-的设置" class="headerlink" title="$\text{HFSS}$ 求解频率和 $\text{delta S}$ 的设置"></a>$\text{HFSS}$ 求解频率和 $\text{delta S}$ 的设置</h3><ul>
<li><p>$\text{HFSS}$ 设置的求解频率（$\text{Project Manager→Analysis→Add Solution Setup}$）决定了最大的初始有限元四面体的尺寸，是 $\text{HFSS}$ 对模型精确求解的频率，也是自使用求解的频率。求解频率设置的值必须是元器件的工作频率。如果仿真的是一个扫描频率，则求解频率的值为工作频率、扫描频率的中心值或者最高工作频率的 $\text{60\%～80\%}$ 之间。选用何种值取决于扫描频率的类型。通常情况下，天线的仿真中设置该值为工作频率，滤波器设置为通带的中心频率。</p>
</li>
<li><p>$\text{delta S}$ 的值是 $\text{HFSS}$ 判断仿真是否收敛的标准，是仿真结果收敛性呈现给使用者的直接体现。$\text{delta S}$ 是通过连续两次仿真的S参数的值计算得到的。一旦 $S$ 参数的幅度值和相位值的改变小于使用者预设的 $\text{delta S}$，则仿真即终止。如果一直没有达到预设的 $\text{delta S}$，则仿真的次数达到设置的最大的仿真次数时也终止。</p>
</li>
</ul>
<p><img src="./Solution_Setup.png" alt="Solution_Setup"></p>
<h3 id="最大精炼和最大仿真次数设置"><a href="#最大精炼和最大仿真次数设置" class="headerlink" title="最大精炼和最大仿真次数设置"></a>最大精炼和最大仿真次数设置</h3><p>最大精炼的设置是指每次自适应仿真四面体元素增加的最大比例；最大仿真次数是指为了达到收敛的目的，$\text{HFSS}$ 仿真最多的重复次数。如下图所示是最大精炼和最大仿真次数的设置界面。</p>
<p><img src="./image-20231107165653191.png" alt="image-20231107165653191"></p>
<p>自适应仿真应用 $\text{delta S}$、最大精炼和最大仿真次数控制仿真的程度。$\text{delta S}$ 和最大仿真次数决定了仿真什么时候停止。如果在达到最大仿真次数之前满足了 $\text{delta S}$ 的要求，则仿真也将停止；同时，如果仿真达到最大仿真次数，而仿真结果还没有收敛，则仿真同样也停止。</p>
<h3 id="频率扫描类型设置"><a href="#频率扫描类型设置" class="headerlink" title="频率扫描类型设置"></a>频率扫描类型设置</h3><p>频率扫描类型在下图中设置。HFSS提供了3种不同的频率扫描类型：离散扫描、快速扫描和插值扫描。选用何种扫描类型取决于使用者的需求。当需要知道一些特殊频率点场信息时，离散扫描比其他两种类型的速度要快；快速扫描通常使用在需要得到一段频率所有解的情况下；插值扫描通常用来解决从DC到高频的情况。</p>
<p><img src="./image-20231107170121684.png" alt="image-20231107170121684"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>虽然大部分内容都还是在照搬书上的，但这确实时无奈之举，但是等反复实操过后，这些基础的操作是应该逐渐掌握的，写这篇博客也是希望能给自己做一个操作手册。</p>
<p>这篇博客远远没有结束，每一个新的收获都会添加在这篇博客内。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS中的建模操作</title>
    <url>/AlanTuringLi/2023/11/12/HFSS%E4%B8%AD%E7%9A%84%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749472031&p=6&high_quality=1&danmaku=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<ul>
<li>基本物体模型 ($\text{Primitive}$) 的概念</li>
<li>创建基本物体模型的具体步骤和操作过程<ul>
<li>了解创建物体模型的两种方法、物体属性对话框的含义。</li>
<li>学习创建圆弧线、圆面、圆锥体及螺旋结构($\text{Helix}$)、平面螺旋结构($\text{Spiral}$)的过程</li>
</ul>
</li>
<li>物体的材料属性<ul>
<li>编辑物体材料库：添加新材料、编辑修改材料参数</li>
<li>设置物体材料：设置建模时的默认材料，查看和更改物体的材料</li>
</ul>
</li>
<li>鼠标的移动模式和捕捉模式($\text{Snap Mode}$)</li>
<li>改变视图操作和显示/隐藏物体模型</li>
<li>选择操作</li>
<li>物体模型的几何变换<ul>
<li>物体模型的移动方式($\text{Edit&gt;Arrange}$)：平移($\text{Move}$)、旋转移动($\text{Rotate}$)、镜像移动($\text{Mirror}$)</li>
<li>复制物体模型($\text{Edit&gt;Duplicate}$)：$\text{(Along Line)、(Around Axis)、(Mirror)}$</li>
<li>改变模型尺寸($\text{Edit&gt;Arrange&gt;Offset}$)：$\text{Edit&gt;Scale}$</li>
<li>通过扫描的方式创建物体($\text{Draw&gt;Sweep}$)</li>
</ul>
</li>
<li>物体的布尔操作<ul>
<li>$\text{Unite\quad Subtract\quad Intersect\quad Split\quad Imprint}$</li>
</ul>
</li>
<li>$\text{HFSS}$ 中的坐标系<ul>
<li>相对坐标系和面坐标系、设置当前坐标系</li>
</ul>
</li>
<li>建模相关选项设置</li>
</ul>
<h1 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h1><p><img src="./image-20231112144017589.png" alt="image-20231112144017589" style="zoom: 67%;" /><img src="./image-20231112144054027.png" alt="image-20231112144054027" style="zoom: 67%;" /></p>
<h1 id="创建基本物体模型"><a href="#创建基本物体模型" class="headerlink" title="创建基本物体模型"></a>创建基本物体模型</h1><ul>
<li>状态栏输入位置坐标及大小尺寸<img src="./image-20231112144612788.png" alt="image-20231112144612788"><img src="./image-20231112144706735.png" alt="image-20231112144706735"></li>
<li>属性对话框设置位置坐标及大小尺寸<img src="./image-20231112145035444.png" alt="image-20231112145035444"></li>
</ul>
<h2 id="属性对话框"><a href="#属性对话框" class="headerlink" title="属性对话框"></a>属性对话框</h2><p><img src="./image-20231112145522128.png" alt="image-20231112145522128"></p>
<ul>
<li>$\text{Name}$ ： 物体的名称。</li>
<li>$\text{Material}$ ： 物体的材料属性。<img src="./image-20231112145628252.png" alt="image-20231112145628252"><img src="./image-20231112145648402.png" alt="image-20231112145648402"></li>
<li>$\text{Solve Inside}$ ：物体内部场的分析。对于介质材料需要分析内部场，而良导体不需要。</li>
<li>$\text{Orientation}$ ：创建物体的默认参考方向。</li>
<li>$\text{Model}$ ：值为 $1$ 表示为实体物体，值为 $0$ 表示其并非实体物体。</li>
<li>$\text{Display Wireframe}$ ：物体的显示方式。值为 $0$ 以实体的方式显示，值为  $1$ 以边框的方式显示。</li>
<li>$\text{Material Appearance}$ ：采用具有材料特性的外形。</li>
<li>$\text{Color}$ ：物体的颜色。</li>
<li>$\text{Transparant}$ ：物体的透明度。</li>
</ul>
<p><img src="./image-20231112152945369.png" alt="image-20231112152945369"></p>
<p>可以在 $\text{Lines}$ 下找到一维的线模型，在 $\text{Sheets}$ 下找到二维的面模型，在 $\text{Solids}$ 下找到三维模型。</p>
<h2 id="螺旋结构-text-Helix"><a href="#螺旋结构-text-Helix" class="headerlink" title="螺旋结构 ($\text{Helix}$)"></a>螺旋结构 ($\text{Helix}$)</h2><p>创建螺旋结构的操作需要选中一维线模型或者二维平面模型后才能激活，软件以选中的线模型或者面模型为横截面，沿着指定的方向螺旋盘升生成螺旋结构模型，模型底圈的半径是设定的方向矢量到选中的线模型/面模型中心的距离；选中一维线模型生成的是中空的螺旋体，选中二维平面模型生成的是实心的螺旋体。</p>
<p><img src="./image-20231112154255973.png" alt="image-20231112154255973"></p>
<p><img src="./image-20231112154320861.png" alt="image-20231112154320861"></p>
<h2 id="通过-text-Sweep-生成模型"><a href="#通过-text-Sweep-生成模型" class="headerlink" title="通过 $\text{Sweep}$ 生成模型"></a>通过 $\text{Sweep}$ 生成模型</h2><p><img src="./image-20231112191244573.png" alt="image-20231112191244573"></p>
<h1 id="物体的材料属性"><a href="#物体的材料属性" class="headerlink" title="物体的材料属性"></a>物体的材料属性</h1><ul>
<li>各项同性材料：<ul>
<li>相对介电常数</li>
<li>相对磁导率</li>
<li>电导率</li>
<li>介质损耗正切</li>
<li>磁损耗正切</li>
</ul>
</li>
<li>各项异性材料</li>
<li>铁氧体材料<ul>
<li>磁饱和度</li>
<li>朗德因子</li>
<li>磁共振线宽</li>
</ul>
</li>
</ul>
<h2 id="编辑材料属性"><a href="#编辑材料属性" class="headerlink" title="编辑材料属性"></a>编辑材料属性</h2><p>$\text{Tools &gt; Edit Libraries &gt; Materials &gt; Add Material…}$<br><img src="./image-20231112174238041.png" alt="image-20231112174238041"><br><img src="./image-20231112174438049.png" alt="image-20231112174438049"></p>
<p>将 $\text{Type}$ 属性修改为 $\text{Anisotropic}$ 后可以修改各向异性材料的属性。</p>
<p><img src="./image-20231112174530678.png" alt="image-20231112174530678"></p>
<p>可以看见还有 $\text{Tensor}$ 和 $\text{Nonelinear}$ ，分别表示可以以 张量 和 非线性函数 的形式修改这个参数的特性。</p>
<p><img src="./image-20231112175027932.png" alt="image-20231112175027932"></p>
<p><img src="./image-20231112175041292.png" alt="image-20231112175041292"></p>
<p>但是一般来说用不到这两个选项。</p>
<h2 id="默认材料"><a href="#默认材料" class="headerlink" title="默认材料"></a>默认材料</h2><p><img src="./image-20231112175500482.png" alt="image-20231112175500482"></p>
<p>红框中的部分为建模时的默认材料，可以修改此选项。</p>
<h1 id="鼠标的移动模式"><a href="#鼠标的移动模式" class="headerlink" title="鼠标的移动模式"></a>鼠标的移动模式</h1><p><img src="./image-20231112175850090.png" alt="image-20231112175850090"></p>
<p><img src="./image-20231112175937953.png" alt="image-20231112175937953"></p>
<h2 id="text-Snap-Mode"><a href="#text-Snap-Mode" class="headerlink" title="$\text{Snap Mode}$"></a>$\text{Snap Mode}$</h2><p> $\text{Modeler &gt; Snap Mode}$</p>
<p><img src="./image-20231112180139788.png" alt="image-20231112180139788"></p>
<p>快捷方式中的图标：      <img src="./image-20231112180354359.png" alt="image-20231112180354359"></p>
<h1 id="改变视图操作和显示-隐藏物体模型"><a href="#改变视图操作和显示-隐藏物体模型" class="headerlink" title="改变视图操作和显示/隐藏物体模型"></a>改变视图操作和显示/隐藏物体模型</h1><p><img src="./image-20231112180849545.png" alt="image-20231112180849545"></p>
<p><img src="./image-20231112180947103.png" alt="image-20231112180947103"></p>
<p><img src="./image-20231112181139190.png" alt="image-20231112181139190"><img src="./image-20231112181148390.png" alt="image-20231112181148390"></p>
<p>还有按住 $\text{Alt}$ 按键在下图中的九个点位双击可以查看系统的预设视角。<img src="./屏幕截图 2023-11-12 181427.png" alt="屏幕截图 2023-11-12 181427"></p>
<h1 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h1><p><img src="./image-20231112182302642.png" alt="image-20231112182302642"></p>
<p>可以选择物体、表面、棱边、顶点或者上述三种的任意一种。</p>
<p>若像选中被遮挡的面，可以考虑旋转视图或者选中靠近的面，然后 $\text{Ctrl+B}$。</p>
<h1 id="物体模型的几何变换"><a href="#物体模型的几何变换" class="headerlink" title="物体模型的几何变换"></a>物体模型的几何变换</h1><h2 id="基础变换"><a href="#基础变换" class="headerlink" title="基础变换"></a>基础变换</h2><p><img src="./image-20231112190058383.png" alt="image-20231112190058383"></p>
<p>图中圈出的1、2、3分别为图形的移动、复制、以及多个图形的布尔操作。</p>
<p>改变模型尺寸：$\text{Edit&gt;Scale}$ ，该操作同时影响对象的坐标和尺寸大小。</p>
<p>$\text{Edit&gt;Arrange&gt;Offset}$ ，对三个维度的长度同时进行修改。</p>
<p><img src="./image-20231112190625169.png" alt="image-20231112190625169"></p>
<h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><blockquote>
<p>几个基础的就不提了。</p>
</blockquote>
<h2 id="text-Split"><a href="#text-Split" class="headerlink" title="$\text{Split}$"></a>$\text{Split}$</h2><p><img src="./image-20231112191644684.png" alt="image-20231112191644684"></p>
<h2 id="text-Imprint"><a href="#text-Imprint" class="headerlink" title="$\text{Imprint}$"></a>$\text{Imprint}$</h2><p><img src="./image-20231112191948822.png" alt="image-20231112191948822"></p>
<p>将 $\text{Tool Part}$  的部分投影到 $\text{Blank Part}$ 的表面。</p>
<p><img src="./image-20231112192132850.png" alt="image-20231112192132850"></p>
<h1 id="text-HFSS-中的坐标系"><a href="#text-HFSS-中的坐标系" class="headerlink" title="$\text{HFSS}$ 中的坐标系"></a>$\text{HFSS}$ 中的坐标系</h1><blockquote>
<p>这部分的内容主要针对 $\text{HFSS}$ 设计中局部坐标系的设计。</p>
</blockquote>
<p><img src="./image-20231112192342890.png" alt="image-20231112192342890"><br><img src="./image-20231112192430875.png" alt="image-20231112192430875"></p>
<p>工作树下的相对坐标系设置。<img src="./image-20231112192611679.png" alt="image-20231112192611679"></p>
<h2 id="面坐标系："><a href="#面坐标系：" class="headerlink" title="面坐标系："></a>面坐标系：</h2><p>选中一个面，并确定 $\text{x,y}$ 轴的方向。</p>
<p><img src="./image-20231112193425563.png" alt="image-20231112193425563"></p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>微波工程笔记</title>
    <url>/AlanTuringLi/2023/11/07/%E5%BE%AE%E6%B3%A2%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>我得承认现阶段不能很深刻的理解每一个公式的含义，目前这篇博客的目的仅仅是为了方便查找公式。</p>
<p>本书采用的是 $\text{MKS}$ 单位制，即用<strong>米</strong>作为长度单位，用<strong>千克</strong>作为质量单位，用<strong>秒</strong>作为时间单位。且带上标的书写体表示的是矢量场，表示坐标 $x, y, z$ 和时间变量 $t$ 的实函数。</p>
<p>有如下定义：</p>
<p>​    $\bar{\mathcal E}$ 电场强度，单位： $\mathrm{V/m}$</p>
<p>​    $\bar{\mathcal H}$ 磁场强度，单位： $\mathrm{A/m}$</p>
<p>​    $\bar{\mathcal D}$ 电位移矢量，单位： $\mathrm{C/m^2}$ （电通量密度）</p>
<p>​    $\bar{\mathcal{B}}$  磁感应强度，单位：$\mathrm{Wb/m^2}$ （磁通量密度）</p>
<p>​    $\bar{\mathcal M}$ （虚拟的）磁流密度，单位：$\mathrm{V/m^2}$ （暂时不理解）</p>
<p>​    $\bar{\mathcal J}$ 电流密度，单位： $\mathrm{A/m^2}$</p>
<p>​     $\rho$ 电荷密度，单位： $\mathrm{C/m^3}$</p>
<p>在真空中，电、磁场强度与其通量有如下关系：</p>
<script type="math/tex; mode=display">
\bar{\mathcal B}=\mu_0\bar{\mathcal H}\\
\bar{\mathcal D}=\epsilon_0\bar{\mathcal E}</script><p>其中 $\mu_0=4\pi\times10^{-7}\mathrm{H/m}$ 是真空磁导率， $\epsilon_0=8.854\times10^{-12}\mathrm{F/m}$ 是真空介电常数。</p>
</blockquote>
<h1 id="麦克斯韦方程组"><a href="#麦克斯韦方程组" class="headerlink" title="麦克斯韦方程组"></a>麦克斯韦方程组</h1><script type="math/tex; mode=display">
\begin{align}
\nabla\times\bar{\mathcal{E}}&=\frac{-\part\bar{\mathcal{B}}}{\part t}-\bar{\mathcal M}\\
\nabla\times\bar{\mathcal H}&=\frac{\part \bar{\mathcal D}}{\part t}+\bar{\mathcal J}\\
\nabla\cdot\bar{\mathcal D}&=\rho\\
\nabla\cdot\bar{\mathcal B}&=0
\end{align}</script><p>应为任何矢量的旋度的散度都为零，故有：</p>
<script type="math/tex; mode=display">
\nabla\cdot\nabla\times\bar{\mathcal E}=0=-\frac{\part}{\part t}(\nabla\cdot\bar{\mathcal B})-\nabla\cdot\bar{\mathcal M}</script><p>又因为不存在自由磁荷，故可以得到 $\nabla\cdot\bar{\mathcal M}=0$ ，即可以得到 $\nabla\cdot\bar{\mathcal B} = 0$。类似得，可以从式 $\mathrm{(3)}$ 中得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla\cdot\bar{\mathcal J}+\frac{\part}{\part t}(\nabla\cdot\bar{\mathcal D}) &= 0\\
\Rightarrow\nabla\cdot\bar{\mathcal J}+\frac{\part\rho}{\part t} &= 0
\end{aligned}</script><h2 id="散度定理"><a href="#散度定理" class="headerlink" title="散度定理"></a>散度定理</h2><script type="math/tex; mode=display">
\int\limits_{V}\nabla\cdot\bar A\mathrm dv=\oint\limits_{S}\bar  A\mathrm d\bar s</script><p>要证明：</p>
<script type="math/tex; mode=display">
\iiint\limits_{(v)}(\frac{\part P}{\part x} + \frac{\part Q}{\part y}+\frac{\part R}{\part z})\mathrm dV=\oiint\limits_{(S)}P\;\mathrm dy\;\wedge\;\mathrm dz+Q\;\mathrm dz\;\wedge\;\mathrm dx+R\;\mathrm dx\wedge\mathrm dy\newline</script><p>只需证明：</p>
<script type="math/tex; mode=display">
\iiint\limits_{(V)}\frac{\part R}{\part z}\mathrm dV=\oiint\limits_{(S)}R\;\mathrm dx\;\wedge\;\mathrm dy\newline</script><p>考虑左式，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\iiint\limits_{(V)}\frac{\part R}{\part z}\mathrm d V&=\iint\limits_{(\sigma_{xy})}\mathrm d\sigma\int_{z_1(x, y)}^{z_2(x, y)}\frac{\part R}{\part z}\mathrm d z\newline
&=\iint\limits_{(\sigma_{x,y})}\{R\;[x,\; y,\; z_2(x,\;y)]-R\;[x\;,y\;,z_1(x\;,y)]\}\mathrm d\sigma
\end{aligned}</script><p>再考虑右式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\quad\oiint\limits_{(S)}R\;\mathrm dx\;\wedge\;\mathrm dy
=&\iint\limits_{(S_{上 })}R\;\mathrm dx\;\wedge\;\mathrm d y+\iint\limits_{(S_{侧})}R\;\mathrm dx\;\wedge\;\mathrm d y+\iint\limits_{(S_{下})}R\;\mathrm dx\;\wedge\;\mathrm d y\newline
=&\iint\limits_{(\sigma_{xy})}R\;[x,\; y,\; z_2(x,\;y)]\mathrm d\sigma+0+\iint\limits_{(\sigma_{xy})}-R\;[x,\; y,\; z_1(x,\;y)]\mathrm d\sigma\newline
=&\iint\limits_{(\sigma_{xy})}\{R\;[x,\; y,\; z_2(x,\;y)]-R\;[x\;,y\;,z_1(x\;,y)]\}\mathrm d\sigma
\end{aligned}</script><p>即可以得到 左式 = 右式 ，再利用  $\nabla$ 算子转化为向量形式即可。</p>
<h2 id="斯托克斯定理"><a href="#斯托克斯定理" class="headerlink" title="斯托克斯定理"></a>斯托克斯定理</h2><script type="math/tex; mode=display">
\int\limits_{S}(\nabla\times\bar A)\cdot\mathrm d\bar s=\oint\limits_{C}\bar A\cdot\mathrm d\bar {\mathscr l}</script><p>这个的证明稍后。。。先🕊一下。。。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><script type="math/tex; mode=display">
\begin{align}
\oint_S\bar D\cdot\mathrm d\bar s&=\int_V\rho\mathrm dv=\mathcal Q\newline
\oint_S\bar B\cdot\mathrm d\bar s&=0\newline
\end{align}\newline</script><script type="math/tex; mode=display">
\oint_C\bar{\mathcal E}\cdot \mathrm d\bar l=-\frac{\part}{\part t}\int_S\bar{\mathcal B}\cdot\mathrm ds-\int_S\bar{\mathcal M}\cdot\mathrm d \bar s\newline
\oint_C\bar{\mathcal H\cdot\mathrm d\bar l}=\frac{\part}{\part r}\int_S\bar{\mathcal D}\cdot\mathrm d\bar s+\int_S\bar{\mathcal J}\cdot\mathrm d\bar s=\frac\part{\part r}\int_S\bar D\cdot\mathrm d\bar s+\mathcal I</script><p>引入复数，可以得到：</p>
<script type="math/tex; mode=display">
\bar{\mathcal E}=\hat xE_1\cos(\omega t+\phi_1)+\hat yE_2\cos(\omega t+\phi_2)+\hat zE_3\cos(\omega t+\phi_3)\newline
\Rightarrow\bar E=\hat xE_1e^{j\phi_1}+\hat yE_2e^{j\phi_2}+\hat zE_3e^{j\phi_3}</script><p>可以得到其振幅平方的平均值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\bar{\mathcal E}\right|_{av}^2&=\frac 1T\int_0^T\bar{\mathcal E}\cdot\bar{\mathcal E}\;\mathrm dt\newline
&=\frac 1T\int_0^T\left[E_1^2\cos^2(\omega t+\phi_1)+E_2^2\cos^2(\omega t+\phi_2)+E_3^2\cos^2(\omega t+\phi_3)\right]\newline
&=\frac12(E_1^2+E_2^2+E_3^2)=\frac12|\bar{E}|^2=\frac12\bar E\cdot\bar E^*
\end{aligned}</script><p>所以可以得到其均方根值 $|\bar E|_{rms}=\frac {|\bar E|}{\sqrt 2}$。</p>
<p>故，在时间依赖关系 $e^{j\omega t}$ 的假设下，向量形式的麦克斯韦方程组有：</p>
<script type="math/tex; mode=display">
\begin{align}
\nabla\times\bar{E}&=-j\omega\bar B-\bar M\newline
\nabla\times\bar H&=jw\bar D+\bar J\newline
\nabla\cdot\bar D&=\rho\newline
\nabla\cdot\bar B&=0
\end{align}</script><blockquote>
<p>感觉在电磁理论基础不够的条件下继续这样看公式的意义不大，所以打算先暂停这本书的学习，先把重点放在  $\mathrm {HFSS}$ 和 电磁理论基础 上。第一章后面的部分感觉都是利用麦克斯韦方程组解决一些相对实际的问题。</p>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>微波工程</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS中的激励方式</title>
    <url>/AlanTuringLi/2023/11/14/HFSS%E4%B8%AD%E7%9A%84%E6%BF%80%E5%8A%B1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="关于激励方式"><a href="#关于激励方式" class="headerlink" title="关于激励方式"></a>关于激励方式</h1><p>$\text{HFSS}$ 中，激励是一种定义在三维物体表面或者二维物体上的激励源，这种激励源可以是电磁波激励、电压源或者电流源。激励端口是一种允许能量进入或流出几何结构的特殊边界条件类型：</p>
<ul>
<li>波端口 ($\text{Wave Port}$)</li>
<li>集总端口 ($\text{Lumped Port}$)</li>
<li>$\text{Floquet}$ 端口 ($\text{Floquet Port}$)</li>
<li>$\text{Incident Wave}$</li>
<li>$\text{Voltage}$</li>
<li>$\text{Current}$</li>
<li>$\text{Magnetic Bias}$</li>
</ul>
<h2 id="1-波端口激励-text-Wave-Port"><a href="#1-波端口激励-text-Wave-Port" class="headerlink" title="1. 波端口激励 ($\text{Wave Port}$)"></a>1. 波端口激励 ($\text{Wave Port}$)</h2><p>默认的情况下，所有三维物体和背景之间的接触面都是理想的导体边界，没有能量可以进出:波端口设置在背景面上，用作模型的激励源并提供一个能量进入/流出的窗口。</p>
<p>$\text{HFSS}$ 软件设定入射到端口上的每个模式的平均功率为 $\text{1W}$ 。求解时，首先端口 $1$ 被 $\text{1W}$ 的信号激励，其他端口设置为 $\text{0W}$ : 在该解产生后，端口 $2$ 被 $\text{1W}$ 的信号激励，他端口设置为 $\text{0W}$，如此循环：最后的解是所有解的叠加。</p>
<p>波端口一般设置在背景平面上，不允许端口平面弯曲。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>对于给定横截面的波导或传输线，特定频率下有一系列的解满足相应的边界条件和麦克斯韦方程组，每个解都称之为一种模式，或者说一种波型。</p>
<p>通常，模式是根据电场和磁场沿导波系统传输方向上有无分量这一情况来命名的，假设导波系统沿 $\text{Z}$ 轴放置，上述分量是指 $\text{Z}$ 向的电场分量 $E<em>{\mathrm{Z}}$ 和磁场分量 $H</em>{\mathrm Z}$ 。对于 $E<em>{\mathrm Z} =0、H</em>{\mathrm Z}=0$ 一类的模，称之为横电磁模，即 $\text{TEM}$ 模: 对于 $E<em>{\mathrm Z} =0、H</em>{\mathrm Z}\ne 0$ 一类的模，称之为横电模，即 $\text{TE}$ 模：对于$E_{\mathrm z}\ne0、Hz=0$ 一类的模，称之为横磁模，即 $\text{TM}$ 模。</p>
<p>默认情况下，$\text{HFSS}$ 只计算主模，即模式 $\text{1}$。但是某些情况下，计算中包含高阶模式的影响是必须的。</p>
<h3 id="端口校准"><a href="#端口校准" class="headerlink" title="端口校准"></a>端口校准</h3><p>波端口必须被校准以确保一致的结果:校准的目的有两个:确定场的方向、设置电压积分路径。</p>
<p>积分校准线: 对于模式驱动 $\text{(Driven Modal)}$  ，波端口使用积分线校准，积分校准线具有以下作用：</p>
<ul>
<li>作为在端口对电场进行积分计算电压的积分路径 $\text{HFSS}$ 利用计算出的电压来计算波端口的特性阻抗。</li>
<li>定义每个波端口上场的正方向;对于任何一个波端口，$wt=0$ 时的场至少有两个方向，通过校准线来确定一个正方向；如果同一端口如果场有两个以上可能方向，如圆端口，这时使用极化电场 $\text{(Polarize E Field)}$ 的选项。</li>
</ul>
<p>对于有多个模式问题的求解，在定义波端口时每个模式都需要设置一个积分校准线。</p>
<h3 id="text-S-参数的归一化处理"><a href="#text-S-参数的归一化处理" class="headerlink" title="$\text S$ 参数的归一化处理"></a>$\text S$ 参数的归一化处理</h3><ul>
<li>模式：<ul>
<li>对于给定横截面的波导或传输线，特定频率下有一系列的场模式满足 $\text{Maxwell}$ 方程组，这些模式的线性叠加都可以在波导中存在；一般来说，传播常数和特性祖抗总是随着频率变化的，每个频点，都有相应的计算结果。</li>
</ul>
</li>
<li>广义 $\text S$  参数：<ul>
<li>正确定义了波端口后，$\text{HFSS}$ 在仿真计算中包括的每个模式在端口处都是完全匹配的；因此，每个模式的 $\text S$ 参数和波端口，将会根据不同频率下的特性祖抗进行归一化，这种类型的 $\text S$ 参数叫做广义 $\text S$ 参数。</li>
</ul>
</li>
<li>归一化 $\text S$  参数：<ul>
<li>在实验测量（如矢量网络分析仪)和）路仿真器 (如 $\text{ADS}$，$\text{Ansoft Designer}$ ) 使用的特性祖抗通常是常数（如 $\text{50}$ 欧姆），为了使 $\text{HFSS}$ 计算结果和合实验测量或电路仿真结果保持一致，$\text{HFSS}$ 计算得出的广义 $\text{S}$ 参数必须用常数特性阻抗进行归一化。</li>
</ul>
</li>
</ul>
<h3 id="端口平移-text-Deembed"><a href="#端口平移-text-Deembed" class="headerlink" title="端口平移 ($\text{Deembed}$)"></a>端口平移 ($\text{Deembed}$)</h3><p>$\text{De-embed}$ 功能是指平移端口的位置，查看其对计算结果的影响:选中使用端口平移功能，只影响数据后处理，$\text{HFSS}$不会重新进行仿真计算。$\text{HFSS}$端口平移中的正数表示参考平面向模型内部移动，负数则是向外延伸。</p>
<blockquote>
<p>对于三端口器件：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&[S_{deembed}]=[e^{\varkappa}][S][e^{\varkappa}]\newline
&[e^{\varkappa}]=
\begin{bmatrix}
e^{\gamma_1l_1} & 0 & 0\newline
0 & e^{\gamma_2l_2} & 0\newline
0 & 0 & e^{\gamma_3l_3}
\end{bmatrix}
\end{aligned}</script></blockquote>
<h2 id="2-集总端口激励-text-Lumped-Port"><a href="#2-集总端口激励-text-Lumped-Port" class="headerlink" title="2. 集总端口激励 ($\text{Lumped Port}$)"></a>2. 集总端口激励 ($\text{Lumped Port}$)</h2><p>集总端口激励和波端口激励是 $\text{HFSS}$ 中最常用的两种激励方式。集总端口类似于传统的波端口，与波端口不同的是集总端口可以设置在物体模型内部，且用户需要设定端口阻抗；集总端口直接在端口处计算 $\text{S}$ 参数，设定的端口阻抗即为集总端口上 $\text{S}$ 参数的参考阻抗；另外集总端口不计算端口处的传播常数，因此根据集总端口无法进行端口平移操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>$\text{Wave Port}$</th>
<th>$\text{Lumped Port}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\text{Accessibility}$</td>
<td>$\text{External Faces}$</td>
<td>$\text{Internal to Model}$</td>
</tr>
<tr>
<td>$\text{Higher order modes}$</td>
<td>$\text{Yes}$</td>
<td>$\text{No}$</td>
</tr>
<tr>
<td>$\text{De-embedding}$</td>
<td>$\text{Yes}$</td>
<td>$\text{No}$</td>
</tr>
<tr>
<td>$\text{Re-normalization}$</td>
<td>$\text{Yes}$</td>
<td>$\text{Yes}$</td>
</tr>
<tr>
<td>$\text{Setup complexity}$</td>
<td>$\text{Moderate}$</td>
<td>$\text{Low}$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-text-Floquet-端口激励"><a href="#3-text-Floquet-端口激励" class="headerlink" title="3. $\text{Floquet}$ 端口激励"></a>3. $\text{Floquet}$ 端口激励</h2><p>$\text{Floquet}$ 端口基于 $\text{Floquet}$ 模式进行场求解，用于二维平面周期性结构的仿真设计，如平面相控阵列和频率选择表面等类型的问题。</p>
<p>与波端口的求解方式类似，$\text{Floquet}$ 端口求解的反射和传输系数能够以 $\text{S}$ 参数的形式显示；使用 $\text{Floquet}$ 端口激励井结合周期性边界，能够像传统的波导端口激励一样轻松地分析周期性结构的电磁特性，从而避免了场求解器复杂的后处理过程。</p>
<p>平面周期性结构可以看作由一个个单元 $\text{(Unit Cell)}$ 组成，使用 $\text{Floquet}$ 端口和主从边界条件分析平面周期结构，用户只需要建立一个单元模型，在设置 $\text{Floquet}$ 端口激励时需要指定端口的栅格坐标系统 $\text{(Lattice Coordinate System)}$，该坐标系统的 $\text{a，b}$ 轴分别表示单元的排列方向。</p>
<p>需要注意的是：</p>
<ul>
<li>只有驱动模式求解类型 $\text{(Modal Driven Solution)}$ 的设计可以使用 $\text{Floquet}$ 端口。</li>
<li>$\text{Floquet}$ 端口不支持快速扫频的方式，但是可以支持离散扫频和插值扫频。</li>
<li>$\text{Floquet}$  端口的四周必须与主从边界条件相连。</li>
</ul>
<h2 id="4-入射波激励-text-Incident-Wave"><a href="#4-入射波激励-text-Incident-Wave" class="headerlink" title="4. 入射波激励 ($\text{Incident Wave}$)"></a>4. 入射波激励 ($\text{Incident Wave}$)</h2><p>是自定义的朝某一特定方向传播的电磁波，其等相位面与传播方向垂直；入射波照射到器件表面和器件表面的夹角称为入射角。入射波激励常用于雷达反射截面 ($\text{RCS}$) 问题的计算。</p>
<p>需要设置的参数有：</p>
<ul>
<li>波的传播方向 ($\text{Poynting Vector}$)；</li>
<li>电场强度以及电场的方向。</li>
</ul>
<h2 id="5-电压源激励-text-Voltage…"><a href="#5-电压源激励-text-Voltage…" class="headerlink" title="5. 电压源激励 ($\text{Voltage…}$)"></a>5. 电压源激励 ($\text{Voltage…}$)</h2><p>电压源激励定义在两层导体之间的平面上，用理想电压源来表示该平面上的电场激励。需要设置的参数有：电压的幅度、相位以及电场的方向。</p>
<p>需注意：</p>
<ul>
<li>电压源激励所在的平面必须远小于工作波长，且平面上的电场是恒定电场。</li>
<li>电压源激励是理想的源，没有内阻，因此后处理时不会输出 $\text{S}$ 参数。</li>
</ul>
<h2 id="6-电流源激励-text-Current"><a href="#6-电流源激励-text-Current" class="headerlink" title="6. 电流源激励 ($\text{Current}$)"></a>6. 电流源激励 ($\text{Current}$)</h2><p>电流源激励定义于导体表面或者导体表面的缝隙上，用理想电流源来表示该平面上激励。需要设定的参数有导体表面缝隙的电流幅度、相位和方向。</p>
<p>需注意：</p>
<ul>
<li>电流源激励所在的平面/缝隙必须远小于工作波长，且平面/缝隙上的电流是恒定的。</li>
<li>电流源激励是理想的源，没有内阻，因此后处理时不会输出 $\text{S}$ 参数。</li>
</ul>
<h2 id="7-磁偏置激励-text-Magnetic-Bias"><a href="#7-磁偏置激励-text-Magnetic-Bias" class="headerlink" title="7. 磁偏置激励 ($\text{Magnetic Bias}$)"></a>7. 磁偏置激励 ($\text{Magnetic Bias}$)</h2><p>创建一个铁氧体材料时，必须通过设置磁偏置激励来定义网格的内部偏置场：该偏置场使得铁氧体中的磁性偶极子规则排列，产生一个非零的磁矩：</p>
<ul>
<li>如果应用的偏置场是均匀的，张量坐标系可以通过旋转全局坐标系来设置；</li>
<li>如果应用的偏置场是非均匀的，不允许旋转全局坐标来设置张量坐标系。</li>
</ul>
<p>均匀偏置场的参数可以由 $\text{HFSS }$直接输入，i而非均匀偏置场的需要从其它的静磁求解器 (如 $\text{Ansoft}$ $\text{Maxwell}$ $\text{3D}$ 软件) 导入。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS中的边界条件</title>
    <url>/AlanTuringLi/2023/11/12/HFSS%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="关于边界条件"><a href="#关于边界条件" class="headerlink" title="关于边界条件"></a>关于边界条件</h1><p>在电磁场理论学习中我们知道，电磁场问题的求解都归结于麦克斯韦 ($\text{Maxwell}$) 方程组的求解在 $\text{HFSS}$ 中波动方程的求解同样是由微分形式的麦克斯韦方程推导出来的。而边界条件定义了求解区域的边界以及不同物体交界处的电磁场特性，是求解麦克斯韦方程的基础。<br>只有在假定场矢量是单值、有界、并且沿空间连续分布的前提下，微分形式的麦克斯韦方程组才是有效的；而在求解区域的边界、不同介质的交界处私场源处，场矢量是不连续的，那么场的导数也就失去了意义。边界条件就是定义跨越不连续边界处的电磁场的特性，因此，正确地理解、定义并设置边界条件，是正确使用 $\text{HFSS}$ 仿真分析电磁场场特性的前提。<br>使用 $\text{HFSS}$ 时，用户应该时刻意识到: 边界条件确定场。正确地使用边界条件，是$\text{HFSS}$能够仿真分析出准确结果的前提。</p>
<h1 id="调整边界条件的优先级"><a href="#调整边界条件的优先级" class="headerlink" title="调整边界条件的优先级"></a>调整边界条件的优先级</h1><p><img src="./HFSS中的边界条件/image-20231112203416703.png" alt="image-20231112203416703"></p>
<h1 id="边界条件的详细说明"><a href="#边界条件的详细说明" class="headerlink" title="边界条件的详细说明"></a>边界条件的详细说明</h1><p>在<a href="https://alanturingli.gitee.io/alanturingli/2023/11/06/HFSS功能概述/">这篇</a> $\text{Blog}$ 中有简单提到边界条件的大致使用，这里详细展开说明一下。</p>
<h2 id="1-理想导体边界条件-text-Perfect-E"><a href="#1-理想导体边界条件-text-Perfect-E" class="headerlink" title="1. 理想导体边界条件 $\text{Perfect E}$"></a>1. 理想导体边界条件 $\text{Perfect E}$</h2><p>$\text{Perfect E}$ 是一种理想电导体或简称为理想导体边界条件。这种边界条件的电场垂直于表面。有两种边界被自动设为理想导体边界条件：</p>
<ul>
<li><p>任何与背景相关联的物体表面将被自动定义为理想导体边界，并命名为 $\text{outer}$ 边界</p>
</li>
<li><p>材料设为 $\text{PEC}$(理想电导体)的物体表面被自动定为理想导体边界，并命名为 $\text{smental}$</p>
</li>
</ul>
<blockquote>
<p>背景结构说明：</p>
<p>所谓背景是指几何模型周围没有被任何物体占据的空间，任何与背景有关联的物体表面被自动定义为理想导体边界，并命名为外部 $\text{(Outer)}$ 边界条件。</p>
<p>我们可以把几何结构想象为外面有一层很道而且是理想导体的材料，如之前创建的波导。</p>
<p>如有必要，也可以改变背景的边界条件，使其性质与理想导体边界条件不同</p>
</blockquote>
<h2 id="2-理想磁边界条件-text-Perfect-H"><a href="#2-理想磁边界条件-text-Perfect-H" class="headerlink" title="2. 理想磁边界条件 $\text{Perfect H}$"></a>2. 理想磁边界条件 $\text{Perfect H}$</h2><p>$\text{Perfect H}$ 是一种理想的磁边界，这种边界条件上的电场方向与表面相切，磁场与表面垂直，真实世界中不存在理想磁边界，它只是理论上的约束条件。</p>
<blockquote>
<p>自然边界 $\text{(Natural)}$ ：</p>
<p>当理想导体边界和理想磁边界出现交叠时，理想磁边界也被称为自然 $\text{(Natural)}$ 边界</p>
<p>背景设置成 $\text{Perfect H}$ 边界条件，可以模拟开放的自由空间</p>
<p>在理想导体边界上叠加理想磁边界将去掉理想导体边界的特性，相当于在理想导体表面开个口，允许电场穿过</p>
</blockquote>
<h2 id="3-有限导体边界条件-text-Finite-Conductivity"><a href="#3-有限导体边界条件-text-Finite-Conductivity" class="headerlink" title="3. 有限导体边界条件 $\text{Finite Conductivity}$"></a>3. 有限导体边界条件 $\text{Finite Conductivity}$</h2><p>有耗导体 / 非理想导体边界条件，电场垂直于物体表面，有限导体边界只在良导体模型下是有效的，即在给定的频率范围内，导体的厚度远远大于趋肤深度。需要设置的参数：导电率和导磁率。</p>
<h2 id="4-辐射边界条件-text-Radiation"><a href="#4-辐射边界条件-text-Radiation" class="headerlink" title="4. 辐射边界条件 $\text{Radiation}$"></a>4. 辐射边界条件 $\text{Radiation}$</h2><p>辐射边界也称为吸收边界 ($\text{Absorbing Boundary Condition}$)，简称 $\text{ABC}$ ，用以模拟开放的自由空间，模拟波辐射到空间的无限远处的情况，常用于天线问题的分析。</p>
<ul>
<li>当结构中包含辐射边界条件时，$\text{HFSS}$ 会自动计算结构的远区场。</li>
<li>$\text{Perfect H}$ 边界条件也可以模拟开放空间的情况，但该边界条件不计算远区场。</li>
<li>辐射边界条件是自由空间的近似，这种近似的准确程度取决于波的传播方向与辐射边界之间的角度，以及辐射源与边界之间的距离：<ul>
<li>可以是任意形状</li>
<li>辐射边界在各个方向上距离辐射体一般不小于 $\lambda/4$</li>
<li>入射能量和辐射边界表面正交时，计算结果最准确</li>
</ul>
</li>
</ul>
<h2 id="5-对称边界条件-text-Symmetry"><a href="#5-对称边界条件-text-Symmetry" class="headerlink" title="5.对称边界条件 $\text{Symmetry}$"></a>5.对称边界条件 $\text{Symmetry}$</h2><p>模拟理想电壁或理想磁壁对称面，应用对称边界可以在构造结构时仅构造一部分，减小结构的尺寸和设计复杂性，缩短计算时间。</p>
<ul>
<li>定义对称平面时，要遵循以下原则:<ul>
<li>对称平面必须暴露在背景中；</li>
<li>对称面必须定义在平面表面上，不能定义在曲面上；</li>
<li>在一个问题上最多只能定义三个正交对称面。</li>
</ul>
</li>
<li>决定对称面的类型<ul>
<li>如果电场垂直于对称面且对称，使用理想电壁对称面；</li>
<li>如果磁场垂直于对称面且对称，使用理想磁壁对称面。</li>
</ul>
</li>
<li>特性阻抗的计算：<ul>
<li>$Z_{\mathrm{pi}}=\frac{p}{I^2}$  ，适合微带线模型</li>
<li>$Z_{\mathrm{pu}} = \frac{U^2}P$ ，适合缝隙类结构</li>
<li>$Z_{\mathrm{ui}}=\frac{U}{I}$ ， 适合 $\mathrm{TEM}$ 波</li>
</ul>
</li>
<li>阻抗乘法器的定义<ul>
<li>理想电壁对称面将结构分成两部分时，只有一半的电压值和一半的能量被计算，由 $Z_{\mathrm{pu}} = U^2/P$<br> 计算出的阻抗也只有真实值的一半，所以需要定义 $2$ 倍的阻抗乘法器。</li>
<li>理想磁壁对称面将结构分成两部分时，只有一半的能量被计算，而电压保持不变，由 $Z_{\mathrm{pu}} =U^2/P$ 计算出的阻抗是真实值的 $2$ 倍，所以需要定义 $0.5$ 倍的阻抗乘法器。</li>
</ul>
</li>
<li>阻抗乘法器的设置<ul>
<li>在设置对称边界的弹出窗口中单击 $\mathrm{lmpedance\;Multiplier}$ 。</li>
</ul>
</li>
</ul>
<h2 id="6-阻抗边界条件-text-Impedance"><a href="#6-阻抗边界条件-text-Impedance" class="headerlink" title="6. 阻抗边界条件 $\text{Impedance}$"></a>6. 阻抗边界条件 $\text{Impedance}$</h2><p>用于模拟已知阻抗的边界表面,如薄膜电阻表面;表面的阻抗 $Z<em>{\mathrm s} = R</em>{\mathrm s} + i<em>{\mathrm{xs}}$，其中 $R_S$ 是以 $\text{Ohms/Square}$ 为单位的电阻， $X</em>{\mathrm s}$是以 $\text{Ohms/Square}$ 为单位的电抗。</p>
<ul>
<li>阻抗的计算：<ul>
<li>$\text{number\;of\;”Square” = Length (in direction of current flow) }\div\text{Width}$</li>
<li>$\text{Impedance per Square = Desired Lumped Impedance}\div\text{number of squares}$</li>
</ul>
</li>
<li>故需要手动设置以 $\text{Ohms/Square}$ 为单位的电阻 $R<em>{\mathrm s}$ 和电抗 $X</em>{\mathrm s}$ 。</li>
</ul>
<h2 id="7-集总-text-RLC-边界条件-text-Lumped-RLC"><a href="#7-集总-text-RLC-边界条件-text-Lumped-RLC" class="headerlink" title="7. 集总 $\text{RLC}$ 边界条件 $\text{Lumped RLC}$"></a>7. 集总 $\text{RLC}$ 边界条件 $\text{Lumped RLC}$</h2><p>类似于阻抗边界条件，利用用户提供的 $R、L、C$值计算出以 $\text{Ohms/Square}$ 为单位的阻抗值。</p>
<p>与阻抗边界不同的是，集总 $\text{RLC}$ 边界不需要提供以 $\text{Ohms/Square}$ 为单位的电阻和电抗，而是要给出 $R、L、C$ 的真实值；之后，$\text{HFSS}$ 就能确定任意频率下集总 $\text{RLC}$ 边界以 $\text{Ohms/Square}$ 为单位的阻抗。</p>
<h2 id="8-分层阻抗边界条件-text-Layered-Impedance"><a href="#8-分层阻抗边界条件-text-Layered-Impedance" class="headerlink" title="8. 分层阻抗边界条件  $\text{Layered Impedance}$"></a>8. 分层阻抗边界条件  $\text{Layered Impedance}$</h2><p>分层阻抗边界条件是用多层结构将物体表面模拟为一个阻抗表面，其效果与阻抗边界条件相同；与阻抗边界条件不同的是，对于分层阻抗边界条件，$\text{HFSS}$ 是根据输入的分层结构数据和表面粗糙度来计算表面电阻和表面电抗的，且不支持快速扫频。</p>
<h2 id="9-无限大地平面-text-Infinite-Ground-Plane"><a href="#9-无限大地平面-text-Infinite-Ground-Plane" class="headerlink" title="9. 无限大地平面 $\text{Infinite Ground Plane}$"></a>9. 无限大地平面 $\text{Infinite Ground Plane}$</h2><p>将有限大的边界表面模拟成无限大地平面的作用，设置无限大平面边界后，在后续处理中会影响近区、远区辐射场的计算。</p>
<ul>
<li>无限大平面边界的设置:在设置理想导体边界、有限导体边界或阻抗边界时选中 $\text{Infinite Ground Plane}$；</li>
<li>定义无限大地平面时，需要满足以下条件：<ul>
<li>无限大地平面必须暴露在背景上；</li>
<li>无限大地平面必须定义在平面上；</li>
<li>无限大地平面和对称面的总数不能超过 $3$ 个；</li>
<li>所有无限大地平面和对称面必须正交。</li>
</ul>
</li>
</ul>
<h2 id="10-主从边界条件-text-Master-and-Slave"><a href="#10-主从边界条件-text-Master-and-Slave" class="headerlink" title="10. 主从边界条件 $\text{Master and Slave}$"></a>10. 主从边界条件 $\text{Master and Slave}$</h2><p>主从边界条件也称为关联边界条件 ($\text{Linked Boundary Condition}$，简称 $\text{LBC}$ ) 用于模拟平面周期结构表面：如阵列天线结构。</p>
<p>主从边界条件包括主边界和从边界两种边界条件，二者总是成对出现的，且主边界表面和从边界表面的形状、大小和方向必须完全相同，主边界表面和从边界表面上的电场存在一定的相位差，该相位差就是周期性结构相邻单元之间存在的相位差。</p>
<script type="math/tex; mode=display">
\vec{E}_{\mathrm{Slave}}=e^{j\phi}\vec{E}_{\mathrm{Master}}=e^{j\frac d\lambda \sin\theta\cos\varphi}\vec{E}_{\mathrm{Master}}\newline
\phi=\frac d\lambda\sin\theta\cos\varphi</script><blockquote>
<p>定义主从边界表面时，需要正确设置 $\mathrm{U, V}$ 坐标系，保证主从边界表面大小和方向完全一致。</p>
<p>但是在我的 $\text{HFSS}$ 中这个选项叫做 $\text{Coupled}$。</p>
</blockquote>
<h2 id="11-理想匹配层-text-PML"><a href="#11-理想匹配层-text-PML" class="headerlink" title="11. 理想匹配层  $\text{PML}$"></a>11. 理想匹配层  $\text{PML}$</h2><p>理想匹配层 ( $\text{Perfectly Matched Layers}$，简称 $\text{PML}$ )，是能够完全吸收入射电磁波的假想的各项异性材料边界。理想匹配层有两种典型的应用： 一是用于外场问题中的自由空间截断，二是用于导波问题中的吸收负载。</p>
<p>对于导波的吸收负载，理想匹配层模拟导波结构均匀地延伸到无穷远处。</p>
<p>对于自由空间截断情况，理想匹配层的作用类似于辐射边界条件，$\text{PML}$ 表面能够完全吸收入射过来的电磁波。和辐射边界条件相比，理想匹配层因为能够完全吸收入射的电磁波，零反射，因此计算结果更精确：同时理想匹配层表面可以距离辐射体更近(差不多十分之一个波长即可)，不需要像辐射边界表面一般需要距离辐射体大于四分之一个波长。</p>
<h2 id="12-text-FE-BI"><a href="#12-text-FE-BI" class="headerlink" title="12. $\text{FE-BI}$"></a>12. $\text{FE-BI}$</h2><p>专门针对电大尺寸的开放结构仿真，对辐射体距离没有要求，能够完全吸收所有的入射波，与结构的共形性非常好，$\text{FE-BI}$ 算法可以有效降低计算机硬件资源消耗，针对外部辐射空间采用 $\text{IE}$ 求解，针对金属结构体采用 $\text{FEM}$ 求解，大幅减少辐射区域的求解规模，提升求解效率。</p>
<blockquote>
<p>当然，在 $\text{Ansys Electronic 2023 R1}$ 的版本中还有 $\text{Anisotropic Impedance}$, $\text{Aperture}$, $\text{Frenel(SBR+)}$, $\text{Half Space}$, $\text{Linked Impedance}$, $\text{Multipaction SEE}$ ，感觉这些边界条件一时半会儿用不上，就暂时不管了。</p>
</blockquote>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS求解类型和求解设置</title>
    <url>/AlanTuringLi/2023/11/15/HFSS%E6%B1%82%E8%A7%A3%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B1%82%E8%A7%A3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749565157&p=13&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<ul>
<li>学习如何选择求解类型，如何添加求解分析设置和扫频设置，以及如何运行仿真。</li>
<li>需求解类型有：模式驱动求解 ($\text{Driven Modal}$) 、终端驱动求解 ($\text{Driven Terminal}$) 以及本征模式求解 ($\text{Eigen Mode}$)。</li>
<li>求解分析设置包括自适应网格剖分频率（求解频率）的选择、收敛误差的确定、设置初始网格选项和选择基础函数。</li>
<li>设计检查和运行仿真。</li>
</ul>
<h2 id="text-HFSS-中的求解类型"><a href="#text-HFSS-中的求解类型" class="headerlink" title="$\text{HFSS}$ 中的求解类型"></a>$\text{HFSS}$ 中的求解类型</h2><ul>
<li>模式驱动求解：以模式为基础计算 $\text{S}$ 参数，根据导波内各模式场的入射功率和应射功率来计算 $\text{S}$ 参数矩阵的解。</li>
<li>终端驱动求解：以终端为基础计算多导体传输线端口的 $\text{S}$ 参数；此时，根据传输线终端的电压和电流来计算 $\text{S}$ 参数矩阵的解。</li>
<li>本征模式求解：本征模求解器主要用于谐振问题的设计分析，可以用于计算谐振结构的谐振频率和谐振频率处对应的场，也可以用于计算谐振腔体的无载 $\text{Q}$ 值。使用此模式求解释需要注意：<ul>
<li>不需要设置激励方式；</li>
<li>不能定义辐射边界条件；</li>
<li>不能进行扫频分析；</li>
<li>不能包含铁氧体材料；</li>
<li>只有场解结果，没有 $\text{S}$ 参数求解结果。</li>
</ul>
</li>
</ul>
<h2 id="自适应网格剖分"><a href="#自适应网格剖分" class="headerlink" title="自适应网格剖分"></a>自适应网格剖分</h2><blockquote>
<p>在分析对象内部搜索误差最大的区域并在该区域进行网格的细化，每次网格细化过程中网格增加百分比由用户事先设置。完成一次细化过程后，重新计算并搜索误差最大的区域，然后判断误差是否满足设置的收敛条件。如果满足收敛条件，则完成网格剖分：如果不满足收敛条件，继续下一次网格细化过程，直到满足收敛条件或者达到设置的最大迭代次数为止。</p>
</blockquote>
<p>$\text{HFSS}$ 软件采用有限元法 ($\text{FEM}$) 来分析三维物体的电磁特性，有限元法求解问题的基本过程包括分析对象的离散化、有限元求解和计算结果的处理 $\text{3}$ 个部分。研究对象的离散化是有限元法的第一步，$\text{HFSS}$ 软件采用自适应网格剖分技术，根据用户设置的误差标准，自动生成精确有效的网格，来完成分析对象的离散化。</p>
<p>自使用网格剖分时，每一次网格细化的迭代过程在 $\text{HFSS}$ 中称为一个 ”$\text{Pass}$”。</p>
<h3 id="收敛误差"><a href="#收敛误差" class="headerlink" title="收敛误差"></a>收敛误差</h3><p>自适应网格剖分过程中，每次网格细化后，$\text{HFSS}$ 会将基于当前网格的S参数 (或者能量、频率) 计算结果和上一次的计算结果相比较，如果求出的误差最大值小于设置的收敛标准，表示解已经收敛，自适应网格剖分计算完成。$\text{HFSS}$ 使用最后一次剖分的网格进行点频和扫频计算。不同的求解类型和端口激励方式对应不同的收敛误差判断方法，具体的收敛误差判断方法有$\Delta S，\Delta E$ 以及 $\Delta F$。</p>
<ul>
<li>波端口激励和集总端口激励问题使用 $\Delta S$ 最大值作为收敛误差判断标准。</li>
<li>电压源激励、电流源激励、入射波激励和磁偏置激励问题使用 $\Delta E$ 最大值作为收敛误差判断标准。</li>
<li>对于本征模求解类型，$\text{HFSS}$ 自动使用 $\Delta F$ 最大值作为收敛误差判断标准。</li>
</ul>
<p>以 $\Delta S$ 为例，$\Delta S$ 的最大值为：</p>
<script type="math/tex; mode=display">
\max\limits_{i,j}\quad \mathrm{mag}(\mathrm{S^N_{ij}}-\mathrm S^{N-1}_{ij})</script><h3 id="收敛精度"><a href="#收敛精度" class="headerlink" title="收敛精度"></a>收敛精度</h3><p>在设置收敛误差标准时，理论上把收敛误差设置的越小计算结果越精确。然而，一方面，收敛误差设置的越小意味着迭代次数越多，有时过小的误差值会极大地增加 $\text{HFSS }$的计算量；另一方面，在实际制造和实验室测量时都会有固定误差。</p>
<p>因此，$\text{HFSS}$ 只需要提供一定水平的准确性，这个准确性大于在真实世界中引入的固有误差就可以了。一般情况下，收敛误差使用 $\text{HFSS}$ 系统默认值或者取默认值的 $\text{1/2}$ 就足够了。</p>
<h2 id="网格自适应剖分频率（求解频率）的选择"><a href="#网格自适应剖分频率（求解频率）的选择" class="headerlink" title="网格自适应剖分频率（求解频率）的选择"></a>网格自适应剖分频率（求解频率）的选择</h2><p>$\text{HFSS}$ 计算时自适应网格剖分是在用户设定的单一频点上进行的，网格剖分完成后，同一个求解设置项下其他频点的求解，都是基于前面设定频点上所完成的网格划分。因此，自适应网格剖分频率的选择对最终求解的结果准确性有着重要的影响。</p>
<p>自适应频率设置的越高，网格剖分就越细，网格个数就越多，计算结果也相应地更加准确，但同时计算过程中所占用的计算机内存也就越高，计算所花费的时间也越长。</p>
<p>合适的自适应网格剖分频率的选择是在保证求解结果尽可能准确的前提下，占用尽可能少的计算机内存和花费尽可能短的计算时间。</p>
<p>下面给出几个常用问题类别的自适应频率的选择，以帮助在今后的设计中正确地设定自适应频率：</p>
<ul>
<li>点频或窄带问题：对于点频或者窄带问题，自适应网格剖分频率直接选择工作频率。</li>
<li>宽带问题：对于宽带问题，应该选择最高频率作为自适应网格剖分频率。</li>
<li>滤波器问题：对于滤波器问题，由于阻带内电场只存在于端口处，所以自适应频率选择在通带内的高频段。</li>
<li>快速扫频问题：对于快速扫频问题，典型的做法是选择中心频率作为自适应频率。</li>
<li>高速数字信号：对于高速数字信号完整性分析类问题，我们需要借助转折频率 ($\text{Knee Frequency}$) 来决定自适应网格剖分频率。</li>
</ul>
<h2 id="扫频分析"><a href="#扫频分析" class="headerlink" title="扫频分析"></a>扫频分析</h2><ul>
<li>离散扫频 $\text{Discrete}$：离散扫频是在频带内的指定频点处计算 $\text{S}$ 参数和场解。默认情况下，使用离散扫频只保存最后计算的频率点的场解。如果希望保存指定的所有频率点的场解，需要选中设置对话框中 $\text{SaveFields}$ 复选框。</li>
<li>快速扫频 $\text{Fast}$：采用 $\text{ALPS}$ 算法，在很宽的频带范围内搜寻出传输函数的全部零、极点。快速扫频适用于谐振问题和高 $\text Q$ 值问题的分析，可以得到场在谐振点附近行为的精确描述。使用快速扫频，一般选择频带中心频率作为自适应网格剖分频率，进行网格剖分，计算出该频点的 $\text{S}$ 参数和场分布，然后使用基于 $\text{ALPS}$ 算法的求解器从中心频率处的S参数解和场解来外推整个频带范围的 $\text{S}$ 参数解和场解。使用快速扫频，计算时只会求解中心频点处的场解，但在数据后处理时整个扫频范围内的任意频点的场都可以显示。</li>
<li>插值扫频 $\text{Interpolating}$ ：插值扫频使用二分法来计算整个频段内的 $\text {S}$ 参数和场解。使用插值扫频，$\text{HFSS}$ 自适应选择计算场解的频率点，并计算相邻两个频点之间的解的误差，找出最大误差，当两点之间的最大误差达到指定的误差收敛标准或者达到了设定的最大频点数目后，扫描完成;其它频率点上的 $\text S$ 参数和场解由内插给出。</li>
</ul>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HFSS变量设置及 $&#92;text{Optimetrics}$模块</title>
    <url>/AlanTuringLi/2023/11/16/HFSS%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749596441&p=14&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<p>$\text{HFSS}$ 作为一款功能强大的三维电磁仿真软件当然不是仅能够提供常规的电磁分析，它还能够提供优化设计、参数扫描分析、灵敏度分析和统计分析等功能，这些功能都集成在 $\text{HFSS}$ 的 $\text{Optimetrics}$ 模块中。在 $\text{HFSS}$ 中，要使用 $\text{Optimetrics}$ 模块的这些分析和设计功能，首先需要做的就是定义和添加相关变量。</p>
<ul>
<li>学习 $\text{HFSS}$ 中变量的定义和使用<ul>
<li>变量的类型</li>
<li>变量的定义</li>
<li>设计中如何添加 / 删除 / 使用变量</li>
</ul>
</li>
<li>简单学习 $\text{Optimetrics}$ 模块中的各种分析、设计功能及其使用<ul>
<li>参数扫描分析</li>
<li>优化设计</li>
<li>调谐分析</li>
<li>灵敏度分析</li>
<li>统计分析</li>
</ul>
</li>
</ul>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>和编程语言类似，$\text{HFSS}$ 中的变量也有自己的作用域，其类型分为工程变量（$\text{Project Variables}$）和设计变量/本地变量（$\text{Local Variables}$）。</p>
<blockquote>
<p>如何区分工程变量/本地变量？</p>
<ul>
<li>工程变量前有 “$” 前缀，而本地变量没有。</li>
<li>工程变量的作用区间为整个 $\text{Project}$ ，本地作用区间为所在的 $\text{Design}$。</li>
</ul>
</blockquote>
<p>$\text{Project &gt; Project Variables}$ 可以打开工程变量编辑对话框。</p>
<p>$\text{HFSS &gt; Design Properties}$ 可以打开设计变量编辑对话框。</p>
<p>物体模型尺寸、物体的材料属性等都可以使用变量来表示。</p>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><ul>
<li><p>变量名：</p>
<ul>
<li>变量名可以由 数字、字母、和下划线 “_” 组成。</li>
<li>$\text{HFSS}$ 中默认的常数（如： $\text{pi}$ ）、默认的数学函数（如：$\text{sin}$）不能用作变量名。</li>
<li>直角坐标系坐标轴的名称 $\text{X、Y、Z}$，圆柱坐标系和球坐标坐标轴的名称 $\text{Phi、Theta、R}$ (圆柱坐标系半径)、$\text{Rho}$（球坐标系半径）也不能用作变量名。</li>
</ul>
</li>
<li><p>变量值：每个变量在定义时都必须赋一个初始值，变量值可以是数值、数学表达式或者数学函数，也可以是数组、矩阵或者行列式。</p>
<ul>
<li>可以使用科学计数法。</li>
<li>可以使用数学表达式，但是需注意运算符的优先级。</li>
</ul>
</li>
</ul>
<h2 id="变量的添加、删除以及使用"><a href="#变量的添加、删除以及使用" class="headerlink" title="变量的添加、删除以及使用"></a>变量的添加、删除以及使用</h2><ul>
<li>添加/删除变量：<ul>
<li>$\text{Project &gt; Project Variables}$ 或者 $\text{[Project Tree] Project &gt; Project Variables}$ 打开 $\text{Project Properties}$ 对话框，可以添加和删除工程变量。</li>
<li>$\text{HFSS &gt; Design Properties}$ 或者 $\text{[Project Tree] Design &gt; Design Properties}$ 打开 $\text{Design}$<br> $\text{Properties}$ 对话框，可以添加和删除设计变量。</li>
<li>在设计过程中，也可以直接输入未定义的变量代替设计参数。输入未定义的变量后，$\text{HFSS}$会自动弹出添加变量对话框。</li>
</ul>
</li>
<li>使用变量<ul>
<li>在 $\text{HFSS}$ 中，几乎所有的设计参数都可以使用变量来表示，例如物体模型的尺寸、物体的材料属性、边界条件相关参数等。</li>
<li>对于已定义的变量，可以直接使用变量或者包含变量的表达式来表示设计参数。</li>
<li>对于未定义的变量后，$\text{HFSS}$会自动弹出添加变量对话框。</li>
</ul>
</li>
<li>注意：<ul>
<li>对于材料属性参数，只能使用工程变量。</li>
<li>每个变量在定义时都必须赋一个初始值，如果赋给变量的初始值已经指定了单位，在使用该变量时就不需要重新指定单位。</li>
<li>由于参数扫描、优化设计、调谐分析和灵敏度分析等不支持复数，所以对于值为复数的变量，不能用于上述分析。</li>
</ul>
</li>
</ul>
<h2 id="text-Optimetrics-模块"><a href="#text-Optimetrics-模块" class="headerlink" title="$\text{Optimetrics}$ 模块"></a>$\text{Optimetrics}$ 模块</h2><p>$\text{Optimetrics}$ 是集成在 $\text{HFSS}$ 中的设计优化模块，该模块通过自动分析设计参数的变化对求解结果的影响， $\text{HFSS}$ 中 $\text{Optimetrics}$ 模块能提供如下分析设计功能。</p>
<ul>
<li>参数扫描分析 $\text{Parametric}$<ul>
<li>参数扫描分析功能可以用来分析物体的性能随着指定变量的变化而变化的关系，在优化设计前一般使用参数扫描分析功能来确定被优化变量的合理变化区间。</li>
</ul>
</li>
<li>优化设计 $\text{Optimization}$<ul>
<li>忧化设计是 $\text{HFSS}$ 软件结合 $\text{Optimetrics}$ 模块根据特定的优化算法在所有可能的设计变化中寻找出一个满足设计要求的值的过程。</li>
</ul>
</li>
<li>调谐分析 $\text{Tuning}$<ul>
<li>调谐分析功能是在改变变量值的同时实时显示求解结果。</li>
</ul>
</li>
<li>灵敏度分析 $\text{Sensitivity}$<ul>
<li>灵敏度分析功能是用来分析设计参数的微小变化对求解结果的影响程度。</li>
</ul>
</li>
<li>统计分析 $\text{Statistical}$<ul>
<li>统计分析功能是利用统计学的观点来研究设计参数的容差对求解结果的影响常用的方法是蒙特卡罗（$\text{MonteCarlo}$）法。</li>
</ul>
</li>
</ul>
<h2 id="参数扫描分析"><a href="#参数扫描分析" class="headerlink" title="参数扫描分析"></a>参数扫描分析</h2><p>参数扫描分析功能是用来分析设计模型的性能随着指定变量的变化而变化的关系，在优化设计前一般使用参数扫描分析功能来确定被优化变量的合理变化区间。</p>
<p>操作步骤：</p>
<ul>
<li>设置首先需要定义变量并添加求解设置项。</li>
<li>$\text{HFSS&gt; Optimetrics Analysis &gt; Add Parametric…}$  弹出 $\text{Setup Sweep Anaysis}$ 对话框，添加扫描变量。</li>
<li>或者选中 $\text{Project Manager}$ 中的 $\text{Optimetrics}$，单击右键 $\text{Add &gt; Parametric}$，弹出 $\text{Setup}$ $\text{Sweep}$ $\text{Anaysis}$ 对话框，添加扫描变量。</li>
<li>设置好扫描变量之后，点击 ”$\text{Analyze}$” 就可以进行参数扫描分析。</li>
<li>查看分析设计结果。</li>
</ul>
<h2 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h2><p>优化设计是 $\text{HFSS}$ 软件结合 $\text{Optimetrics}$ 模块在一定的约束条件下根据特定的优化算法对设计的某些参数进行调整，从所有可能的设计变化中寻找出一个满足设计要求的值。优化设计时，首先需要明确设计要求或设计目标，然后用户根据设计要求创建初始结构模型 ($\text{Nominal Design}$) 、定义设计变量并构造目标函数，最后指定优化算法进行优化。</p>
<p>操作步骤：</p>
<ul>
<li><p>初始设计</p>
<ul>
<li>初始设计或者初始结构模型在 $\text{HFSS}$ 中称之为 $\text{Nominal Desiqn}$。用户一般根据理论知识和实际经验给出初始设计，创建初始结构模型。初始设计应该尽量接近真实值，否则会导致优化时间过长，有时甚至得不到全局最优解。</li>
</ul>
</li>
<li><p>添加优化变量</p>
<ul>
<li>在进行优化设计时，首先需要添加优化变量。打开工程变量/设计变量编辑对话框，单击选择变量编辑对话框中的 $\text{Optimization}$ 单选按钮，此时对话框内会列出当前设计中所定义的全部工程变量或者设计变量，勾选变量对应的 $\text{Include}$ 项复选框，把该变量添加为优化变量：同时在 $\text{Nominal Value}$、$\text{Min}$ 和 $\text{Max}$ 项下的文本框可以输入优化变量的初始值、最小值和最大值。</li>
<li>在优化设计前，一般先进行参数扫描分析，确定优化变量的初始值和合理的变化区间。</li>
</ul>
</li>
<li><p>构造目标函数</p>
<ul>
<li>在优化设计中，为了评价设计结果的好坏以及判断设计是否已经达到要求的目标，必须定义一个判据，软件根据这个判据来决定是否需要继续进行最优搜索，这个判据就称为目标函数。</li>
<li>目标函数需要用户根据具体的设计目标进行构造。例如<a href="https://alanturingli.gitee.io/alanturingli/2023/11/06/HFSS入门-波导优化设计/">T波导的优化设计</a>中就有详细提到操作流程。</li>
</ul>
</li>
<li><p>加权函数</p>
<ul>
<li>在有些设计中，为了达到设计要求，需要设置多个目标函数。另外，目标函数所包含的有些性能指标是互相矛盾或互相制约的，一般很难保证全部指标都达到最优。在这两种情况下，可以给每个目标函数分配一个加权值，加权值越大，表示该目标函数越重要。</li>
</ul>
</li>
<li><p>规范类型</p>
<ul>
<li><p>对于有多个目标函数的问题，误差函数值是所有目标函数误差值的加权和。 $\text{HFSS}$ 根据指定的规范类型来计算加权和。</p>
</li>
<li><script type="math/tex; mode=display">
L_1\Rightarrow e=\sum\limits_{1}^N|w_ie_i|\newline
L_2\Rightarrow e=\sum\limits_{1}^Nw_ie_i^2\newline
Max \Rightarrow e=\max\limits_{1}^N w_ie_i</script></li>
<li><p>默认为 $L_2$ 类型。</p>
</li>
</ul>
</li>
</ul>
<h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><ul>
<li>误差函数<ul>
<li>在定义目标函数时，目标函数可以是等于、大于等于或小于等于某个目标值:对应的，在优化设置对话框 $\text{Condition}$ 处分别选择 $&lt;=、=、&gt;=$ 。</li>
</ul>
</li>
<li>优化阈值<ul>
<li>优化阑值是优化过程终止的判别标准，当加权后总的误差值小于或等于优化阑值时，优化分析终止。优化设置对话框的左下角 $\text{Acceptable}$ 处设置优化阑值。</li>
<li>优化阑值可以是一个复数。</li>
</ul>
</li>
<li>目标噪声函数<ul>
<li>使用有限元法分析电磁问题时，网格剖分的变化会给目标函数引入各种噪声。在使用拟牛顿优化算法和模式搜索优化算法时，需要提供噪声的估算值，以评估求解过程中的变化对目标函数的影响。</li>
</ul>
</li>
</ul>
<h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><ul>
<li>拟牛顿法 $Quasi-Newton$<ul>
<li>牛顿法的基本思想是在极小点附近通过对目标函数做二阶泰勒（ $Taylor$ ）展开，进而找到的极小点的估计值。</li>
<li>拟牛顿法只有在目标函数的噪声很小的情况下使用是足够准确的，如果目标函数的噪声在工程是十分显著的，需要使用模式搜索优化算法来得到最优结果。</li>
</ul>
</li>
<li>模式搜索法 $Pattern\; Search$<ul>
<li>模式搜索法是求解最优化问题的一种直接搜索算法，它不用目标函数与约束函数的导数信息而只用函数值信息，是求解不可导或求导代价较大的最优化问题的一种有效算法。</li>
<li>模式搜索法是 $Hooke$ 和 $Jeeves$ 于 $1961$ 年提出的，这种优化方法对数值噪声不敏感，因此适合于数值噪声比较显著问题的 $\text{HFSS}$ 设计工程的优化。</li>
</ul>
</li>
<li>非线性顺序编程算法（$\text{SNLP}$） -    $Sequential\;Non\;Non-Linear\;Programming$<ul>
<li>类似拟牛顿法，$\text{SNLP}$算法中引入了噪声滤波和 $RSM$ ( $Response\;Surface\;Modeling$) 技术，可以适当地降低噪声的影响，收敛速度比拟牛顿法，结果比拟牛顿法准确。</li>
</ul>
</li>
<li>混合整数非线性顺序编程算法 ($\text{SMINLP}$)<ul>
<li>$\text{SMINLP}$ 能够优化同时具有连续变量和整数变量的问题，该算法和非线性顺序编程算法相似不同点是$\text{SMINLP}$ 算法需要标记出整数变量。</li>
</ul>
</li>
<li>溃传算法 - $\text{Genetic Algorithm}$<ul>
<li>遗传算法是 $20$ 世纪 $50$ 年代初由一些生物学家尝试用计算机模拟生物系统演化时提出的。运用随机而非确定性的规则对一族而非一个点进行全局而非局部地搜索，仅利用目标函数而不要求其导数信息或其他附加限制。遗传算法虽然在特定问题上也许不是效率最高的，但其效率远高于传统随机算法，是一种普遍用于各种问题的算法。</li>
</ul>
</li>
</ul>
<h2 id="调谐分析"><a href="#调谐分析" class="headerlink" title="调谐分析"></a>调谐分析</h2><p>$\text{HFSS}$ 中的调谐分析功能是用户在手动改变变量值的同时能实时显示求解结果。例如，在执行完成一个优化分析并且得到了变量的最优值之后，可以在该最优值附近手动改变变量的值，观察变量在最优值附近扰动对设计性能的影响。针对某一变量调谐分析结束后，设计结果将随之更新。</p>
<h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>使用 $\text{HFSS}$ 进行电磁分析的过程中，不同设计参数的变化对电磁特性的影响程度是不尽相同的。对于相同的变化量，有些参数对电磁特性的影响较大，有的则较小。为了衡量各个设计参数变化对电磁特性的影响，通常引用灵敏度的概念，用它来定量表示设计参数变化对电磁性能的影响程度。</p>
<p>灵敏度定义为电磁特性/求解结果的变化与电路参数的变化的比值。使用 $\text{HFSS}$ 进行电磁分析时，$S$ 参数是很常用的一个分析结果。这里，以 $S$ 参数为例来说明灵敏度的定义。假设 $X<em>i(i=1，2，…， m)$ 为某一设计参数，则第 $k、j$ 两端口之间的传输系数 $S</em>{jk} (k，j=1，2，…，n)$ 对设计参数 $X_i$ 的灵敏度可以定义为：</p>
<script type="math/tex; mode=display">
C_{x_i}^{s_{jk}}=\frac{\part S_{jk}}{\part X_i}</script><p>灵敏度计算可以在优化设计中确定电路的关键参数，大量的计算实践表明，有些最优化方法当变量增加时收敛速度变慢，有的甚至发散，这使优化设计毫无结果。如果在优化设计前进行灵敏度分析，找出那些对电路特性有较大影响（即灵敏度较高）的关键性设计参数，并将它们作为优化变量，则不仅能大大减少计算工作量，提高优化设计效率，而且能使原来不收敛的优化过程得到良好的结果。</p>
<h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><p>实际使用的元件或者制造工艺一般都有一定的误差，例如标称值为 $1nH$、容差为 $\pm 10\%$ 的二极管引线电感，其实际值将是 $0.9nH$ 到 $1.1nH$ 之间的随机值。因此，由这些元件所构成的电路模型或者这些制造工艺生产出的器件模型也具有随机特性，根据这种模型所求出的电路/电磁特性当然也是一些随机量。</p>
<p>统计分析就是利用统计学的观点来研究设计参数容差对求解结果的影响，常用的方法是蒙特卡罗（$\text{MonteCar lo}$）法。这种方法是利用计算机产生各种不同分布的伪随机数，来模拟产生各设计参数的随机值，并对由此形成的电路/器件模型进行分析，计算出表征电路/器件各种特性参数的随机量，然后对这些随机量进行统计分类或计算，画出统计分布图。</p>
<p>其具体分析步骤如下：</p>
<ul>
<li>用计算机产生伪随机数，并用它们模拟产生电路/器件各设计参数的随机值序列，然后将这些字列进行随机组合，形成电路/器件的统计分析模型；</li>
<li>调用分析程序对电路进行分析，计算出电路/器件的各种特性参数，如输入驻波比、$S$ 参数等；</li>
<li>对分析结果进行统计分类，画出直方图。</li>
</ul>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Optimetrics模块设计</title>
    <url>/AlanTuringLi/2023/11/20/Optimetrics%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><iframe src="//player.bilibili.com/player.html?aid=385016188&bvid=BV1vZ4y1q7gt&cid=749632133&p=15&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<p>$\text{Optimetrics}$ 简介参考<a href="https://alanturingli.gitee.io/alanturingli/2023/11/16/HFSS变量设置/">这篇博客</a>。</p>
<p>以一个微带线特征阻抗分析实例来学习 $\text{Optimetrics}$ 模块进行参数扫描分析、优化设计、调谐分析、以及灵敏度和统计分析的具体操作。</p>
<p>假设微带线的宽度为 $w$，介质层的厚度为 $h$，介质的相对介电常数为 $e$ ，根据理论分析可知，则微带线的特征阻抗：</p>
<script type="math/tex; mode=display">
Z_0=\frac{376.7}{2\pi\sqrt{\epsilon_e}}\ln\left[\frac{6+(2\pi-6)e^{-(\frac{30.67}{w/h})^{0.7528}}}{w/h}+\sqrt{1+(2h/w)^2}\right]\\
\epsilon_e=\frac{\epsilon_r+1}2+\frac{\epsilon_r-1}2(1+\frac{10h}w)^{-0.564(1+\frac1{49}
\ln\frac{(w/h)^2+(w/52h)^2}{(w/h)^2+0.432}+\frac1{18,7}\ln[1+\frac{w}{18.1h}])(\frac{s-0.9}{s+3})^{0.053}}</script><p>初始设计中，微带线材料为铜箔，厚度为 $35\mu m$ (1盎司)，宽度为 $1\mathrm{mm}$；介质层使用 $\text{FR4}$ 材料，厚度为$0.5\mathrm{mm}$，空气腔 长 X 宽 X 高为 $16\mathrm{mm}\times10\mathrm{mm}\times5\mathrm{mm}$ 。</p>
<p>选择模式驱动求解，空气腔的前后表面设置为波端口激励，求解频率设置为 $1\mathrm{GHz}$ 。</p>
<ul>
<li>定义和使用变量<ul>
<li>首先定义两个设计变量 $\text{width}$ 和 $\text{height}$ ，分别用于表示微带线的宽度和介质层的厚度。</li>
<li>因为微带线始终位于介质层正上方，同时为了让微带线始终位于介质层的中心位置，所以微带线起始点坐标也需要使用变量表示，坐标设置为 ($\text{-8mm，-width/2，height}$)。</li>
</ul>
</li>
<li>参数扫描分析<ul>
<li>分析微带线的特征阻抗随着微带线宽度 $\text{width}$ 和介质层厚度 $\text{height }$的变化关系。</li>
</ul>
</li>
<li>优化设计<ul>
<li>优化设计的目标是:当工作频率为 $\text{1GHZ}$ 时，在保持介质层厚度 $\text{height=0.5mm}$ 不变的情况下，改变微带线宽度 $\text{width}$，使微带线的特征阻抗达到 $50\Omega$。</li>
</ul>
</li>
<li>调谐分析<ul>
<li>手动改变变量 $\text{height}$ 和 $\text{Width}$ 的值，使用调协分析功能实时显示求解结果。</li>
</ul>
</li>
<li>灵敏度分析<ul>
<li>从优化分析结果可知，在 $\text{width} = 0.806\mathrm{mm}$，$\text{height} = 0.5\mathrm{mm}$ 时微带线的特征阻抗约为 $50\Omega$；这里在 $\text{width} = 0.806\mathrm{mm}，\text{height} =0.5\mathrm{mm}$ 附近分析两个变量的变化对微带线的特征阻抗的影响。</li>
</ul>
</li>
<li>统计分析<ul>
<li>假设 $\text{width}$ 和 $\text{height}$ 制造误差为 $\pm10\%$，且均匀分布，分析此时微带线的特征阻抗的统计分布情况。</li>
</ul>
</li>
</ul>
<h2 id="定义变量并进行参数扫描分析"><a href="#定义变量并进行参数扫描分析" class="headerlink" title="定义变量并进行参数扫描分析"></a>定义变量并进行参数扫描分析</h2><p>在特定 $\text{Hight}$ 下，微带线的特征阻抗随 $\text{Width}$ 的变化曲线：</p>
<p><img src="./Optimetrics模块设计/image-20231120203849139.png" alt="image-20231120203849139"></p>
<p>在特定 $\text{Width}$ 下，微带线的特征阻抗随 $\text{Hight}$ 的变化曲线：</p>
<p><img src="./Optimetrics模块设计/image-20231120204434452.png" alt="image-20231120204434452"></p>
<h2 id="对宽度进行优化分析"><a href="#对宽度进行优化分析" class="headerlink" title="对宽度进行优化分析"></a>对宽度进行优化分析</h2><p>设置优化范围并进行优化分析，通过优化数据再次仿真，得到数据：</p>
<p><img src="./Optimetrics模块设计/image-20231120221048766.png" alt="image-20231120221048766"></p>
<p>后面的几项设置也都是在 $\text{HFSS &gt; Properties}$ 中进行，就不列举了。</p>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>HFSS入门</tag>
      </tags>
  </entry>
  <entry>
    <title>pip换源操作</title>
    <url>/AlanTuringLi/2023/11/22/pip%E6%8D%A2%E6%BA%90%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="国内常用镜像源："><a href="#国内常用镜像源：" class="headerlink" title="国内常用镜像源："></a>国内常用镜像源：</h1><ul>
<li><p>中科大源：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://pypi.mirrors.ustc.edu.cn/simple</span><br></pre></td></tr></table></figure>
</li>
<li><p>清华源：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
</li>
<li><p>豆瓣</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
</li>
<li><p>阿里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
</li>
<li><p>华中科技大学</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://pypi.hustunique.com/</span><br></pre></td></tr></table></figure>
</li>
<li><p>山东理工大学</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://pypi.hustunique.com/</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜狐</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://mirrors.sohu.com/Python/</span><br></pre></td></tr></table></figure>
</li>
<li><p>百度</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://mirror.baidu.com/pypi/simple</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="修改默认源"><a href="#修改默认源" class="headerlink" title="修改默认源"></a>修改默认源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://mirror.baidu.com/pypi/simple</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>A Pixelated Microwave Near-Field Sensor for Precise Characterization of Dielectric Materials</title>
    <url>/AlanTuringLi/2023/11/27/A-Pixelated-Microwave-Near-Field-Sensor-for-Precise-Characterization-of-Dielectric-Materials/</url>
    <content><![CDATA[<link rel="stylesheet" href="/AlanTuringLi/css/spoiler.css" type="text/css"><script src="/AlanTuringLi/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
